<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Euclid</name>
    </assembly>
    <members>
        <member name="M:Euclid.Analytics.Clustering.KMeans`1.#ctor(System.Func{System.Collections.Generic.IEnumerable{`0},`0},System.Func{`0,`0,System.Double},System.Int32)">
            TODO: harden this function
        </member>
        <member name="M:Euclid.Analytics.Clustering.KMeans`1.Cluster(System.Collections.Generic.IList{`0},System.Int32)">
            <summary>Provides the centroïds for the </summary>
            <param name="data">the data to cluster</param>
            <param name="numberOfClasses">the target number of classes</param>
            <returns>an Enumerable of centroïds</returns>
        </member>
        <member name="T:Euclid.Analytics.Clustering.IDecisionNode`2">
            <summary>Interface for decision tree node</summary>
            <typeparam name="TI">the input type</typeparam>
            <typeparam name="TA">the answer type</typeparam>
        </member>
        <member name="M:Euclid.Analytics.Clustering.IDecisionNode`2.Evaluate(`0)">
            <summary>Evaluates the answer for a given input</summary>
            <param name="input">the input</param>
            <returns>an answer</returns>
        </member>
        <member name="P:Euclid.Analytics.Clustering.IDecisionNode`2.Depth">
            <summary>Returns the depth of the node</summary>
        </member>
        <member name="P:Euclid.Analytics.Clustering.IDecisionNode`2.Children">
            <summary>Counts the children of the node</summary>
        </member>
        <member name="P:Euclid.Analytics.Clustering.IDecisionNode`2.Clone">
            <summary>Clones the node</summary>
        </member>
        <member name="T:Euclid.Analytics.Clustering.DecisionNode`2">
            <summary>Decision tree node</summary>
            <typeparam name="TI">the input type</typeparam>
            <typeparam name="TA">the answer type</typeparam>
        </member>
        <member name="M:Euclid.Analytics.Clustering.DecisionNode`2.#ctor(Euclid.Analytics.Clustering.PrettyPredicate{`0},Euclid.Analytics.Clustering.IDecisionNode{`0,`1},Euclid.Analytics.Clustering.IDecisionNode{`0,`1})">
            <summary>Builds a decision tree node split according to a predicate</summary>
            <param name="predicate">the splitting predicate</param>
            <param name="trueBranch">the tree subpart if the predicate is met</param>
            <param name="falseBranch">the tree subpart if the predicate is not met</param>
        </member>
        <member name="P:Euclid.Analytics.Clustering.DecisionNode`2.Predicate">
            <summary>Returns the splitting predicate</summary>
        </member>
        <member name="P:Euclid.Analytics.Clustering.DecisionNode`2.Clone">
            <summary>Clones the node</summary>
        </member>
        <member name="P:Euclid.Analytics.Clustering.DecisionNode`2.True">
            <summary>Returns the tree subpart if the predicate is met </summary>
        </member>
        <member name="P:Euclid.Analytics.Clustering.DecisionNode`2.False">
            <summary>Returns the tree subpart if the predicate is not met</summary>
        </member>
        <member name="P:Euclid.Analytics.Clustering.DecisionNode`2.Depth">
            <summary>Returns the depth of the node</summary>
        </member>
        <member name="P:Euclid.Analytics.Clustering.DecisionNode`2.Children">
            <summary>Counts the children of the node</summary>
        </member>
        <member name="M:Euclid.Analytics.Clustering.DecisionNode`2.Evaluate(`0)">
            <summary>Evaluates the answer for a given input</summary>
            <param name="input">the input</param>
            <returns>an answer</returns>
        </member>
        <member name="T:Euclid.Analytics.Clustering.DecisionLeaf`2">
            <summary>Decision tree leaf</summary>
            <typeparam name="TI">the input type</typeparam>
            <typeparam name="TA">the answer type</typeparam>
        </member>
        <member name="M:Euclid.Analytics.Clustering.DecisionLeaf`2.#ctor(`1)">
            <summary>Builds a decision tree leaf</summary>
            <param name="answer">the fixed answer</param>
        </member>
        <member name="P:Euclid.Analytics.Clustering.DecisionLeaf`2.Answer">
            <summary>Returns the answer assigned to the leaf</summary>
        </member>
        <member name="P:Euclid.Analytics.Clustering.DecisionLeaf`2.Clone">
            <summary>Clones the node</summary>
        </member>
        <member name="P:Euclid.Analytics.Clustering.DecisionLeaf`2.Depth">
            <summary>Returns the depth of the node</summary>
        </member>
        <member name="P:Euclid.Analytics.Clustering.DecisionLeaf`2.Children">
            <summary>Counts the children of the node</summary>
        </member>
        <member name="M:Euclid.Analytics.Clustering.DecisionLeaf`2.Evaluate(`0)">
            <summary>Evaluates the answer for a given input</summary>
            <param name="input">the input</param>
            <returns>an answer</returns>
        </member>
        <member name="T:Euclid.Analytics.Clustering.PrettyPredicate`1">
            <summary>Decorated predicate class</summary>
            <typeparam name="TI">the input type</typeparam>
        </member>
        <member name="M:Euclid.Analytics.Clustering.PrettyPredicate`1.#ctor(System.String,System.Predicate{`0})">
            <summary>Builds a decorated predicate class</summary>
            <param name="description">the description of the predicate</param>
            <param name="predicate">the predicate</param>
        </member>
        <member name="P:Euclid.Analytics.Clustering.PrettyPredicate`1.Description">
            <summary>Returns the description of the predicate</summary>
        </member>
        <member name="P:Euclid.Analytics.Clustering.PrettyPredicate`1.Predicate">
            <summary>The predicate</summary>
        </member>
        <member name="P:Euclid.Analytics.Clustering.PrettyPredicate`1.Clone">
            <summary>Returns a clone of the pretty predicate</summary>
        </member>
        <member name="T:Euclid.Analytics.Entropy">
            <summary>Helper class for entropy calculations</summary>
        </member>
        <member name="M:Euclid.Analytics.Entropy.EntropyMetric(System.Int32[])">
            <summary>Entropy is a measure of unpredictability of information content. Here is used Shannon's entropy expressed in nat (base e)</summary>
            <param name="occurences">the occurences in each bucket</param>
            <returns>the entropy in natural bits of information</returns>
        </member>
        <member name="M:Euclid.Analytics.Entropy.InformationGain(System.Collections.Generic.List{System.Int32[]})">
            <summary>Change in information entropy from a prior state that takes some more information</summary>
            <param name="occurencesBuckets">the occurences in each bucket</param>
            <returns></returns>
        </member>
        <member name="M:Euclid.Analytics.Entropy.Redundancy(System.Int32[0:,0:])">
            <summary>Redundancy of information in the pair of variables</summary>
            <param name="occurences">the occurences in each bucket</param>
            <returns> 0 when the variables are independent and 1 when they are totally redundant</returns>
        </member>
        <member name="M:Euclid.Analytics.Entropy.Uncertainty(System.Int32[0:,0:],System.Int32[])">
            <summary>The uncertainty coefficient measures the validity of a classification</summary>
            <param name="occurences">the occurences in each cross bucket</param>
            <param name="normalizerOccurences">the normalizing variable occurence</param>
            <returns>the fraction of additional information</returns>
        </member>
        <member name="M:Euclid.Analytics.Entropy.MutualInformation(System.Int32[0:,0:])">
            <summary>Mutual information measures the amount of information that can be obtained about one random variable by observing another</summary>
            <param name="occurences">the occurences in each bucket</param>
            <returns>the mutual information in natural bits of information</returns>
        </member>
        <member name="T:Euclid.Analytics.ErrorFunctions.ManhattanError">
            <summary>
            Sum of squares error function
            </summary>
        </member>
        <member name="M:Euclid.Analytics.ErrorFunctions.ManhattanError.Function(Euclid.Vector,Euclid.Vector)">
            <summary>Calculates the Manhattan norm of the difference between the obtained vector and the expected vector</summary>
            <param name="x">the obtained vector</param>
            <param name="benchmark">the expected vector</param>
            <returns>the error</returns>
        </member>
        <member name="M:Euclid.Analytics.ErrorFunctions.ManhattanError.Function(System.Collections.Generic.List{Euclid.Vector},System.Collections.Generic.List{Euclid.Vector})">
            <summary>Calculates the sum of the Manhattan norms of the differences between the obtained and the expected vectors</summary>
            <param name="x">the list of obtained vectors</param>
            <param name="benchmark"></param>
            <returns>the sum of the errors</returns>
        </member>
        <member name="M:Euclid.Analytics.ErrorFunctions.ManhattanError.Gradient(Euclid.Vector,Euclid.Vector)">
            <summary>Calculates the gradient of the Manhattan norm, as observed from the obtained vector's value</summary>
            <param name="x">the obtained vector</param>
            <param name="benchmark">the obtained vector</param>
            <returns>a vector whose size is the same as the obtained vector</returns>
        </member>
        <member name="T:Euclid.Analytics.ErrorFunctions.SumOfSquares">
            <summary>
            Sum of squares error function
            </summary>
        </member>
        <member name="M:Euclid.Analytics.ErrorFunctions.SumOfSquares.Function(Euclid.Vector,Euclid.Vector)">
            <summary>
            Calculates the euclidian norm of the difference between the obtained vector and the expected vector
            </summary>
            <param name="x">the obtained vector</param>
            <param name="benchmark">the expected vector</param>
            <returns>the error</returns>
        </member>
        <member name="M:Euclid.Analytics.ErrorFunctions.SumOfSquares.Function(System.Collections.Generic.List{Euclid.Vector},System.Collections.Generic.List{Euclid.Vector})">
            <summary>
            Calculates the sum of the euclidian norms of the differences between the obtained and the expected vectors
            </summary>
            <param name="x">the list of obtained vectors</param>
            <param name="benchmark"></param>
            <returns>the sum of the errors</returns>
        </member>
        <member name="M:Euclid.Analytics.ErrorFunctions.SumOfSquares.Gradient(Euclid.Vector,Euclid.Vector)">
            <summary>
            Calculates the gradient of the euclidian norm, as observed from the obtained vector's value
            </summary>
            <param name="x">the obtained vector</param>
            <param name="benchmark">the obtained vector</param>
            <returns>a vector whose size is the same as the obtained vector</returns>
        </member>
        <member name="T:Euclid.Analytics.ErrorFunctions.IErrorFunction">
            <summary>
            Interface for error function
            </summary>
        </member>
        <member name="M:Euclid.Analytics.ErrorFunctions.IErrorFunction.Function(Euclid.Vector,Euclid.Vector)">
            <summary>
            Calculates the error
            </summary>
            <param name="x">the obtained vector</param>
            <param name="benchmark">the expected vector</param>
            <returns>the error</returns>
        </member>
        <member name="M:Euclid.Analytics.ErrorFunctions.IErrorFunction.Function(System.Collections.Generic.List{Euclid.Vector},System.Collections.Generic.List{Euclid.Vector})">
            <summary>
            Calculates the sum of the errors
            </summary>
            <param name="x">the list of obtained vectors</param>
            <param name="benchmark">the list of expected vectors</param>
            <returns>the sum of the errors</returns>
        </member>
        <member name="M:Euclid.Analytics.ErrorFunctions.IErrorFunction.Gradient(Euclid.Vector,Euclid.Vector)">
            <summary>
            Calculates the gradient of the error function, as observed from the obtained vector's value
            </summary>
            <param name="x">the obtained vector</param>
            <param name="benchmark">the obtained vector</param>
            <returns>a vector whose size is the same as the obtained vector</returns>
        </member>
        <member name="T:Euclid.Analytics.InterRelations">
            <summary>Class used to calculate statistic relationships between dataframes</summary>
        </member>
        <member name="M:Euclid.Analytics.InterRelations.CovarianceEstimatorMatrix``2(Euclid.DataStructures.IndexedSeries.DataFrame{``0,System.Double,``1})">
            <summary>Gets the covariance matrix between the series of the dataframe</summary>
            <typeparam name="T">the dataframes' legend types</typeparam>
            <typeparam name="TV">the dataframes' label types</typeparam>
            <param name="dataFrame">the underlying data frame</param>
            <returns>a dataFrame</returns>
        </member>
        <member name="M:Euclid.Analytics.InterRelations.CorrelationMatrix``2(Euclid.DataStructures.IndexedSeries.DataFrame{``0,System.Double,``1})">
            <summary>Gets the correlation matrix between the series of the dataframe</summary>
            <typeparam name="T">the dataframes' legend types</typeparam>
            <typeparam name="TV">the dataframes' label types</typeparam>
            <param name="dataFrame">the underlying data frame</param>
            <returns>a dataFrame</returns>
        </member>
        <member name="M:Euclid.Analytics.InterRelations.CorrelationMatrix``2(Euclid.DataStructures.IndexedSeries.DataFrame{``0,System.Double,``1},Euclid.DataStructures.IndexedSeries.DataFrame{``0,System.Double,``1})">
            <summary>Gets the cross-correlation between the time series of the input dataframes</summary>
            <typeparam name="T">the dataframes' legend types</typeparam>
            <typeparam name="TV">the dataframes' label types</typeparam>
            <param name="dataFrame1">the left hand side dataFrame</param>
            <param name="dataFrame2">the right hand side data frame</param>
            <returns>a dataFrame</returns>
        </member>
        <member name="M:Euclid.Analytics.InterRelations.RedundancyMatrix``2(Euclid.DataStructures.IndexedSeries.DataFrame{``0,System.Double,``1})">
            <summary>Gets the redundancy matrix of the series of the dataframe</summary>
            <typeparam name="T">the dataframe's legend types</typeparam>
            <typeparam name="TV">the dataframe's label types</typeparam>
            <param name="dataFrame">the underlying dataFrame</param>
            <returns>a dataframe</returns>
        </member>
        <member name="M:Euclid.Analytics.InterRelations.Correlogram(System.Double[],System.Int32[])">
            <summary>Returns the auto-correlogram for a data series (</summary>
            <param name="dataSeries">the input data series</param>
            <param name="lags">the lags for which the correlogram is calculated</param>
            <returns>an array of <c>double</c></returns>
        </member>
        <member name="T:Euclid.Analytics.LogisticModel">
            <summary>
            Stores the metrics of a logistic regression and allows prediction
            </summary>
        </member>
        <member name="M:Euclid.Analytics.LogisticModel.#ctor(System.Double,System.Double[],System.Double,System.Boolean)">
            <summary>Default constructor for a linear model</summary>
            <param name="constant">the constant term</param>
            <param name="factors">the regression coefficients</param>
            <param name="r2">the R squared</param>
            <param name="succeeded">the status of the regression</param>
        </member>
        <member name="M:Euclid.Analytics.LogisticModel.#ctor(System.Double,System.Double)">
            <summary> Builds a constant linear model</summary>
            <param name="constant">the constant</param>
            <param name="r2">the R squared</param>
        </member>
        <member name="M:Euclid.Analytics.LogisticModel.#ctor(System.Double,System.Double[],System.Double)">
            <summary> Builds a linear model for a succesful regression </summary>
            <param name="constant">the regression constant term</param>
            <param name="factors">the regression linear coefficients</param>
            <param name="r2">the R squared</param>
        </member>
        <member name="P:Euclid.Analytics.LogisticModel.Constant">
            <summary>Gets the constant term</summary>
        </member>
        <member name="P:Euclid.Analytics.LogisticModel.R2">
            <summary>Returns the R-squared</summary>
        </member>
        <member name="P:Euclid.Analytics.LogisticModel.Factors">
            <summary>Gets the linear terms</summary>
        </member>
        <member name="P:Euclid.Analytics.LogisticModel.Succeeded">
            <summary>specifies whether the regression succeeds</summary>
        </member>
        <member name="M:Euclid.Analytics.LogisticModel.ToString">
            <summary>Returns a string that represents the linear model</summary>
            <returns>a string that represents the linear model</returns>
        </member>
        <member name="M:Euclid.Analytics.LogisticModel.Predict(System.Collections.Generic.IList{System.Double})">
            <summary>Returns the estimator for the given set of data</summary>
            <param name="x">the set of regressors</param>
            <returns>the estimator of the regressed data</returns>
        </member>
        <member name="M:Euclid.Analytics.LogisticModel.Predict(Euclid.Vector)">
            <summary>Returns the estimator for the given set of data</summary>
            <param name="x">the set of regressors</param>
            <returns>the estimator of the regressed data</returns>
        </member>
        <member name="T:Euclid.Analytics.LinearModel">
            <summary>
            Stores the metrics of a linear regression and allows prediction
            </summary>
        </member>
        <member name="M:Euclid.Analytics.LinearModel.#ctor(System.Double,System.Double[],System.Double[],System.Int32,System.Double,System.Double,System.Boolean)">
            <summary>Default constructor for a linear model</summary>
            <param name="constant">the constant term</param>
            <param name="factors">the regression coefficients</param>
            <param name="correlations">the zero-degree correlations</param>
            <param name="sampleSize">the sample size</param>
            <param name="SSE">the sum of squared due to error</param>
            <param name="SSR">the sum of squared due to the regression</param>
            <param name="succeeded">the status of the regression</param>
        </member>
        <member name="M:Euclid.Analytics.LinearModel.#ctor">
            <summary>Builds a linear model for a failed regression</summary>
        </member>
        <member name="M:Euclid.Analytics.LinearModel.#ctor(System.Double,System.Int32,System.Double)">
            <summary> Builds a constant linear model</summary>
            <param name="constant">the constant</param>
            <param name="sampleSize">the sample size</param>
            <param name="SSE">the sum of squares due to error</param>
        </member>
        <member name="M:Euclid.Analytics.LinearModel.#ctor(System.Double,System.Double[],System.Double[],System.Int32,System.Double,System.Double)">
            <summary> Builds a linear model for a succesful regression </summary>
            <param name="constant">the regression constant term</param>
            <param name="factors">the regression linear coefficients</param>
            <param name="correlations">the zero-degree correlations</param>
            <param name="sampleSize">the sample size</param>
            <param name="SSE">the sum of squares due to the error</param>
            <param name="SSR">the sum of squares due to the regression</param>
        </member>
        <member name="P:Euclid.Analytics.LinearModel.Constant">
            <summary>Gets the constant term</summary>
        </member>
        <member name="P:Euclid.Analytics.LinearModel.Factors">
            <summary>Gets the linear terms</summary>
        </member>
        <member name="P:Euclid.Analytics.LinearModel.Correlations">
            <summary>Gets the correlations between the explanatory variables and the regressand </summary>
        </member>
        <member name="P:Euclid.Analytics.LinearModel.SampleSize">
            <summary>Gets the sample size</summary>
        </member>
        <member name="P:Euclid.Analytics.LinearModel.R2">
            <summary>Gets the R² on the sample data</summary>
        </member>
        <member name="P:Euclid.Analytics.LinearModel.AdjustedR2">
            <summary>Gets the adjusted R² on the sample data</summary>
        </member>
        <member name="P:Euclid.Analytics.LinearModel.Succeeded">
            <summary>Specifies whether the regression succeeds</summary>
        </member>
        <member name="P:Euclid.Analytics.LinearModel.SSE">
            <summary>Gets the sum of squares due to error</summary>
        </member>
        <member name="P:Euclid.Analytics.LinearModel.SSR">
            <summary>Gets the sum of squares due to the regression</summary>
        </member>
        <member name="P:Euclid.Analytics.LinearModel.SST">
            <summary>Gets the total sum of squares</summary>
        </member>
        <member name="M:Euclid.Analytics.LinearModel.ToString">
            <summary>Returns a string that represents the linear model</summary>
            <returns>a string that represents the linear model</returns>
        </member>
        <member name="M:Euclid.Analytics.LinearModel.Predict(System.Collections.Generic.IList{System.Double})">
            <summary>Returns the estimator for the given set of data</summary>
            <param name="x">the set of regressors</param>
            <returns>the estimator of the regressed data</returns>
        </member>
        <member name="M:Euclid.Analytics.LinearModel.Predict(Euclid.Vector)">
            <summary>Returns the estimator for the given set of data</summary>
            <param name="x">the set of regressors</param>
            <returns>the estimator of the regressed data</returns>
        </member>
        <member name="T:Euclid.Analytics.IPredictor`2">
            <summary>
            Interface for predictors
            </summary>
            <typeparam name="T">the predicted type</typeparam>
            <typeparam name="TU">the predictors type</typeparam>
        </member>
        <member name="M:Euclid.Analytics.IPredictor`2.Predict(System.Collections.Generic.IList{`1})">
            <summary>Prediction method</summary>
            <param name="x">the predictors</param>
            <returns>the prediction</returns>
        </member>
        <member name="T:Euclid.Analytics.NeuralNetworks.ActivationFunctions.ActivationFunctionHelper">
            <summary>
            ActivationFunction helper
            </summary>
        </member>
        <member name="M:Euclid.Analytics.NeuralNetworks.ActivationFunctions.ActivationFunctionHelper.ActivationFunction(System.String)">
            <summary>
            Builds an IActivationFunction object from its class name
            </summary>
            <param name="name">the name of the IActivationFunction class</param>
            <returns>an <c>IActivationFunction</c></returns>
        </member>
        <member name="P:Euclid.Analytics.NeuralNetworks.ActivationFunctions.ActivationFunctionHelper.ActivationFunctionsList">
            <summary>Returns a list of all the classes assignable from IActivationList</summary>
        </member>
        <member name="T:Euclid.Analytics.NeuralNetworks.ActivationFunctions.Algebraic">
            <summary>
            The algebraic activation function
            </summary>
        </member>
        <member name="M:Euclid.Analytics.NeuralNetworks.ActivationFunctions.Algebraic.Function(System.Double)">
            <summary>The algebraic function</summary>
            <param name="x">x</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Analytics.NeuralNetworks.ActivationFunctions.Algebraic.Derivative(System.Double)">
            <summary>The algebraic function's derivative</summary>
            <param name="x">x</param>
            <returns>a double</returns>
        </member>
        <member name="P:Euclid.Analytics.NeuralNetworks.ActivationFunctions.Algebraic.Max">
            <summary>The maximum value of the activation function</summary>
        </member>
        <member name="P:Euclid.Analytics.NeuralNetworks.ActivationFunctions.Algebraic.Min">
            <summary>The minimum value of the activation function</summary>
        </member>
        <member name="T:Euclid.Analytics.NeuralNetworks.ActivationFunctions.HyperbolicTan">
            <summary>
            The hyperbolic tangent sigmoïd
            </summary>
        </member>
        <member name="M:Euclid.Analytics.NeuralNetworks.ActivationFunctions.HyperbolicTan.Function(System.Double)">
            <summary>The hyperbolic tangent's function</summary>
            <param name="x">x</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Analytics.NeuralNetworks.ActivationFunctions.HyperbolicTan.Derivative(System.Double)">
            <summary>The hyperbolic tangent's derivative</summary>
            <param name="x">x</param>
            <returns>a double</returns>
        </member>
        <member name="P:Euclid.Analytics.NeuralNetworks.ActivationFunctions.HyperbolicTan.Max">
            <summary>The maximum value of the activation function</summary>
        </member>
        <member name="P:Euclid.Analytics.NeuralNetworks.ActivationFunctions.HyperbolicTan.Min">
            <summary>The minimum value of the activation function</summary>
        </member>
        <member name="T:Euclid.Analytics.NeuralNetworks.ActivationFunctions.LogisticCurve">
            <summary>
            The logistic activation function
            </summary>
        </member>
        <member name="M:Euclid.Analytics.NeuralNetworks.ActivationFunctions.LogisticCurve.Function(System.Double)">
            <summary>The logistic curve</summary>
            <param name="x">x</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Analytics.NeuralNetworks.ActivationFunctions.LogisticCurve.Derivative(System.Double)">
            <summary>The logistic curve's derivative</summary>
            <param name="x">x</param>
            <returns>a double</returns>
        </member>
        <member name="P:Euclid.Analytics.NeuralNetworks.ActivationFunctions.LogisticCurve.Max">
            <summary>The maximum value of the activation function</summary>
        </member>
        <member name="P:Euclid.Analytics.NeuralNetworks.ActivationFunctions.LogisticCurve.Min">
            <summary>The minimum value of the activation function</summary>
        </member>
        <member name="T:Euclid.Analytics.NeuralNetworks.ActivationFunctions.IActivationFunction">
            <summary>
            Activation function interface
            </summary>
        </member>
        <member name="M:Euclid.Analytics.NeuralNetworks.ActivationFunctions.IActivationFunction.Function(System.Double)">
            <summary>The activation function</summary>
            <param name="x">x</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Analytics.NeuralNetworks.ActivationFunctions.IActivationFunction.Derivative(System.Double)">
            <summary>The activation function's derivative</summary>
            <param name="x">x</param>
            <returns>a double</returns>
        </member>
        <member name="P:Euclid.Analytics.NeuralNetworks.ActivationFunctions.IActivationFunction.Max">
            <summary>The maximum value of the activation function</summary>
        </member>
        <member name="P:Euclid.Analytics.NeuralNetworks.ActivationFunctions.IActivationFunction.Min">
            <summary>The minimum value of the activation function</summary>
        </member>
        <member name="T:Euclid.Analytics.NeuralNetworks.FeedForward.Perceptron">
            <summary>Perceptron feed-forward neural network class</summary>
        </member>
        <member name="P:Euclid.Analytics.NeuralNetworks.FeedForward.Perceptron.Clone">
            <summary>Gets a deep copy of the perceptron network</summary>
        </member>
        <member name="P:Euclid.Analytics.NeuralNetworks.FeedForward.Perceptron.Item(System.Int32)">
            <summary>Gets a layer of the perceptron</summary>
            <param name="index">the layer's index</param>
            <returns>a Layer</returns>
        </member>
        <member name="P:Euclid.Analytics.NeuralNetworks.FeedForward.Perceptron.LayerCount">
            <summary>Gets the number of layers in the network</summary>
        </member>
        <member name="P:Euclid.Analytics.NeuralNetworks.FeedForward.Perceptron.Parameters">
            <summary>Gets the number of parameters (i.e. freedom degrees) of the network</summary>
        </member>
        <member name="P:Euclid.Analytics.NeuralNetworks.FeedForward.Perceptron.InputSize">
            <summary>Gets the size of the input data expected by the network</summary>
        </member>
        <member name="M:Euclid.Analytics.NeuralNetworks.FeedForward.Perceptron.ToXml(System.Xml.XmlWriter)">
            <summary>Writes the network's characteristics to an XML</summary>
            <param name="writer">the XML writer</param>
        </member>
        <member name="M:Euclid.Analytics.NeuralNetworks.FeedForward.Perceptron.Process(Euclid.Vector)">
            <summary>Calculates the network's response to an input</summary>
            <param name="input">the input data</param>
            <returns>a Vector</returns>
        </member>
        <member name="M:Euclid.Analytics.NeuralNetworks.FeedForward.Perceptron.Process(System.Collections.Generic.List{Euclid.Vector})">
            <summary>Calculates the network's responses to a set of inputs</summary>
            <param name="inputs">the set of input data</param>
            <returns>a List of Vectors</returns>
        </member>
        <member name="M:Euclid.Analytics.NeuralNetworks.FeedForward.Perceptron.Create(Euclid.Analytics.NeuralNetworks.ActivationFunctions.IActivationFunction,System.Int32,System.Int32[])">
            <summary>Creates an empty network</summary>
            <param name="function">the activation function</param>
            <param name="inputSize">the input size</param>
            <param name="layerSizes">the layers' sizes</param>
            <returns>a Perceptron network</returns>
        </member>
        <member name="M:Euclid.Analytics.NeuralNetworks.FeedForward.Perceptron.Create(System.Xml.XmlNode)">
            <summary>Builds ans fills a Perceptron network from its XML representation</summary>
            <param name="node">the XML node</param>
            <returns>a Perceptron network</returns>
        </member>
        <member name="T:Euclid.Analytics.NeuralNetworks.FeedForward.Trainer">
            <summary>Class used to train a Perceptron network</summary>
        </member>
        <member name="M:Euclid.Analytics.NeuralNetworks.FeedForward.Trainer.#ctor(Euclid.Analytics.NeuralNetworks.FeedForward.Perceptron,Euclid.Analytics.ErrorFunctions.IErrorFunction)">
            <summary>Builds a trainer class</summary>
            <param name="network">the initial state of the network to train</param>
            <param name="errorFunction">the error function</param>
        </member>
        <member name="M:Euclid.Analytics.NeuralNetworks.FeedForward.Trainer.TrainBackPropagation(System.Collections.Generic.List{Euclid.Vector},System.Collections.Generic.List{Euclid.Vector},System.Collections.Generic.List{Euclid.Vector},System.Collections.Generic.List{Euclid.Vector},System.Double,System.Int32)">
            <summary>Trains the underlyng network using standard back propagation</summary>
            <param name="learningX">the learning phase's inputs</param>
            <param name="learningY">the learning phase's expected responses</param>
            <param name="validationX">the validation phase's inputs</param>
            <param name="validationY">the validation phase's expected responses</param>
            <param name="learningRate">the learning rate</param>
            <param name="epochs">the number of epochs</param>
        </member>
        <member name="M:Euclid.Analytics.NeuralNetworks.FeedForward.Trainer.TrainBackPropagationMomentum(System.Collections.Generic.List{Euclid.Vector},System.Collections.Generic.List{Euclid.Vector},System.Collections.Generic.List{Euclid.Vector},System.Collections.Generic.List{Euclid.Vector},System.Double,System.Double,System.Int32)">
            <summary>Trains the underlyng network using standard back propagation with a momentum</summary>
            <param name="learningX">the learning phase's inputs</param>
            <param name="learningY">the learning phase's expected responses</param>
            <param name="validationX">the validation phase's inputs</param>
            <param name="validationY">the validation phase's expected responses</param>
            <param name="learningRate">the learning rate</param>
            <param name="momentum">the momentum applied to the descent direction</param>
            <param name="epochs">the number of epochs</param>
        </member>
        <member name="M:Euclid.Analytics.NeuralNetworks.FeedForward.Trainer.TrainResilientPropagation(System.Collections.Generic.List{Euclid.Vector},System.Collections.Generic.List{Euclid.Vector},System.Collections.Generic.List{Euclid.Vector},System.Collections.Generic.List{Euclid.Vector},System.Double,System.Double,System.Int32)">
            <summary>Trains the underlying network using the resilient propagation</summary>
            <param name="learningX">the learning phase's inputs</param>
            <param name="learningY">the learning phase's expected responses</param>
            <param name="validationX">the validation phase's inputs</param>
            <param name="validationY">the validation phase's expected responses</param>
            <param name="etaPlus">the speeding factor</param>
            <param name="etaMinus">the slowing factor</param>
            <param name="epochs">the number of epochs</param>
        </member>
        <member name="P:Euclid.Analytics.NeuralNetworks.FeedForward.Trainer.Convergence">
            <summary>The history of training and validation errors, epoch by epoch</summary>
        </member>
        <member name="T:Euclid.Analytics.NeuralNetworks.FeedForward.Layer">
            <summary>A Layer class for feed-forward perceptron</summary>
        </member>
        <member name="M:Euclid.Analytics.NeuralNetworks.FeedForward.Layer.Process(Euclid.Vector)">
            <summary>Returns the output of a layer for a given input set</summary>
            <param name="input">the input vector</param>
            <returns>a <c>Vector</c></returns>
        </member>
        <member name="M:Euclid.Analytics.NeuralNetworks.FeedForward.Layer.Process(System.Collections.Generic.List{Euclid.Vector})">
            <summary>Returns the list of the outputs of a layer for a given list of input sets</summary>
            <param name="inputs">the list of input vectors</param>
            <returns>a list of <c>Vector</c></returns>
        </member>
        <member name="P:Euclid.Analytics.NeuralNetworks.FeedForward.Layer.Biases">
            <summary>Gets and sets the biases of the layer</summary>
        </member>
        <member name="P:Euclid.Analytics.NeuralNetworks.FeedForward.Layer.Weights">
            <summary>Gets and sets the weights of the layer</summary>
        </member>
        <member name="M:Euclid.Analytics.NeuralNetworks.FeedForward.Layer.Weight(System.Int32,System.Int32)">
            <summary>Gets the weight of a given neuron for a given input</summary>
            <param name="neuronIndex">the index of the neuron</param>
            <param name="inputIndex">the index of the input</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Analytics.NeuralNetworks.FeedForward.Layer.Bias(System.Int32)">
            <summary>Gets the bias of a given neuron</summary>
            <param name="neuronIndex">the index of the neuron</param>
            <returns>a double</returns>
        </member>
        <member name="P:Euclid.Analytics.NeuralNetworks.FeedForward.Layer.Clone">
            <summary>Gets a deep copy of the Layer</summary>
        </member>
        <member name="P:Euclid.Analytics.NeuralNetworks.FeedForward.Layer.Parameters">
            <summary>Gets the number of parameters of the Layer</summary>
        </member>
        <member name="P:Euclid.Analytics.NeuralNetworks.FeedForward.Layer.LayerSize">
            <summary>Gets the number of neurons in the Layer</summary>
        </member>
        <member name="P:Euclid.Analytics.NeuralNetworks.FeedForward.Layer.InputSize">
            <summary>Gets the input size of the Layer</summary>
        </member>
        <member name="P:Euclid.Analytics.NeuralNetworks.FeedForward.Layer.Function">
            <summary>Gets the activation function of the Layer</summary>
        </member>
        <member name="P:Euclid.Analytics.NeuralNetworks.FeedForward.Layer.A">
            <summary>Gets the linear output of the layer before activation</summary>
        </member>
        <member name="P:Euclid.Analytics.NeuralNetworks.FeedForward.Layer.Z">
            <summary>Gets the outputs of the layer's processing</summary>
        </member>
        <member name="M:Euclid.Analytics.NeuralNetworks.FeedForward.Layer.ToXml(System.Xml.XmlWriter)">
            <summary>Serializes the <c>Layer</c> to a XML </summary>
            <param name="writer">the XMlWriter</param>
        </member>
        <member name="M:Euclid.Analytics.NeuralNetworks.FeedForward.Layer.Create(Euclid.Matrix,Euclid.Vector,Euclid.Analytics.NeuralNetworks.ActivationFunctions.IActivationFunction)">
            <summary>Builds a <c>Layer</c></summary>
            <param name="weights">the weghts of the layer</param>
            <param name="biases">the biases of the layer</param>
            <param name="function">the activation function</param>
            <returns>a <c>Layer</c></returns>
        </member>
        <member name="M:Euclid.Analytics.NeuralNetworks.FeedForward.Layer.Create(System.Int32,System.Int32,Euclid.Analytics.NeuralNetworks.ActivationFunctions.IActivationFunction)">
            <summary>Builds an empty <c>Layer</c></summary>
            <param name="layerSize">the number of neurons in the layer</param>
            <param name="inputSize">the number of inputs of the layer</param>
            <param name="function">the activation function</param>
            <returns>a <c>Layer</c></returns>
        </member>
        <member name="M:Euclid.Analytics.NeuralNetworks.FeedForward.Layer.Create(System.Xml.XmlNode)">
            <summary>Builds a <c>Layer</c> from a XML node</summary>
            <param name="node">the node</param>
            <returns>a <c>Layer</c></returns>
        </member>
        <member name="T:Euclid.Analytics.Regressions.LazyPartialLeastSquaresLinearRegression`2">
            <summary>
            LazyPartialLeastSquaresLinearRegression class (performs all 2^n possible regressions)
            </summary>
            <typeparam name="T">the legends' type</typeparam>
            <typeparam name="TV">the labels' type</typeparam>
        </member>
        <member name="M:Euclid.Analytics.Regressions.LazyPartialLeastSquaresLinearRegression`2.#ctor(Euclid.DataStructures.IndexedSeries.DataFrame{`0,System.Double,`1},Euclid.DataStructures.IndexedSeries.Series{`0,System.Double,`1})">
            <summary>
            Builds a LazyPartialLeastSquaresLinearRegression to regress a <c>Series</c> on a <c>DataFrame</c>
            </summary>
            <param name="x">the <c>DataFrame</c></param>
            <param name="y">the <c>Series</c></param>
        </member>
        <member name="P:Euclid.Analytics.Regressions.LazyPartialLeastSquaresLinearRegression`2.ReturnAverageIfFailed">
            <summary>Gets and sets whether the Y's average should be return when the regression fails</summary>
        </member>
        <member name="P:Euclid.Analytics.Regressions.LazyPartialLeastSquaresLinearRegression`2.WithConstant">
            <summary>Gets and sets whether the regression should involve a constant term</summary>
        </member>
        <member name="P:Euclid.Analytics.Regressions.LazyPartialLeastSquaresLinearRegression`2.LinearModel">
            <summary>Gets the result <c>LinearModel</c></summary>
        </member>
        <member name="P:Euclid.Analytics.Regressions.LazyPartialLeastSquaresLinearRegression`2.Status">
            <summary>Gets the regression's final status</summary>
        </member>
        <member name="M:Euclid.Analytics.Regressions.LazyPartialLeastSquaresLinearRegression`2.Regress">
            <summary>
            Performs the regression
            </summary>
        </member>
        <member name="T:Euclid.Analytics.Regressions.LASSORegression`2">
            <summary>
            Performs a LASSO regression for a given regularization factor
            </summary>
            <typeparam name="T">the legends</typeparam>
            <typeparam name="TV">the labels</typeparam>
        </member>
        <member name="M:Euclid.Analytics.Regressions.LASSORegression`2.#ctor(Euclid.DataStructures.IndexedSeries.DataFrame{`0,System.Double,`1},Euclid.DataStructures.IndexedSeries.Series{`0,System.Double,`1},System.Double)">
            <summary>Buils a LASSO to regress a <c>Series</c> on a <c>DataFrame</c></summary>
            <param name="x">the <c>DataFrame</c></param>
            <param name="y">the <c>Series</c></param>
            <param name="regularization">the regularization factor</param>
        </member>
        <member name="P:Euclid.Analytics.Regressions.LASSORegression`2.ComputeError">
            <summary>Gets and sets whether the errors should be computed after the regression</summary>
        </member>
        <member name="P:Euclid.Analytics.Regressions.LASSORegression`2.Regularization">
            <summary>Gets and sets the regularization factor</summary>
        </member>
        <member name="P:Euclid.Analytics.Regressions.LASSORegression`2.LinearModel">
            <summary>Gets the result <c>LinearModel</c></summary>
        </member>
        <member name="P:Euclid.Analytics.Regressions.LASSORegression`2.Status">
            <summary>Gets the regression's final status</summary>
        </member>
        <member name="M:Euclid.Analytics.Regressions.LASSORegression`2.Regress">
            <summary>Performs the regression</summary>
        </member>
        <member name="T:Euclid.Analytics.Regressions.LogisticRegression`2">
            <summary>OrdinaryLeastSquaresLinearRegression class</summary>
            <typeparam name="T">the legends' type</typeparam>
            <typeparam name="TV">the labels' type</typeparam>
        </member>
        <member name="M:Euclid.Analytics.Regressions.LogisticRegression`2.#ctor(Euclid.DataStructures.IndexedSeries.DataFrame{`0,System.Double,`1},Euclid.DataStructures.IndexedSeries.Series{`0,System.Double,`1})">
            <summary>Builds a OLS to regress a <c>Series</c> on a <c>DataFrame</c></summary>
            <param name="x">the <c>DataFrame</c></param>
            <param name="y">the <c>Series</c></param>
        </member>
        <member name="P:Euclid.Analytics.Regressions.LogisticRegression`2.ReturnAverageIfFailed">
            <summary>Gets and sets whether the Y's average should be return when the regression fails</summary>
        </member>
        <member name="P:Euclid.Analytics.Regressions.LogisticRegression`2.WithConstant">
            <summary>Gets and sets whether the regression should involve a constant term</summary>
        </member>
        <member name="P:Euclid.Analytics.Regressions.LogisticRegression`2.LogisticModel">
            <summary>Returns the result <c>LinearModel</c></summary>
        </member>
        <member name="P:Euclid.Analytics.Regressions.LogisticRegression`2.Status">
            <summary>Gets the regression's final status</summary>
        </member>
        <member name="P:Euclid.Analytics.Regressions.LogisticRegression`2.LogLikelihood">
            <summary>Returns the final log-likelihood of the regression</summary>
        </member>
        <member name="M:Euclid.Analytics.Regressions.LogisticRegression`2.RegressUsingGradientDescent(System.Double)">
            <summary>Performs the regression using gradient descent</summary>
        </member>
        <member name="M:Euclid.Analytics.Regressions.LogisticRegression`2.RegressUsingConjugateGradientDescent">
            <summary>Performs the regression using conjugate gradient descent</summary>
        </member>
        <member name="T:Euclid.Analytics.Regressions.RIDGERegression`2">
            <summary>Performs a RIDGE regression for a given regularization factor</summary>
            <typeparam name="T">the legends</typeparam>
            <typeparam name="TV">the labels</typeparam>
        </member>
        <member name="M:Euclid.Analytics.Regressions.RIDGERegression`2.#ctor(Euclid.DataStructures.IndexedSeries.DataFrame{`0,System.Double,`1},Euclid.DataStructures.IndexedSeries.Series{`0,System.Double,`1},System.Double)">
            <summary>Builds a RIDGE to regress a <c>Series</c> on a <c>DataFrame</c></summary>
            <param name="x">the <c>DataFrame</c></param>
            <param name="y">the <c>Series</c></param>
            <param name="regularization">the regularization factor</param>
        </member>
        <member name="P:Euclid.Analytics.Regressions.RIDGERegression`2.ReturnAverageIfFailed">
            <summary>Gets and sets whether the Y's average should be return when the regression fails</summary>
        </member>
        <member name="P:Euclid.Analytics.Regressions.RIDGERegression`2.WithConstant">
            <summary>Gets and sets whether the regression should involve a constant term</summary>
        </member>
        <member name="P:Euclid.Analytics.Regressions.RIDGERegression`2.ComputeError">
            <summary>Gets and sets whether the errors should be computed after the regression</summary>
        </member>
        <member name="P:Euclid.Analytics.Regressions.RIDGERegression`2.Regularization">
            <summary>Gets and sets the regularization factor</summary>
        </member>
        <member name="P:Euclid.Analytics.Regressions.RIDGERegression`2.LinearModel">
            <summary>Gets the result <c>LinearModel</c></summary>
        </member>
        <member name="P:Euclid.Analytics.Regressions.RIDGERegression`2.Status">
            <summary>Gets the regression's final status </summary>
        </member>
        <member name="M:Euclid.Analytics.Regressions.RIDGERegression`2.Regress">
            <summary>Performs the regression</summary>
        </member>
        <member name="T:Euclid.Analytics.Regressions.OrdinaryLeastSquaresLinearRegression`2">
            <summary>OrdinaryLeastSquaresLinearRegression class</summary>
            <typeparam name="T">the legends' type</typeparam>
            <typeparam name="TV">the labels' type</typeparam>
        </member>
        <member name="M:Euclid.Analytics.Regressions.OrdinaryLeastSquaresLinearRegression`2.#ctor(System.Double[][],System.Double[])">
            <summary>Builds a OLS to regress a <c>Series</c> on a <c>DataFrame</c></summary>
            <param name="x">the <c>DataFrame</c></param>
            <param name="y">the <c>Series</c></param>
        </member>
        <member name="P:Euclid.Analytics.Regressions.OrdinaryLeastSquaresLinearRegression`2.ReturnAverageIfFailed">
            <summary>Gets and sets whether the Y's average should be return when the regression fails</summary>
        </member>
        <member name="P:Euclid.Analytics.Regressions.OrdinaryLeastSquaresLinearRegression`2.WithConstant">
            <summary>Gets and sets whether the regression should involve a constant term</summary>
        </member>
        <member name="P:Euclid.Analytics.Regressions.OrdinaryLeastSquaresLinearRegression`2.ComputeError">
            <summary>Gets and sets whether the errors should be computed after the regression</summary>
        </member>
        <member name="P:Euclid.Analytics.Regressions.OrdinaryLeastSquaresLinearRegression`2.LinearModel">
            <summary>Gets the result <c>LinearModel</c></summary>
        </member>
        <member name="P:Euclid.Analytics.Regressions.OrdinaryLeastSquaresLinearRegression`2.Status">
            <summary>Gets the regression's final status</summary>
        </member>
        <member name="M:Euclid.Analytics.Regressions.OrdinaryLeastSquaresLinearRegression`2.Regress">
            <summary>
            Performs the regression
            </summary>
        </member>
        <member name="T:Euclid.Analytics.Regressions.RegressionStatus">
            <summary>
            Returns the status of the regression
            </summary>
        </member>
        <member name="F:Euclid.Analytics.Regressions.RegressionStatus.NotRan">
            <summary> the regression did not run </summary>
        </member>
        <member name="F:Euclid.Analytics.Regressions.RegressionStatus.Normal">
            <summary> the regression ran as expected </summary>
        </member>
        <member name="F:Euclid.Analytics.Regressions.RegressionStatus.IterationExceeded">
            <summary> the regression exceeded its max iterations </summary>
        </member>
        <member name="F:Euclid.Analytics.Regressions.RegressionStatus.BadData">
            <summary> the regression failed </summary>
        </member>
        <member name="T:Euclid.Analytics.Regressions.RegressionHelper">
            <summary>A helper for the regression</summary>
        </member>
        <member name="M:Euclid.Analytics.Regressions.RegressionHelper.Text``2(Euclid.DataStructures.IndexedSeries.DataFrame{``0,System.Double,``1},Euclid.DataStructures.IndexedSeries.Series{``0,System.Double,``1},Euclid.Analytics.LinearModel,System.String)">
            <summary>Displays the regression result as a string</summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TV"></typeparam>
            <param name="dataFrame">the dataframe</param>
            <param name="series">the series</param>
            <param name="linearModel">the linear model</param>
            <param name="format">the format for the coefficients</param>
            <returns>a string</returns>
        </member>
        <member name="T:Euclid.Analytics.Regressions.Scaling">
            <summary>Scaling class</summary>
        </member>
        <member name="P:Euclid.Analytics.Regressions.Scaling.Intercept">
            <summary>Gets the intercept of the Scaling</summary>
        </member>
        <member name="P:Euclid.Analytics.Regressions.Scaling.ScalingCoefficient">
            <summary>Gets the scaling coefficient of the Scaling</summary>
        </member>
        <member name="M:Euclid.Analytics.Regressions.Scaling.Scale(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>Scales "up" a series of data</summary>
            <param name="data">the data to scale "up" : intercept + x * scalingCoefficient</param>
            <returns>an array of double</returns>
        </member>
        <member name="M:Euclid.Analytics.Regressions.Scaling.Reduce(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>Scales "down" a series of data</summary>
            <param name="data">the data to scale "down" (x-intercept)/scalingCoefficient</param>
            <returns>an array of double</returns>
        </member>
        <member name="M:Euclid.Analytics.Regressions.Scaling.CreateZScore(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>Creates a Scaling based on the average and the standard deviation</summary>
            <param name="data">the data to scale</param>
            <returns>a <c>Scaling</c> class</returns>
        </member>
        <member name="M:Euclid.Analytics.Regressions.Scaling.CreateMinMax(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>Creates a Scaling based on the minimum and maximum</summary>
            <param name="data">the data to scale</param>
            <returns>a <c>Scaling</c> class</returns>
        </member>
        <member name="T:Euclid.Analytics.Statistics.StatisticalFns">
            <summary>
            Collection of statistical functions
            </summary>
        </member>
        <member name="M:Euclid.Analytics.Statistics.StatisticalFns.Percentile(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IList{System.Double})">
            <summary>
            Compute percentile(s) over a collection of data
            </summary>
            <param name="values">Collection of data</param>
            <param name="percentiles">Percentiles</param>
            <returns>Percentiles values</returns>
        </member>
        <member name="M:Euclid.Analytics.Statistics.StatisticalFns.Describe(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Compute the descriptive statistics from the serie 
            </summary>
            <param name="values">Serie of data</param>
            <returns>A statistical summary of the numeric data</returns>
        </member>
        <member name="T:Euclid.Analytics.Statistics.SummaryStatistics">
            <summary>
            Class which encapsulate a glossary of statistics
            </summary>
        </member>
        <member name="P:Euclid.Analytics.Statistics.SummaryStatistics.Min">
            <summary>Returns the minimum</summary>
        </member>
        <member name="P:Euclid.Analytics.Statistics.SummaryStatistics.Average">
            <summary>Returns the average</summary>
        </member>
        <member name="P:Euclid.Analytics.Statistics.SummaryStatistics.Max">
            <summary>Returns the maximum</summary>
        </member>
        <member name="P:Euclid.Analytics.Statistics.SummaryStatistics.Stdev">
            <summary>Standard deviation (Pearson)</summary>
        </member>
        <member name="P:Euclid.Analytics.Statistics.SummaryStatistics.Range">
            <summary>Distance between Min and Max</summary>
        </member>
        <member name="P:Euclid.Analytics.Statistics.SummaryStatistics.Median">
            <summary>Median</summary>
        </member>
        <member name="P:Euclid.Analytics.Statistics.SummaryStatistics.Percentile10">
            <summary>Percentile 10%</summary>
        </member>
        <member name="P:Euclid.Analytics.Statistics.SummaryStatistics.Percentile90">
            <summary>Percentile 90%</summary>
        </member>
        <member name="P:Euclid.Analytics.Statistics.SummaryStatistics.Skewness">
            <summary>Measure of asymmetry</summary>
        </member>
        <member name="P:Euclid.Analytics.Statistics.SummaryStatistics.Kurtosis">
            <summary>Measure of the tailedness</summary>
        </member>
        <member name="P:Euclid.Analytics.Statistics.SummaryStatistics.Sum">
            <summary>Sum of element(s)</summary>
        </member>
        <member name="P:Euclid.Analytics.Statistics.SummaryStatistics.Count">
            <summary>Number of element(s)</summary>
        </member>
        <member name="M:Euclid.Analytics.Statistics.SummaryStatistics.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Euclid.Analytics.Statistics.SummaryStatistics.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Double,System.Double,System.Double)">
            <summary>Builds a <c>SummaryStatistics</c></summary>
            <param name="min">Minimum</param>
            <param name="average">Average</param>
            <param name="max">Maximum</param>
            <param name="stdev">Standard deviation</param>
            <param name="range">Range</param>
            <param name="percentile10">Percentile 10%</param>
            <param name="median">Median</param>
            <param name="percentile90">Percentile 90%</param>
            <param name="count">Nb of elements</param>
            <param name="skewness">Skewness</param>
            <param name="kurtosis">Kurtosis</param>
            <param name="sum">Sum of elements</param>
        </member>
        <member name="M:Euclid.Analytics.Statistics.SummaryStatistics.ToString">
            <summary>
            Print main statistics from the summary
            </summary>
            <returns></returns>
        </member>
        <member name="T:Euclid.Analytics.Statistics.Tests.ANOVA">
            <summary>
            Class which descibes Analysis of variance: ANOVA
            </summary>
        </member>
        <member name="P:Euclid.Analytics.Statistics.Tests.ANOVA.Data">
            <summary>
            Two-dimensional arrays of double
            </summary>
        </member>
        <member name="P:Euclid.Analytics.Statistics.Tests.ANOVA.F">
            <summary>
            F-Statistics
            </summary>
        </member>
        <member name="P:Euclid.Analytics.Statistics.Tests.ANOVA.Ssb">
            <summary>
            Sum of squares between groups
            </summary>
        </member>
        <member name="P:Euclid.Analytics.Statistics.Tests.ANOVA.Msb">
            <summary>
            Mean square between groups
            </summary>
        </member>
        <member name="P:Euclid.Analytics.Statistics.Tests.ANOVA.Ssw">
            <summary>
            Sum of squares within groups
            </summary>
        </member>
        <member name="P:Euclid.Analytics.Statistics.Tests.ANOVA.Msw">
            <summary>
            Mean square within groups
            </summary>
        </member>
        <member name="P:Euclid.Analytics.Statistics.Tests.ANOVA.DF">
            <summary>
            Degree of fredom
            </summary>
        </member>
        <member name="P:Euclid.Analytics.Statistics.Tests.ANOVA.Pvalue">
            <summary>
            Probability that all population means are equal 
            </summary>
        </member>
        <member name="M:Euclid.Analytics.Statistics.Tests.ANOVA.#ctor(System.Double[][])">
            <summary>
            Constructor for ANOVA's object
            </summary>
            <param name="data">Sample</param>
        </member>
        <member name="M:Euclid.Analytics.Statistics.Tests.ANOVA.RunOneWay">
            <summary>
            Run ANOVA computation for one factor
            </summary>
            <returns>True computation done with sucess else an error has been raised</returns>
        </member>
        <member name="M:Euclid.Analytics.Statistics.Tests.ANOVA.FstatOneWay">
            <summary>
            Compute the F-statisics for One way ANONVA method
            </summary>
            <returns>F-Statistics</returns>
        </member>
        <member name="M:Euclid.Analytics.Statistics.Tests.ANOVA.LogGammaByLanczosAlgorithm(System.Double)">
            <summary>
            Log gamma approximation by using Lanczos algorithm
            </summary>
            <param name="x">value</param>
            <returns>approximation</returns>
        </member>
        <member name="M:Euclid.Analytics.Statistics.Tests.ANOVA.BetaInc(System.Double,System.Double,System.Double)">
            <summary>
            Imcomplete beta approximation by using Lanczos algorithm
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="x"></param>
            <returns>Imcomplete beta approximation</returns>
        </member>
        <member name="M:Euclid.Analytics.Statistics.Tests.ANOVA.BetaIncCf(System.Double,System.Double,System.Double)">
            <summary> Approximate Incomplete Beta computed by continued fraction (Handbook of Mathematical Functions: with Formulas, Graphs, and Mathematical Tables, A &amp; S 26.5.8)</summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="x"></param>
            <returns>Approximate Incomplete Beta</returns>
        </member>
        <member name="M:Euclid.Analytics.Statistics.Tests.ANOVA.PF(System.Double,System.Double,System.Double)">
            <summary>
            Approximate lower tail of F-dist (area from 0.0 to x) equivalent to the R pf() function only accurate to about 3 decimals
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="x"></param>
            <returns>Probability</returns>
        </member>
        <member name="T:Euclid.Analytics.Tests.KolmogorovSmirnovTest">
            <summary> Helps testing empiric distribution adequacy using Kolmogorov-Smirnov</summary>
        </member>
        <member name="M:Euclid.Analytics.Tests.KolmogorovSmirnovTest.IsSameDistribution(System.Double[],System.Double[],System.Double)">
            <summary>
            Performs the Kolmogorov Smirnov test.
            </summary>
            <param name="series1">The first sample.</param>
            <param name="series2">The second sample.</param>
            <param name="alpha">The confidence level of the test</param>
            <returns>True if the series appear to be drawn from the same distribution, false otherwise.</returns>
        </member>
        <member name="T:Euclid.Arithmetics.BinomialCoefficients">
            <summary>Binomial coefficients class</summary>
        </member>
        <member name="M:Euclid.Arithmetics.BinomialCoefficients.#ctor(System.Int32)">
            <summary>Calculates all the binomial coefficients for a given degree</summary>
            <param name="n">the degree</param>
        </member>
        <member name="P:Euclid.Arithmetics.BinomialCoefficients.Item(System.Int32)">
            <summary>Returns the binomial coefficient for a given index</summary>
            <param name="index">the index</param>
            <returns>an <c>int</c></returns>
        </member>
        <member name="P:Euclid.Arithmetics.BinomialCoefficients.Coefficients">
            <summary>Gets all the binomial coefficients</summary>
        </member>
        <member name="T:Euclid.Arithmetics.Subsets">
            <summary>Subsets class</summary>
        </member>
        <member name="M:Euclid.Arithmetics.Subsets.AllSubsets``1(System.Collections.Generic.List{``0})">
            <summary>Returns all possible subsets from a List</summary>
            <typeparam name="T">the template type</typeparam>
            <param name="data">the original data</param>
            <returns>the List of subsets</returns>
        </member>
        <member name="M:Euclid.Arithmetics.Subsets.SubsetsOfSize``1(System.Collections.Generic.List{``0},System.Int32,System.Int32)">
            <summary>Returns all possible subsets of a given size from a list</summary>
            <typeparam name="T">the template type</typeparam>
            <param name="data">the original data</param>
            <param name="subsetSize">the subset size</param>
            <param name="startingIndex">the starting index</param>
            <returns>the list of subsets</returns>
        </member>
        <member name="T:Euclid.DataStructures.CachedFunction`2">
            <summary>Class allowing to cache calculation results</summary>
            <typeparam name="T">the key type</typeparam>
            <typeparam name="U">the value type</typeparam>
        </member>
        <member name="M:Euclid.DataStructures.CachedFunction`2.#ctor(System.Func{`0,`1})">
            <summary>Builds a cached function class</summary>
            <param name="function">the function</param>
        </member>
        <member name="P:Euclid.DataStructures.CachedFunction`2.Item(`0)">
            <summary>Returns the value for a given key (if not stored, calculates it and stores it)</summary>
            <param name="t">the target key</param>
            <returns>the sought value</returns>
        </member>
        <member name="T:Euclid.DataStructures.EndlessStack`1">
            <summary>Represents an endless stack (i.e a stack that refills whenever it is empty)</summary>
            <typeparam name="T">the item type</typeparam>
        </member>
        <member name="M:Euclid.DataStructures.EndlessStack`1.#ctor(System.Func{System.Int32,System.Collections.Generic.IEnumerable{`0}},System.Int32,System.Int32)">
            <summary>Builds an endless stack</summary>
            <param name="refiller">the function to provide the refills</param>
            <param name="initialSize">the initial size of the stack</param>
            <param name="refillSize">the number of items to load when the stack is empty </param>
        </member>
        <member name="M:Euclid.DataStructures.EndlessStack`1.Pop">
            <summary>Reads and delete an item from the top of the stack (refills if needed)</summary>
            <returns>the top element</returns>
        </member>
        <member name="T:Euclid.DataStructures.IndexedSeries.IDataFrame`3">
            <summary>Class representing a template of DataFrame of synchronized data</summary>
            <typeparam name="T">the legend type</typeparam>
            <typeparam name="TU">the data type</typeparam>
            <typeparam name="TV">the label type</typeparam>
        </member>
        <member name="F:Euclid.DataStructures.IndexedSeries.IDataFrame`3._labels">
            <summary>
            Columns variable
            </summary>
        </member>
        <member name="F:Euclid.DataStructures.IndexedSeries.IDataFrame`3._legends">
            <summary>
            Row variable
            </summary>
        </member>
        <member name="F:Euclid.DataStructures.IndexedSeries.IDataFrame`3._data">
            <summary>
            Matrix of data
            </summary>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.#ctor(Euclid.DataStructures.IndexedSeries.IHeader{`2},Euclid.DataStructures.IndexedSeries.IHeader{`0},`1[][])">
            <summary>
            Hidden constructor
            </summary>
            <param name="labels">header of labels</param>
            <param name="legends">header of legends</param>
            <param name="data">data</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.#ctor">
            <summary>
            public constructor
            </summary>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.Initialize(System.Collections.Generic.IList{`2},System.Collections.Generic.IList{`0},`1[][])">
            <summary>
            Initialize an instance of IDataFrame
            </summary>
            <param name="labels"></param>
            <param name="legends"></param>
            <param name="data"></param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.Initialize(`1)">
            <summary>
            Initialize the data matrix with the specified value.
            </summary>
            <param name="value">Value used for initialization</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.Create``1(System.Xml.XmlNode)">
            <summary>
            Builds a <c>DataFrame</c> from its serialized form
            </summary>
            <typeparam name="TY">IDataFrame implementation</typeparam>
            <param name="node">the <c>XmlNode</c></param>
            <returns>Instance</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.Create``1(System.Collections.Generic.IList{`2},System.Collections.Generic.IList{`0},`1[][])">
            <summary>
            Create an instance of IDataFrame
            </summary>
            <typeparam name="TY">Generic type</typeparam>
            <param name="labels">labels</param>
            <param name="legends">legends</param>
            <param name="data">data</param>
            <returns>Instance</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.Create``1(System.Collections.Generic.IList{`2},System.Collections.Generic.IList{`0})">
            <summary>Builds a <c>DataFrame</c></summary>
            <typeparam name="TY">IDataFrame implementation</typeparam>
            <param name="labels">the labels</param>
            <param name="legends">the legends</param>
            <returns>a <c>DataFrame</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.Create``1(System.Collections.Generic.IEnumerable{Euclid.DataStructures.IndexedSeries.Slice{`0,`1,`2}})">
            <summary>
            Builds a <c>DataFrame</c>
            </summary>
            <typeparam name="TY">IDataFrame implementation</typeparam>
            <param name="slices">Slices</param>
            <returns>Instance</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.Create``1(System.Collections.Generic.IEnumerable{Euclid.DataStructures.IndexedSeries.Series{`0,`1,`2}})">
            <summary>
            Builds a <c>DataFrame</c>
            </summary>
            <typeparam name="TY">IDataFrame implementation</typeparam>
            <param name="series">Series</param>
            <returns>Instance</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.Create``1(System.String)">
            <summary>Builds a <c>DataFrame</c> from a CSV string</summary>
            <typeparam name="TY">IDataFrame implementation</typeparam>
            <param name="text">the serialized version of the data</param>
            <returns>Instance</returns>
            <exception cref="T:System.ArgumentNullException">Text empty</exception>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.IDataFrame`3.Legends">
            <summary>Returns the legends </summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.IDataFrame`3.Labels">
            <summary>Returns the labels </summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.IDataFrame`3.Columns">
            <summary>Returns the number of columns</summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.IDataFrame`3.Rows">
            <summary>Returns the number of rows</summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.IDataFrame`3.Data">
            <summary>Gets the data</summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.IDataFrame`3.Item(System.Int32,System.Int32)">
            <summary>Gets and sets the data for the i-th row and j-th column of the <c>DataFrame</c></summary>
            <param name="i">the row index</param>
            <param name="j">the column index</param>
            <returns>a data point</returns>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.IDataFrame`3.Item(`0,`2)">
            <summary>Gets and sets the data for a given legend and a given label</summary>
            <param name="t">the legend</param>
            <param name="v">the label</param>
            <returns>a data point</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.GetLabelRank(`2)">
            <summary>Returns the label rank</summary>
            <param name="label">the target label</param>
            <returns>an <c>Integer</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.GetLegendRank(`0)">
            <summary>Returns the legend rank</summary>
            <param name="legend">the target legend</param>
            <returns>an <c>Integer</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.GetSeriesAt(`2)">
            <summary> Gets the data-point column of the given label</summary>
            <param name="label">the label</param>
            <returns> a <c>Series</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.GetValuesAt(`2)">
            <summary> Gets the data-point collection of the given label</summary>
            <param name="label">the label</param>
            <returns> a <c>data</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.GetSeriesAt(`2,System.Func{`0,System.Boolean})">
            <summary> Gets the data-point column of the given label</summary>
            <param name="label">the label</param>
            <param name="predicate">legend predicate</param>
            <returns> a <c>Series</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.GetSeries">
            <summary> Gets all the data as an array of <c>Series</c></summary>
            <returns>an array of <c>Series</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.AddSeries(`2,`1[])">
            <summary> Adds a column to the <c>DataFrame</c></summary>
            <param name="label">the new column's label</param>
            <param name="column">the new column's data</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.AddSeries(`2)">
            <summary>Adds an empty column to the <c>DataFrame</c></summary>
            <param name="label">the new column's label</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.TakeSeries(`2)">
            <summary>Takes a <c>Series</c> from the DataFrame thereby removing it from the DataFrame</summary>
            <param name="label">the label of the <c>Series</c> to take</param>
            <returns> a <c>Series</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.RemoveSeriesAt(`2)">
            <summary>Remove the data for a given label</summary>
            <param name="label">the label</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.ExtractByLabels``1(System.Func{`2,System.Boolean})">
            <summary>Extracts the part of the DataFrame whose labels obeys the predicate</summary>
            <param name="predicate">the predicate on the labels</param>
            <returns>a DataFrame</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.FastExtractByLabels``1(System.Func{`2,System.Boolean})">
            <summary>
            Fast extracts the part of the DataFrame whose labels obeys the predicate
            </summary>
            <typeparam name="TY">dataframe type</typeparam>
            <param name="predicate">the predicate on the labels</param>
            <returns>Matching dataframe</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.FastExtractValuesByLabels(System.Func{`2,System.Boolean})">
            <summary>
            Fast extracts the part of the DataFrame whose labels obeys the predicate
            </summary>
            <typeparam name="TY">dataframe type</typeparam>
            <param name="predicate">the predicate on the labels</param>
            <returns>Matching dataframe</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.GetSliceAt(`0)">
            <summary>Gets the data-point row of the given legend</summary>
            <param name="legend">the legend</param>
            <returns>a <c>Slice</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.GetSlices">
            <summary>Gets all the data as an array of <c>Slice</c></summary>
            <returns>an array of <c>Slice</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.AddSlice(`0,`1[])">
            <summary> Adds a slice to the <c>DataFrame</c></summary>
            <param name="legend">the new slice's legend</param>
            <param name="slice">the new slice's data</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.AddSlice(`0)">
            <summary>Adds an empty slice to the <c>DataFrame</c></summary>
            <param name="legend">the new slice's legend</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.TakeSlice(`0)">
            <summary>Takes a <c>Slice</c> from the DataFrame thereby removing it from the DataFrame</summary>
            <param name="legend">the legend of the <c>Slice</c> to take</param>
            <returns> a <c>Slice</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.RemoveSliceAt(`0)">
            <summary>Removes the row for a given legend</summary>
            <param name="legend">the legend</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.ExtractByLegend``1(System.Func{`0,System.Boolean})">
            <summary>Extracts the part of the DataFrame whose legends obeys the predicate</summary>
            <param name="predicate">the predicate on the legends</param>
            <returns>a DataFrame</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.Clone``1">
            <summary>Clones the <c>DataFrame</c></summary>
            <returns>a <c>DataFrame</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.ApplyOnData(System.Func{`1,`1})">
            <summary>Applies a function to all the data</summary>
            <param name="function">the function</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.ApplyOnLegends(System.Func{`0,`0})">
            <summary>Applies a function to all the legends</summary>
            <param name="function">the function</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.ApplyOnLabels(System.Func{`2,`2})">
            <summary>Applies a function to all the labels</summary>
            <param name="function">the function</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.GetLegend(System.Int32)">
            <summary>Gets the i-th legend value</summary>
            <param name="index">the index</param>
            <returns>a legend value</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.RenameLegend(`0,`0)">
            <summary>Renames a legend</summary>
            <param name="oldValue">the old legend value</param>
            <param name="newValue">the new legend value</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.GetLabel(System.Int32)">
            <summary>Gets the i-th label's value</summary>
            <param name="index">the index</param>
            <returns>a label</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.RenameLabel(`2,`2)">
            <summary>Renames a label</summary>
            <param name="oldValue">the old value</param>
            <param name="newValue">the new value</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.ToXml(System.Xml.XmlWriter)">
            <summary>Serializes the <c>DataFrame</c> to Xml </summary>
            <param name="writer">the <c>XmlWriter</c></param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.FromXml``1(System.Xml.XmlNode)">
            <summary>Buils a <c>DataFrame</c></summary>
            <param name="node">the Xml node</param>
            <returns>a DataFrame</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.ToCSV">
            <summary>Builds a string representation of the content of the <c>DataFrame</c> (default use ',' as separator) </summary>
            <returns>a <c>String</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.ToCSV(System.String)">
            <summary>Builds a string representation of the content of the <c>DataFrame</c> </summary>
            <param name="separator">CSV separator</param>
            <returns>a <c>String</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IDataFrame`3.Equals(Euclid.DataStructures.IndexedSeries.IDataFrame{`0,`1,`2})">
            <summary>Equality comparer</summary>
            <param name="other">the other DataFrame</param>
            <returns>true if the data, legends and labels match, false otherwise</returns>
        </member>
        <member name="T:Euclid.DataStructures.IndexedSeries.IHeader`1">
            <summary>
            Abstract Header class for the IIndexe
            </summary>
            <typeparam name="T">the type of label</typeparam>
        </member>
        <member name="F:Euclid.DataStructures.IndexedSeries.IHeader`1._map">
            <summary>
            map field
            </summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.IHeader`1.Item(`0)">
            <summary>Gets the index associated with a label</summary>
            <param name="t">the label</param>
            <returns>an integer</returns>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.IHeader`1.Count">
            <summary>Gets the number of labels in the header</summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.IHeader`1.Values">
            <summary>Gets the labels</summary>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IHeader`1.GetEnumerator">
            <summary>Gets an enumerator of the labels</summary>
            <returns>a IEnumerator</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IHeader`1.Clone">
            <summary>Clones the header</summary>
            <returns>a Header</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IHeader`1.Remove(`0)">
            <summary>Removes a label from the header</summary>
            <param name="t">the label</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IHeader`1.Add(`0)">
            <summary>Adds a label to the header</summary>
            <param name="t">the label</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IHeader`1.AddRange(`0[])">
            <summary>Adds a range of values to the header</summary>
            <param name="ts">the values</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IHeader`1.Rename(`0,`0)">
            <summary>Renames a label</summary>
            <param name="oldValue">the old value of the label</param>
            <param name="newValue">the new value of the label</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IHeader`1.ElementAt(System.Int32)">
            <summary>Returns the label at a given index</summary>
            <param name="index">the index</param>
            <returns>a label</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IHeader`1.Contains(`0)">
            <summary>Checks if the header contains a given label</summary>
            <param name="t">the target label</param>
            <returns>true if the label is in the header, false otherwise</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IHeader`1.Equals(System.Object)">
            <summary>Overriden generic Equals</summary>
            <param name="obj">the compared object</param>
            <returns>true if obj matches this object, false otherwise</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IHeader`1.GetHashCode">
            <summary>Returns a hash code</summary>
            <returns>an <c>Integer</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IHeader`1.Equals(Euclid.DataStructures.IndexedSeries.IHeader{`0})">
            <summary>Equality comparer</summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IHeader`1.op_Equality(Euclid.DataStructures.IndexedSeries.IHeader{`0},Euclid.DataStructures.IndexedSeries.IHeader{`0})">
            <summary>Equality operator</summary>
            <param name="h1">the left-hand-side header</param>
            <param name="h2">the right-hand-side header</param>
            <returns>true if the headers have the same content, false otherwise</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IHeader`1.op_Inequality(Euclid.DataStructures.IndexedSeries.IHeader{`0},Euclid.DataStructures.IndexedSeries.IHeader{`0})">
            <summary>Inequality operator</summary>
            <param name="h1">the left-hand-side header</param>
            <param name="h2">the right-hand-side header</param>
            <returns>true if the headers do not have the same content, false otherwise</returns>
        </member>
        <member name="T:Euclid.DataStructures.IndexedSeries.SortedHeader`1">
            <summary>
            Sorted Header class for the IIndexe
            </summary>
            <typeparam name="T">the type of label</typeparam>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.SortedHeader`1.#ctor">
            <summary>Standard builder</summary>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.SortedHeader`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>Builds a zero-indexed header</summary>
            <param name="content">the values of the labels</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.SortedHeader`1.#ctor(Euclid.DataStructures.IMap{`0,System.Int32})">
            <summary> Builds a header from a two-way dictionary</summary>
            <param name="map">the map</param>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.SortedHeader`1.Values">
            <summary>Gets the labels</summary>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.SortedHeader`1.Clone">
            <summary>Clones the header</summary>
            <returns>a Header</returns>
        </member>
        <member name="T:Euclid.DataStructures.IndexedSeries.TimeDataFrame`2">
            <summary>Class representing a DataFrame of synchronized data ordered by time </summary>
            <typeparam name="TU">The data type</typeparam>
            <typeparam name="TV">The lable type</typeparam>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.TimeDataFrame`2.#ctor(Euclid.DataStructures.IndexedSeries.IHeader{`1},Euclid.DataStructures.IndexedSeries.IHeader{System.DateTime},`0[][])">
            <summary>
            Protected constructor
            </summary>
            <param name="labels">Labels, serie of generic type</param>
            <param name="legends">Legends, serie of datetime type</param>
            <param name="data">Matric of generic type</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.TimeDataFrame`2.#ctor">
            <summary>
            public constructor
            </summary>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.TimeDataFrame`2.Initialize(System.Collections.Generic.IList{`1},System.Collections.Generic.IList{System.DateTime},`0[][])">
            <summary>
            Initialize TimeDataFrame instance
            </summary>
            <param name="labels">labels</param>
            <param name="legends">legends</param>
            <param name="data">data</param>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.TimeDataFrame`2.Chunks">
            <summary>
            returns the chunk used for building index
            </summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.TimeDataFrame`2.Legends">
            <summary>
            returns the values of legend
            </summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.TimeDataFrame`2.IntradayChunk">
            <summary>
            Precise if the chunk has intraday granularity
            </summary>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.TimeDataFrame`2.BuildIndex(System.Collections.Generic.IEnumerable{System.DateTime},System.Boolean)">
            <summary>
            Build index for searching into the time series
            </summary>
            <param name="chunks">Chunk of time</param>
            <param name="intraday">Precise if index is intraday or extraday</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.TimeDataFrame`2.FindFirstIndexOf(System.Func{System.DateTime,System.Boolean},System.Nullable{System.DateTime})">
            <summary>
            Find first index of a predicate by using binary search + indexes
            </summary>
            <param name="predicate">Predicate</param>
            <param name="chunk">Chunk value</param>
            <returns>index of the target else -1</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.TimeDataFrame`2.FindLastIndexOf(System.Func{System.DateTime,System.Boolean},System.Nullable{System.DateTime})">
            <summary>
            Find last index of a predicate by using binary search + indexes
            </summary>
            <param name="predicate">Predicate</param>
            <param name="chunk">Chunk value</param>
            <returns>index of the target else -1</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Euclid.DataStructures.IndexedSeries.TimeDataFrame`2.FastExtractByLegend(System.DateTime,System.DateTime)" -->
        <!-- Badly formed XML comment ignored for member "M:Euclid.DataStructures.IndexedSeries.TimeDataFrame`2.FastExtractValuesByLegend(System.DateTime,System.DateTime)" -->
        <!-- Badly formed XML comment ignored for member "M:Euclid.DataStructures.IndexedSeries.TimeDataFrame`2.FastExtractValuesByLegendAndLabels(System.DateTime,System.DateTime,System.Func{`1,System.Boolean})" -->
        <member name="M:Euclid.DataStructures.IndexedSeries.TimeDataFrame`2.GetSeriesAt(`1)">
            <summary> Gets the data-point column of the given label</summary>
            <param name="label">the label</param>
            <returns> a <c>Time series</c></returns>
        </member>
        <member name="T:Euclid.DataStructures.IndexedSeries.TimeSeries`2">
            <summary>
            Class representing a serie ordered by time
            </summary>
            <typeparam name="TU">Data type</typeparam>
            <typeparam name="TV">Label type</typeparam>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.TimeSeries`2.#ctor">
            <summary>
            Parameterless constructor
            </summary>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.TimeSeries`2.Initialize(`1,System.Collections.Generic.IList{System.DateTime},`0[])">
            <summary>
            Initialize serie instance
            </summary>
            <param name="label">Label</param>
            <param name="legends">Legends</param>
            <param name="data">Data</param>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.TimeSeries`2.Legends">
            <summary>
            returns the values of legend
            </summary>
        </member>
        <member name="T:Euclid.DataStructures.IndexedSeries.DataCube`4">
            <summary>Class representing a cube of synchronized data</summary>
            <typeparam name="T">the legend type</typeparam>
            <typeparam name="TU">the label type</typeparam>
            <typeparam name="TV">the layer type</typeparam>
            <typeparam name="TW">the data type</typeparam>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataCube`4.Create(System.Xml.XmlNode)">
            <summary>Builds a <c>DataCube</c> from its serialized form</summary>
            <param name="node">the <c>XmlNode</c></param>
            <returns>a <c>DataCube</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataCube`4.Create(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1},System.Collections.Generic.IList{`2},`3[0:,0:,0:])">
            <summary>Builds a <c>DataCube</c> </summary>
            <param name="labels">the labels</param>
            <param name="layers">the layers</param>
            <param name="legends">the legends</param>
            <param name="data">the data</param>
            <returns>a <c>DataCube</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataCube`4.Create(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1},System.Collections.Generic.IList{`2})">
            <summary>Builds a <c>DataCube</c></summary>
            <param name="labels">the labels</param>
            <param name="layers">the layers</param>
            <param name="legends">the legends</param>
            <returns>a <c>DataCube</c></returns>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.DataCube`4.Legends">
            <summary>Returns the legends</summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.DataCube`4.Labels">
            <summary>Returns the labels</summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.DataCube`4.Layers">
            <summary>Returns the layers</summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.DataCube`4.Columns">
            <summary>Returns the number of columns</summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.DataCube`4.Rows">
            <summary>Returns the number of rows</summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.DataCube`4.Depth">
            <summary>Returns the number of layers</summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.DataCube`4.Data">
            <summary>Gets the data</summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.DataCube`4.Item(System.Int32,System.Int32,System.Int32)">
            <summary>Gets and sets the data for the i-th row and j-th column of the <c>DataFrame</c></summary>
            <param name="i">the row index</param>
            <param name="j">the column index</param>
            <param name="k">the layer index</param>
            <returns>a data point</returns>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.DataCube`4.Item(`0,`1,`2)">
            <summary>Gets and sets the data for a given legend and a given label</summary>
            <param name="t">the legend</param>
            <param name="u">the label</param>
            <param name="v">the layer</param>
            <returns>a data point</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataCube`4.GetLabelRank(`1)">
            <summary>Returns the label rank</summary>
            <param name="label">the target label</param>
            <returns>an <c>Integer</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataCube`4.GetSeriesAt(`1,`2)">
            <summary> Gets the data-point column of the given label and layer</summary>
            <param name="label">the label</param>
            <param name="layer">the layer</param>
            <returns> a <c>Series</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataCube`4.GetSeries">
            <summary> Gets all the data as an array of <c>Series</c></summary>
            <returns>an array of <c>Series</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataCube`4.GetDataFrameForLabel(`1)">
            <summary>Gets the dataframe for a given label</summary>
            <param name="label">the label</param>
            <returns>a <c>DataFrame</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataCube`4.GetDataFrameForLayer(`2)">
            <summary>Gets the dataframe for a given layer</summary>
            <param name="layer">the layer</param>
            <returns>a <c>DataFrame</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataCube`4.Clone">
            <summary>Clones the <c>DataCube</c></summary>
            <returns>a <c>DataCube</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataCube`4.ApplyOnData(System.Func{`3,`3})">
            <summary>Applies a function to all the data</summary>
            <param name="function">the function</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataCube`4.ApplyOnLegends(System.Func{`0,`0})">
            <summary>Applies a function to all the legends</summary>
            <param name="function">the function</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataCube`4.ApplyOnLabels(System.Func{`1,`1})">
            <summary>Applies a function to all the labels</summary>
            <param name="function">the function</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataCube`4.ApplyOnLayers(System.Func{`2,`2})">
            <summary>Applies a function to all the layers</summary>
            <param name="function">the function</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataCube`4.GetLegend(System.Int32)">
            <summary>Gets the i-th legend value</summary>
            <param name="index">the index</param>
            <returns>a legend value</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataCube`4.RenameLegend(`0,`0)">
            <summary>Renames a legend</summary>
            <param name="oldValue">the old legend value</param>
            <param name="newValue">the new legend value</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataCube`4.GetLabel(System.Int32)">
            <summary>Gets the i-th label's value</summary>
            <param name="index">the index</param>
            <returns>a label</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataCube`4.RenameLabel(`1,`1)">
            <summary>Renames a label</summary>
            <param name="oldValue">the old value</param>
            <param name="newValue">the new value</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataCube`4.GetLayer(System.Int32)">
            <summary>Gets the i-th layer's value</summary>
            <param name="index">the index</param>
            <returns>a layer</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataCube`4.RenameLabel(`2,`2)">
            <summary>Renames a layer</summary>
            <param name="oldValue">the old value</param>
            <param name="newValue">the new value</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataCube`4.ToXml(System.Xml.XmlWriter)">
            <summary>Serializes the <c>DataCube</c> to Xml </summary>
            <param name="writer">the <c>XmlWriter</c></param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataCube`4.ToCSV(System.String)">
            <summary>Builds a string representation of the content of the <c>DataFrame</c> </summary>
            <param name="separator">Column separator</param>
            <returns>a <c>String</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataCube`4.Equals(Euclid.DataStructures.IndexedSeries.DataCube{`0,`1,`2,`3})">
            <summary>Equality comparer</summary>
            <param name="other">the other DataFrame</param>
            <returns>true if the data, legends and labels match, false otherwise</returns>
        </member>
        <member name="T:Euclid.DataStructures.IndexedSeries.Header`1">
            <summary>Header class for the IIndexe</summary>
            <typeparam name="T">the type of label</typeparam>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Header`1.#ctor">
            <summary>Standard builder</summary>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Header`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>Builds a zero-indexed header</summary>
            <param name="content">the values of the labels</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Header`1.#ctor(Euclid.DataStructures.IMap{`0,System.Int32})">
            <summary> Builds a header from a two-way dictionary</summary>
            <param name="map">the map</param>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.Header`1.Values">
            <summary>Gets the labels</summary>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Header`1.Clone">
            <summary>Clones the header</summary>
            <returns>a Header</returns>
        </member>
        <member name="T:Euclid.DataStructures.IndexedSeries.Slice`3">
            <summary>Class representing a Slice of synchronized data</summary>
            <typeparam name="T">the legend type</typeparam>
            <typeparam name="TU">the data type</typeparam>
            <typeparam name="TV">the label type</typeparam>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.Slice`3.Legends">
            <summary>Gets the legends. Inherited (in this case, the legend is packaged into an array)</summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.Slice`3.Legend">
            <summary>Gets and sets the legend</summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.Slice`3.Labels">
            <summary>Returns the labels</summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.Slice`3.Columns">
            <summary>Returns the number of columns</summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.Slice`3.Rows">
            <summary>Returns the number of rows</summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.Slice`3.Data">
            <summary> Gets a deep copy of the data</summary>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Slice`3.Clone">
            <summary>Clones the slice</summary>
            <returns>a <c>Slice</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Slice`3.RemoveColumnAt(`2)">
            <summary>Remove the data for a given label</summary>
            <param name="label">the label</param>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.Slice`3.Item(System.Int32)">
            <summary>Gets and sets the i-th data </summary>
            <param name="i">the index</param>
            <returns>a data point</returns>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.Slice`3.Item(`2)">
            <summary>Gets and sets the data for a given label</summary>
            <param name="v">the target label</param>
            <returns>a data point</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Slice`3.Add(`2,`1)">
            <summary>Adds a data to the slice</summary>
            <param name="label">the new label</param>
            <param name="value">the new value</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Slice`3.ApplyOnData(System.Func{`1,`1})">
            <summary>Applies a function to the data</summary>
            <param name="function">the function</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Slice`3.GetLabel(System.Int32)">
            <summary>Gets the i-th label's value</summary>
            <param name="i">the index</param>
            <returns>a label</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Slice`3.RenameLabel(`2,`2)">
            <summary>Sets the i-th label's value</summary>
            <param name="oldValue">the old value</param>
            <param name="newValue">the new value</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Slice`3.ToXml(System.Xml.XmlWriter)">
            <summary>Serializes the slice to Xml </summary>
            <param name="writer">the <c>XmlWriter</c></param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Slice`3.ToCSV(System.String)">
            <summary>Builds a string representation the content of the slice </summary>
            <param name="separator">Column separator</param>
            <returns>a <c>String</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Slice`3.Create(System.Xml.XmlNode)">
            <summary>De-serializes the slice from a Xml node</summary>
            <param name="node">the <c>XmlNode</c></param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Slice`3.Create(Euclid.DataStructures.IndexedSeries.IHeader{`2},`0,System.Collections.Generic.IEnumerable{`1})">
            <summary>Builds a slice from generic enumerable labels and data</summary>
            <param name="labels">the labels</param>
            <param name="legend">the legend</param>
            <param name="data">the data</param>
            <returns>a <c>Slice</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Slice`3.Create(System.String)">
            <summary>Builds a <c>Slice</c> from its CSV string</summary>
            <param name="text">the <c>String</c> content</param>
        </member>
        <member name="T:Euclid.DataStructures.IndexedSeries.Series`3">
            <summary>Class representing a Series of data</summary>
            <typeparam name="T">the legend type</typeparam>
            <typeparam name="TU">the data type</typeparam>
            <typeparam name="TV">the label type</typeparam>
        </member>
        <member name="F:Euclid.DataStructures.IndexedSeries.Series`3._label">
            <summary>
            Label variable
            </summary>
        </member>
        <member name="F:Euclid.DataStructures.IndexedSeries.Series`3._data">
            <summary>
            Data variable
            </summary>
        </member>
        <member name="F:Euclid.DataStructures.IndexedSeries.Series`3._legends">
            <summary>
            Legend variable
            </summary>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Series`3.#ctor">
            <summary>
            Parameterless constructor
            </summary>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Series`3.#ctor(`2,Euclid.DataStructures.IndexedSeries.IHeader{`0},`1[])">
            <summary>Builds a <c>Series</c></summary>
            <param name="label">the label</param>
            <param name="legends">the legends</param>
            <param name="data">the data</param>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.Series`3.Legends">
            <summary>Returns the legends of the <c>Series</c></summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.Series`3.Labels">
            <summary>Returns the labels of the <c>Series</c> (in this case, it is the only label)</summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.Series`3.Data">
            <summary>Returns the data of the <c>Series</c></summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.Series`3.Label">
            <summary>Gets and sets the label</summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.Series`3.Columns">
            <summary>Returns the number of columns of the <c>Series</c> (in this case, it is one)</summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.Series`3.Rows">
            <summary>Returns the number of rows of the <c>Series</c></summary>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Series`3.Clone``1">
            <summary>Clones the <c>Series</c></summary>
            <returns>a <c>Series</c></returns>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.Series`3.Item(System.Int32)">
            <summary>Gets and sets the i-th data of the <c>Series</c></summary>
            <param name="index">the index</param>
            <returns>a data point</returns>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.Series`3.Item(`0)">
            <summary>Gets and sets the data for a given legend</summary>
            <param name="t">the legend</param>
            <returns>a data point</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Series`3.RemoveRowAt(`0)">
            <summary>Removes the row for a given legend</summary>
            <param name="t">the legend</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Series`3.Add(`0,`1)">
            <summary>Adds a line to the <c>Series</c></summary>
            <param name="legend">the new legend</param>
            <param name="value">the new data</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Series`3.Remove(System.Func{`0,`1,System.Boolean})">
            <summary>Removes all the data-points that fit a predicate</summary>
            <param name="predicate">the predicate</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Series`3.ApplyOnData(System.Func{`1,`1})">
            <summary>Applies a function to all the data</summary>
            <param name="function">the function</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Series`3.ApplyOnLegends(System.Func{`0,`0})">
            <summary>Applies a function to all the legends</summary>
            <param name="function">the function</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Series`3.Sum(System.Func{`1,`1})">
            <summary>Returns the sum of the data passed through a function</summary>
            <param name="function">the function</param>
            <returns>a scalar</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Series`3.GetLegend(System.Int32)">
            <summary>Gets the i-th legend value</summary>
            <param name="index">the index</param>
            <returns>a legend value</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Series`3.Rename(`0,`0)">
            <summary>Sets the i-th legend value </summary>
            <param name="oldValue">the old legend</param>
            <param name="newValue">the new legend value</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Series`3.Equals(Euclid.DataStructures.IndexedSeries.Series{`0,`1,`2})">
            <summary>Equality comparer for the Series</summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Series`3.ToXml(System.Xml.XmlWriter)">
            <summary>Serializes the <c>Series</c> to Xml </summary>
            <param name="writer">the <c>XmlWriter</c></param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Series`3.ToCSV(System.String)">
            <summary>Builds a string representing the content of the <c>Series</c></summary>
            <param name="separator">column separator, by default ';' is used</param>
            <returns>a <c>String</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Series`3.op_Addition(Euclid.DataStructures.IndexedSeries.Series{`0,`1,`2},Euclid.DataStructures.IndexedSeries.Series{`0,`1,`2})">
            <summary>Adds two <c>Series</c></summary>
            <param name="ts1">the left hand side <c>Series</c></param>
            <param name="ts2">the right hand side <c>Series</c></param>
            <returns>a <c>Series</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Series`3.op_Subtraction(Euclid.DataStructures.IndexedSeries.Series{`0,`1,`2},Euclid.DataStructures.IndexedSeries.Series{`0,`1,`2})">
            <summary>Substracts one <c>Series</c> to another</summary>
            <param name="ts1">the left hand side <c>Series</c></param>
            <param name="ts2">the right hand side <c>Series</c></param>
            <returns>a <c>Series</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Series`3.op_Multiply(Euclid.DataStructures.IndexedSeries.Series{`0,`1,`2},`1)">
            <summary>Multiplies the <c>Series</c> by a factor</summary>
            <param name="ts">the <c>Series</c></param>
            <param name="factor">the factor </param>
            <returns>a <c>Series</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Series`3.op_Multiply(`1,Euclid.DataStructures.IndexedSeries.Series{`0,`1,`2})">
            <summary>Multiplies the <c>Series</c> by a factor</summary>
            <param name="factor">the factor</param>
            <param name="ts">the <c>Series</c></param>
            <returns>a <c>Series</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Series`3.op_Division(Euclid.DataStructures.IndexedSeries.Series{`0,`1,`2},`1)">
            <summary>Divides the <c>Series</c> by a factor</summary>
            <param name="ts">the <c>Series</c></param>
            <param name="factor">the factor</param>
            <returns>a <c>Series</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Series`3.op_Addition(Euclid.DataStructures.IndexedSeries.Series{`0,`1,`2},`1)">
            <summary>Adds a scalar to a <c>Series</c></summary>
            <param name="ts">the <c>Series</c></param>
            <param name="amount">the number</param>
            <returns>a <c>Series</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Series`3.op_Addition(`1,Euclid.DataStructures.IndexedSeries.Series{`0,`1,`2})">
            <summary>Adds a scalar to a <c>Series</c></summary>
            <param name="amount">the scalar</param>
            <param name="ts">the <c>Series</c></param>
            <returns>a <c>Series</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Series`3.op_Subtraction(Euclid.DataStructures.IndexedSeries.Series{`0,`1,`2},`1)">
            <summary>Substracts a scalar to a <c>Series</c></summary>
            <param name="ts">the <c>Series</c></param>
            <param name="amount">the scalar</param>
            <returns>a <c>Series</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Series`3.Initialize(`2,System.Collections.Generic.IList{`0},`1[])">
            <summary>
            Initialize serie instance
            </summary>
            <param name="label">Label</param>
            <param name="legends">Legends</param>
            <param name="data">Data</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Series`3.Initialize(`1)">
            <summary>
            Initialize the data vector with the specified value.
            </summary>
            <param name="value">Value used for initialization</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Series`3.Create``1(`2,System.Collections.Generic.IList{`0},`1[])">
            <summary>
            Builds a <c>Series</c> from generic enumerables of legends and data
            </summary>
            <typeparam name="TY">Generic type</typeparam>
            <param name="label">label</param>
            <param name="legends">legends</param>
            <param name="data">data</param>
            <returns>Instance</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Series`3.Create``1(`2,Euclid.DataStructures.IndexedSeries.IHeader{`0},`1[])">
            <summary>
            Create a <c>Series</c> from generic enumerables of legends and data
            </summary>
            <typeparam name="TY">Typed series</typeparam>
            <param name="label">Label</param>
            <param name="legends">Legends</param>
            <param name="data">Data</param>
            <returns>Series</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Series`3.Create``1(`2,System.Collections.Generic.IList{`0})">
            <summary>Builds a <c>Series</c> from generic enumerables of legends</summary>
            <param name="label">the label</param>
            <param name="legends">the legends</param>
            <returns>a <c>Series</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Series`3.Create``1(System.Xml.XmlNode)">
            <summary>Builds a <c>Series</c> from its serialized form</summary>
            <param name="node">the <c>XmlNode</c></param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.Series`3.Create``1(System.String)">
            <summary>Builds a <c>Series</c> from a string</summary>
            <param name="text">the <c>String</c> content</param>
        </member>
        <member name="T:Euclid.DataStructures.IndexedSeries.DataFrame`3">
            <summary>Class representing a DataFrame of synchronized data</summary>
            <typeparam name="T">the legend type</typeparam>
            <typeparam name="TU">the data type</typeparam>
            <typeparam name="TV">the label type</typeparam>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataFrame`3.#ctor(System.Collections.Generic.IList{`2},System.Collections.Generic.IList{`0},`1[][])">
            <summary>
            Constructor of DataFrame
            </summary>
            <param name="labels">Label</param>
            <param name="legends">Legends</param>
            <param name="data">Data</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataFrame`3.#ctor">
            <summary>
            Constructor parameterless
            </summary>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataFrame`3.Initialize(System.Collections.Generic.IList{`2},System.Collections.Generic.IList{`0},`1[][])">
            <summary>
            Initialize DataFrame instance
            </summary>
            <param name="labels">labels</param>
            <param name="legends">legends</param>
            <param name="data">data</param>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.DataFrame`3.Legends">
            <summary>Returns the legends </summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.DataFrame`3.Labels">
            <summary>Returns the labels </summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.DataFrame`3.Columns">
            <summary>Returns the number of columns</summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.DataFrame`3.Rows">
            <summary>Returns the number of rows</summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.DataFrame`3.Data">
            <summary>Gets the data</summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.DataFrame`3.Item(System.Int32,System.Int32)">
            <summary>Gets and sets the data for the i-th row and j-th column of the <c>DataFrame</c></summary>
            <param name="i">the row index</param>
            <param name="j">the column index</param>
            <returns>a data point</returns>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.DataFrame`3.Item(`0,`2)">
            <summary>Gets and sets the data for a given legend and a given label</summary>
            <param name="t">the legend</param>
            <param name="v">the label</param>
            <returns>a data point</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataFrame`3.GetLabelRank(`2)">
            <summary>Returns the label rank</summary>
            <param name="label">the target label</param>
            <returns>an <c>Integer</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataFrame`3.GetLabelRank(`0)">
            <summary>Returns the legend rank</summary>
            <param name="legend">the target legend</param>
            <returns>an <c>Integer</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataFrame`3.GetSeriesAt(`2)">
            <summary> Gets the data-point column of the given label</summary>
            <param name="label">the label</param>
            <returns> a <c>Series</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataFrame`3.GetSeriesAt(`2,System.Func{`0,System.Boolean})">
            <summary> Gets the data-point column of the given label</summary>
            <param name="label">the label</param>
            <param name="predicate">legend predicate</param>
            <returns> a <c>Series</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataFrame`3.GetSeries">
            <summary> Gets all the data as an array of <c>Series</c></summary>
            <returns>an array of <c>Series</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataFrame`3.AddSeries(`2,`1[])">
            <summary> Adds a column to the <c>DataFrame</c></summary>
            <param name="label">the new column's label</param>
            <param name="column">the new column's data</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataFrame`3.AddSeries(`2)">
            <summary>Adds an empty column to the <c>DataFrame</c></summary>
            <param name="label">the new column's label</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataFrame`3.TakeSeries(`2)">
            <summary>Takes a <c>Series</c> from the DataFrame thereby removing it from the DataFrame</summary>
            <param name="label">the label of the <c>Series</c> to take</param>
            <returns> a <c>Series</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataFrame`3.RemoveSeriesAt(`2)">
            <summary>Remove the data for a given label</summary>
            <param name="label">the label</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataFrame`3.ExtractByLabels(System.Func{`2,System.Boolean})">
            <summary>Extracts the part of the DataFrame whose labels obeys the predicate</summary>
            <param name="predicate">the predicate on the labels</param>
            <returns>a DataFrame</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataFrame`3.GetSliceAt(`0)">
            <summary>Gets the data-point row of the given legend</summary>
            <param name="legend">the legend</param>
            <returns>a <c>Slice</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataFrame`3.GetSlices">
            <summary>Gets all the data as an array of <c>Slice</c></summary>
            <returns>an array of <c>Slice</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataFrame`3.AddSlice(`0,`1[])">
            <summary> Adds a slice to the <c>DataFrame</c></summary>
            <param name="legend">the new slice's legend</param>
            <param name="slice">the new slice's data</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataFrame`3.AddSlice(`0)">
            <summary>Adds an empty slice to the <c>DataFrame</c></summary>
            <param name="legend">the new slice's legend</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataFrame`3.TakeSlice(`0)">
            <summary>Takes a <c>Slice</c> from the DataFrame thereby removing it from the DataFrame</summary>
            <param name="legend">the legend of the <c>Slice</c> to take</param>
            <returns> a <c>Slice</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataFrame`3.RemoveSliceAt(`0)">
            <summary>Removes the row for a given legend</summary>
            <param name="legend">the legend</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataFrame`3.ExtractByLegend(System.Func{`0,System.Boolean})">
            <summary>Extracts the part of the DataFrame whose legends obeys the predicate</summary>
            <param name="predicate">the predicate on the legends</param>
            <returns>a DataFrame</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataFrame`3.Clone">
            <summary>Clones the <c>DataFrame</c></summary>
            <returns>a <c>DataFrame</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataFrame`3.ApplyOnData(System.Func{`1,`1})">
            <summary>Applies a function to all the data</summary>
            <param name="function">the function</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataFrame`3.ApplyOnLegends(System.Func{`0,`0})">
            <summary>Applies a function to all the legends</summary>
            <param name="function">the function</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataFrame`3.ApplyOnLabels(System.Func{`2,`2})">
            <summary>Applies a function to all the labels</summary>
            <param name="function">the function</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataFrame`3.GetLegend(System.Int32)">
            <summary>Gets the i-th legend value</summary>
            <param name="index">the index</param>
            <returns>a legend value</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataFrame`3.RenameLegend(`0,`0)">
            <summary>Renames a legend</summary>
            <param name="oldValue">the old legend value</param>
            <param name="newValue">the new legend value</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataFrame`3.GetLabel(System.Int32)">
            <summary>Gets the i-th label's value</summary>
            <param name="index">the index</param>
            <returns>a label</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataFrame`3.RenameLabel(`2,`2)">
            <summary>Renames a label</summary>
            <param name="oldValue">the old value</param>
            <param name="newValue">the new value</param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataFrame`3.ToXml(System.Xml.XmlWriter)">
            <summary>Serializes the <c>DataFrame</c> to Xml </summary>
            <param name="writer">the <c>XmlWriter</c></param>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataFrame`3.FromXml(System.Xml.XmlNode)">
            <summary>Buils a <c>DataFrame</c></summary>
            <param name="node">the Xml node</param>
            <returns>a DataFrame</returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataFrame`3.ToCSV">
            <summary>Builds a string representation of the content of the <c>DataFrame</c> </summary>
            <returns>a <c>String</c></returns>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.DataFrame`3.Equals(Euclid.DataStructures.IndexedSeries.DataFrame{`0,`1,`2})">
            <summary>Equality comparer</summary>
            <param name="other">the other DataFrame</param>
            <returns>true if the data, legends and labels match, false otherwise</returns>
        </member>
        <member name="T:Euclid.DataStructures.IndexedSeries.IIndexedSeries`3">
            <summary>
            Interface for all series : DataFrame, Slice, Series
            </summary>
            <typeparam name="T">the type of legends</typeparam>
            <typeparam name="TU">the type of the data</typeparam>
            <typeparam name="TV">the type of the labels</typeparam>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.IIndexedSeries`3.Legends">
            <summary>Gets the legends</summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.IIndexedSeries`3.Labels">
            <summary> Gets the labels </summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.IIndexedSeries`3.Rows">
            <summary>Gets the number of rows</summary>
        </member>
        <member name="P:Euclid.DataStructures.IndexedSeries.IIndexedSeries`3.Columns">
            <summary>Gets the number of columns </summary>
        </member>
        <member name="M:Euclid.DataStructures.IndexedSeries.IIndexedSeries`3.ApplyOnData(System.Func{`1,`1})">
            <summary>Applies a function to the data</summary>
            <param name="function">the function</param>
        </member>
        <member name="T:Euclid.DataStructures.SortedMap`2">
            <summary>
            A two ways sorted dictionary class
            </summary>
            <typeparam name="T1">the left hand side type</typeparam>
            <typeparam name="T2">the right hand side type</typeparam>
        </member>
        <member name="M:Euclid.DataStructures.SortedMap`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IDictionary{`1,`0})">
            <summary>
            Private constructor
            </summary>
            <param name="forward">forward field</param>
            <param name="backward">backward field</param>
        </member>
        <member name="M:Euclid.DataStructures.SortedMap`2.#ctor">
            <summary>
            Empty sorted map
            </summary>
        </member>
        <member name="M:Euclid.DataStructures.SortedMap`2.Clone">
            <summary>Gets a deep copy of the sorted map</summary>
        </member>
        <member name="T:Euclid.DataStructures.TreeNode`1">
            <summary>Represents a tree node</summary>
            <typeparam name="T">The value type</typeparam>
        </member>
        <member name="P:Euclid.DataStructures.TreeNode`1.Value">
            <summary>Gets and sets the node's value</summary>
        </member>
        <member name="P:Euclid.DataStructures.TreeNode`1.Left">
            <summary>Gets and sets the left node</summary>
        </member>
        <member name="P:Euclid.DataStructures.TreeNode`1.Right">
            <summary>Gets and sets the right node</summary>
        </member>
        <member name="P:Euclid.DataStructures.TreeNode`1.Parent">
            <summary>Gets and sets the parent node</summary>
        </member>
        <member name="P:Euclid.DataStructures.TreeNode`1.Leaves">
            <summary>Returns all the leaves</summary>
        </member>
        <member name="P:Euclid.DataStructures.TreeNode`1.IsRoot">
            <summary>Indicates if the current node is the root node</summary>
        </member>
        <member name="P:Euclid.DataStructures.TreeNode`1.IsLeaf">
            <summary>Indicates if the current node is a leaf node</summary>
        </member>
        <member name="M:Euclid.DataStructures.TreeNode`1.BuildRoot(Euclid.DataStructures.TreeNode{`0},Euclid.DataStructures.TreeNode{`0})">
            <summary>Builds a root tree node</summary>
            <param name="left">the left child node</param>
            <param name="right">the right child node</param>
            <returns>a tree node</returns>
        </member>
        <member name="T:Euclid.DataStructures.SelfFlushedQueue`1">
            <summary>Queue that flushes itself whenever it reaches a given size</summary>
            <typeparam name="T">the template type of the data</typeparam>
        </member>
        <member name="M:Euclid.DataStructures.SelfFlushedQueue`1.#ctor(System.Int32,Euclid.DataStructures.SelfFlushedQueue{`0}.Flush)">
            <summary>Builds a <c>SelfFlushedQueue</c></summary>
            <param name="maximumSize">the maximum size of the Queue</param>
            <param name="flushCallBack">the method to use of the flushed data</param>
        </member>
        <member name="M:Euclid.DataStructures.SelfFlushedQueue`1.Add(`0)">
            <summary>Adds an item to the queue</summary>
            <param name="t">the item to add</param>
        </member>
        <member name="M:Euclid.DataStructures.SelfFlushedQueue`1.ForceFlush">
            <summary>
            Flushes the data stored in the queue
            </summary>
        </member>
        <member name="T:Euclid.DataStructures.SelfFlushedQueue`1.Flush">
            <summary>Delegate definition of the flush method</summary>
            <param name="content">the data to treat after flush</param>
        </member>
        <member name="T:Euclid.DataStructures.IMap`2">
            <summary>
            A two ways dictionary interface
            </summary>
            <typeparam name="T1">the left hand side type</typeparam>
            <typeparam name="T2">the right hand side type</typeparam>
        </member>
        <member name="P:Euclid.DataStructures.IMap`2.ForwardEnumerator">
            <summary>Gets an enumerator for the left hand side</summary>
        </member>
        <member name="P:Euclid.DataStructures.IMap`2.BackwardEnumerator">
            <summary>Gets an enumerator for the right hand side </summary>
        </member>
        <member name="M:Euclid.DataStructures.IMap`2.Add(`0,`1)">
            <summary>Adds a pair to the map</summary>
            <param name="t1">the left hand side key</param>
            <param name="t2">the right hand side key</param>
        </member>
        <member name="M:Euclid.DataStructures.IMap`2.Remove(`0,`1)">
            <summary>Removes a pair from the map</summary>
            <param name="t1">the left hand side key</param>
            <param name="t2">the right hand side key</param>
        </member>
        <member name="M:Euclid.DataStructures.IMap`2.SetForward(`0,`1)">
            <summary>Sets the right hand side value for a given left hand side value</summary>
            <param name="key">the left hand side key</param>
            <param name="newValue">the new right hand side value</param>
        </member>
        <member name="M:Euclid.DataStructures.IMap`2.SetBackward(`1,`0)">
            <summary>Sets the left hand side value for a given right hand side value</summary>
            <param name="key">the right hand side key</param>
            <param name="newValue">the new left right hand side value</param>
        </member>
        <member name="M:Euclid.DataStructures.IMap`2.ContainsForwardKey(`0)">
            <summary>Checks if the left hand side contains a key</summary>
            <param name="t1">the left hand side key</param>
            <returns><c>True</c> if this is a left hand side key, <c>False</c> otherwise</returns>
        </member>
        <member name="M:Euclid.DataStructures.IMap`2.ContainsBackwardKey(`1)">
            <summary>Checks if the right hand side contains a key</summary>
            <param name="t2">the right hand side key</param>
            <returns><c>True</c> if this a right hand side key, <c>False</c> otherwise</returns>
        </member>
        <member name="M:Euclid.DataStructures.IMap`2.Forward(`0)">
            <summary>Gets the right hand side value associated to a left hand side key</summary>
            <param name="t1">The left hand side key</param>
            <returns>a right hand side key</returns>
        </member>
        <member name="M:Euclid.DataStructures.IMap`2.Backward(`1)">
            <summary>Gets the left hand side value associated to a right hand side key</summary>
            <param name="t2">The right hand side key</param>
            <returns>a left hand side key</returns>
        </member>
        <member name="P:Euclid.DataStructures.IMap`2.Lefts">
            <summary>Gets the left hand side keys</summary>
        </member>
        <member name="P:Euclid.DataStructures.IMap`2.Rights">
            <summary>Gets the right hand side keys</summary>
        </member>
        <member name="P:Euclid.DataStructures.IMap`2.Count">
            <summary>Gets the number of pairs in the map</summary>
        </member>
        <member name="M:Euclid.DataStructures.IMap`2.Clone">
            <summary>Gets a deep copy of the map</summary>
        </member>
        <member name="T:Euclid.DataStructures.Map`2">
            <summary>A two ways dictionary class</summary>
            <typeparam name="T1">the left hand side type</typeparam>
            <typeparam name="T2">the right hand side type</typeparam>
        </member>
        <member name="F:Euclid.DataStructures.Map`2._lock">
            <summary>
            lock field for thread safety
            </summary>
        </member>
        <member name="F:Euclid.DataStructures.Map`2._forward">
            <summary>
            forward field
            </summary>
        </member>
        <member name="F:Euclid.DataStructures.Map`2._backward">
            <summary>
            backward field
            </summary>
        </member>
        <member name="M:Euclid.DataStructures.Map`2.#ctor">
            <summary>Builds an empty map</summary>
        </member>
        <member name="M:Euclid.DataStructures.Map`2.#ctor(System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}})">
            <summary>Builds a Map of </summary>
            <param name="values"></param>
        </member>
        <member name="P:Euclid.DataStructures.Map`2.ForwardEnumerator">
            <summary>Gets an enumerator for the left hand side</summary>
        </member>
        <member name="P:Euclid.DataStructures.Map`2.BackwardEnumerator">
            <summary>Gets an enumerator for the right hand side </summary>
        </member>
        <member name="M:Euclid.DataStructures.Map`2.Add(`0,`1)">
            <summary>Adds a pair to the map</summary>
            <param name="t1">the left hand side key</param>
            <param name="t2">the right hand side key</param>
        </member>
        <member name="M:Euclid.DataStructures.Map`2.Remove(`0,`1)">
            <summary>Removes a pair from the map</summary>
            <param name="t1">the left hand side key</param>
            <param name="t2">the right hand side key</param>
        </member>
        <member name="M:Euclid.DataStructures.Map`2.SetForward(`0,`1)">
            <summary>Sets the right hand side value for a given left hand side value</summary>
            <param name="key">the left hand side key</param>
            <param name="newValue">the new right hand side value</param>
        </member>
        <member name="M:Euclid.DataStructures.Map`2.SetBackward(`1,`0)">
            <summary>Sets the left hand side value for a given right hand side value</summary>
            <param name="key">the right hand side key</param>
            <param name="newValue">the new left right hand side value</param>
        </member>
        <member name="M:Euclid.DataStructures.Map`2.ContainsForwardKey(`0)">
            <summary>Checks if the left hand side contains a key</summary>
            <param name="t1">the left hand side key</param>
            <returns><c>True</c> if this is a left hand side key, <c>False</c> otherwise</returns>
        </member>
        <member name="M:Euclid.DataStructures.Map`2.ContainsBackwardKey(`1)">
            <summary>Checks if the right hand side contains a key</summary>
            <param name="t2">the right hand side key</param>
            <returns><c>True</c> if this a right hand side key, <c>False</c> otherwise</returns>
        </member>
        <member name="M:Euclid.DataStructures.Map`2.Forward(`0)">
            <summary>Gets the right hand side value associated to a left hand side key</summary>
            <param name="t1">The left hand side key</param>
            <returns>a right hand side key</returns>
        </member>
        <member name="M:Euclid.DataStructures.Map`2.Backward(`1)">
            <summary>Gets the left hand side value associated to a right hand side key</summary>
            <param name="t2">The right hand side key</param>
            <returns>a left hand side key</returns>
        </member>
        <member name="P:Euclid.DataStructures.Map`2.Lefts">
            <summary>Gets the left hand side keys</summary>
        </member>
        <member name="P:Euclid.DataStructures.Map`2.Rights">
            <summary>Gets the right hand side keys</summary>
        </member>
        <member name="P:Euclid.DataStructures.Map`2.Count">
            <summary>Gets the number of pairs in the map</summary>
        </member>
        <member name="M:Euclid.DataStructures.Map`2.Clone">
            <summary>Gets a deep copy of the map</summary>
        </member>
        <member name="T:Euclid.Complex">
            <summary>Represents complex numbers</summary>
        </member>
        <member name="M:Euclid.Complex.#ctor(System.Double,System.Double)">
            <summary>
            Builds a <c>Complex</c> number
            </summary>
            <param name="real">the real part of the <c>Complex</c></param>
            <param name="imaginary">the imaginary part of the <c>Complex</c></param>
        </member>
        <member name="M:Euclid.Complex.#ctor">
            <summary>
            Builds a <c>Complex</c> number with its real and imaginary parts at zero
            </summary>
        </member>
        <member name="P:Euclid.Complex.Re">
            <summary>Returns the real part of the <c>Complex</c></summary>
        </member>
        <member name="P:Euclid.Complex.Im">
            <summary>Returns the imaginary part of the <c>Complex</c></summary>
        </member>
        <member name="P:Euclid.Complex.Conjugate">
            <summary>The conjugate number of the <c>Complex</c></summary>
        </member>
        <member name="M:Euclid.Complex.Modulus">
            <summary>Returns the modulus of the <c>Complex</c></summary>
            <returns>the modulus of the complex</returns>
        </member>
        <member name="M:Euclid.Complex.SquareModulus">
            <summary>Returns the square of the modulus of the <c>Complex</c></summary>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Complex.Argument">
            <summary>
            Returns the argument of the <c>Complex</c> (between -Pi and +Pi)
            </summary>
            <returns>the argument of the <c>Complex</c></returns>
        </member>
        <member name="M:Euclid.Complex.ToString">
            <summary>
            Returns a string that represents the <c>Complex</c>
            </summary>
            <returns>a string that represents the <c>Complex</c></returns>
        </member>
        <member name="M:Euclid.Complex.ToString(System.String)">
            <summary>
            returns a string that represents the <c>Complex</c> with the specified format to the composants
            </summary>
            <param name="format">the format string</param>
            <returns>a string that represents the <c>Complex</c></returns>
        </member>
        <member name="P:Euclid.Complex.I">
            <summary>Returns the imaginary number <c>i</c></summary>
        </member>
        <member name="P:Euclid.Complex.One">
            <summary>Returns the complex representation of the real number 1</summary>
        </member>
        <member name="P:Euclid.Complex.Zero">
            <summary>Returns a complex with both imaginary and real parts equal to zero</summary>
        </member>
        <member name="M:Euclid.Complex.Exp(Euclid.Complex)">
            <summary>Returns a complex from its exponential form </summary>
            <param name="complex">the exponential argument</param>
            <returns>a <c>Complex</c></returns>
        </member>
        <member name="M:Euclid.Complex.op_Addition(Euclid.Complex,Euclid.Complex)">
            <summary>Allows to add a complex to another complex</summary>
            <param name="lhs">the right hand side</param>
            <param name="rhs">the left hand side</param>
            <returns>the <c>Complex</c> result of the addition</returns>
        </member>
        <member name="M:Euclid.Complex.Add(Euclid.Complex,System.Double)">
            <summary>Allows to add a scalar to a complex</summary>
            <param name="complex">the complex left hand side</param>
            <param name="addon">the scalar right hand side</param>
            <returns>the <c>Complex</c> result of the addition</returns>
        </member>
        <member name="M:Euclid.Complex.op_Addition(Euclid.Complex,System.Double)">
            <summary>Allows to add a scalar to a complex</summary>
            <param name="complex">the complex left hand side</param>
            <param name="addon">the scalar right hand side</param>
            <returns>the <c>Complex</c> result of the addition</returns>
        </member>
        <member name="M:Euclid.Complex.op_Addition(System.Double,Euclid.Complex)">
            <summary>Allows to add a scalar to a complex</summary>
            <param name="addon">the scalar right hand side </param>
            <param name="complex">the complex left hand side</param>
            <returns>the <c>Complex</c> result of the addition</returns>
        </member>
        <member name="M:Euclid.Complex.op_Subtraction(Euclid.Complex,Euclid.Complex)">
            <summary>Allows to substract a complex to another complex</summary>
            <param name="rhs">the right hand side</param>
            <param name="lhs">the left hand side</param>
            <returns>the <c>Complex</c> result of the substraction</returns>
        </member>
        <member name="M:Euclid.Complex.op_Multiply(Euclid.Complex,Euclid.Complex)">
            <summary>Allows to multiply a complex by another complex</summary>
            <param name="lhs">the left hand side</param>
            <param name="rhs">the right hand side</param>
            <returns>the <c>Complex</c> result of the multiplication</returns>
        </member>
        <member name="M:Euclid.Complex.op_Multiply(Euclid.Complex,System.Double)">
            <summary>Allows to multiply a complex by a scalar</summary>
            <param name="complex">the complex number</param>
            <param name="factor">the scalar</param>
            <returns>the <c>Complex</c> result of the multiplication</returns>
        </member>
        <member name="M:Euclid.Complex.op_Multiply(System.Double,Euclid.Complex)">
            <summary>Allows to multiply a complex by a scalar</summary>
            <param name="factor">the scalar</param>
            <param name="complex">the complex number</param>
            <returns>the <c>Complex</c> result of the multiplication</returns>
        </member>
        <member name="M:Euclid.Complex.op_Division(Euclid.Complex,Euclid.Complex)">
            <summary>Allows to divide a complex by another complex</summary>
            <param name="numerator">the numerator</param>
            <param name="denominator">the denominator</param>
            <returns>the <c>Complex</c> result of the division</returns>
        </member>
        <member name="M:Euclid.Complex.op_Division(Euclid.Complex,System.Double)">
            <summary>Allows to divide a complex by a double</summary>
            <param name="complex">the numerator</param>
            <param name="factor">the denominator</param>
            <returns>the <c>Complex</c> result of the division</returns>
        </member>
        <member name="M:Euclid.Complex.op_UnaryNegation(Euclid.Complex)">
            <summary>Returns the opposite of the complex</summary>
            <param name="complex">the <c>Complex</c></param>
            <returns>the opposite complex</returns>
        </member>
        <member name="T:Euclid.Distributions.Continuous.CauchyDistribution">
            <summary>
            Cauchy distribution class
            </summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.CauchyDistribution.#ctor(System.Double,System.Double)">
            <summary>Builds a Cauchy distribution</summary>
            <param name="x0">the location</param>
            <param name="gamma">the scale</param>
        </member>
        <member name="P:Euclid.Distributions.Continuous.CauchyDistribution.Entropy">
            <summary>Gets the distribution's entropy</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.CauchyDistribution.Support">
            <summary>Gets the distribution's support</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.CauchyDistribution.Mean">
            <summary>Gets the distribution's mean</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.CauchyDistribution.Median">
            <summary>Gets the distribution's median</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.CauchyDistribution.Mode">
            <summary>Gets the distribution's mode</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.CauchyDistribution.Skewness">
            <summary>Gets the distribution's skewness</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.CauchyDistribution.StandardDeviation">
            <summary>Gets the distribution's standard deviation</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.CauchyDistribution.Variance">
            <summary>Gets the distribution's variance</summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.CauchyDistribution.Fit(Euclid.Distributions.FittingMethod,System.Double[])">
            <summary>Creates a new instance of the distribution fitted on the data sample</summary>
            <param name="sample">the sample of data to fit</param>
            <param name="method">the fitting method</param>
        </member>
        <member name="M:Euclid.Distributions.Continuous.CauchyDistribution.CumulativeDistribution(System.Double)">
            <summary>Computes the cumulative distribution(CDF) of the distribution at x, i.e.P(X ≤ x)</summary>
            <param name="x">the location at which to compute the function</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.CauchyDistribution.InverseCumulativeDistribution(System.Double)">
            <summary>
            Computes the inverse of the cumulative distribution function(InvCDF) for the distribution at the given probability.This is also known as the quantile or percent point function
            </summary>
            <param name="p">The location at which to compute the inverse cumulative density</param>
            <returns>the inverse cumulative density at p</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.CauchyDistribution.ProbabilityDensity(System.Double)">
            <summary>Computes the probability density of the distribution(PDF) at x, i.e. ∂P(X ≤ x)/∂x</summary>
            <param name="x">The location at which to compute the density</param>
            <returns>a <c>double</c></returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.CauchyDistribution.MomentGeneratingFunction(System.Double)">
            <summary>Evaluates the moment-generating function for a given t</summary>
            <param name="t">the argument</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.CauchyDistribution.ToString">
            <summary>Returns a string that represents this instance</summary>
            <returns>A string</returns>
        </member>
        <member name="T:Euclid.Distributions.Continuous.ChiSquaredDistribution">
            <summary>Chi squared distribution</summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ChiSquaredDistribution.#ctor(System.Int32)">
            <summary>
            Builds a Chi² distribution
            </summary>
            <param name="k">the number of freedom degrees</param>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ChiSquaredDistribution.Entropy">
            <summary>Gets the distribution's entropy</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ChiSquaredDistribution.Support">
            <summary>Gets the distribution's support</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ChiSquaredDistribution.Mean">
            <summary>Gets the distribution's mean</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ChiSquaredDistribution.Median">
            <summary>Gets the distribution's median</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ChiSquaredDistribution.Mode">
            <summary>Gets the distribution's mode</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ChiSquaredDistribution.Skewness">
            <summary>Gets the distribution's skewness</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ChiSquaredDistribution.StandardDeviation">
            <summary>Gets the dsitribution's standard deviation</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ChiSquaredDistribution.Variance">
            <summary>Gets the distribution's variance</summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ChiSquaredDistribution.Fit(Euclid.Distributions.FittingMethod,System.Double[])">
            <summary>Creates a new instance of the distribution fitted on the data sample</summary>
            <param name="sample">the sample of data to fit</param>
            <param name="method">the fitting method</param>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ChiSquaredDistribution.CumulativeDistribution(System.Double)">
            <summary>Computes the cumulative distribution(CDF) of the distribution at x, i.e.P(X ≤ x)</summary>
            <param name="x">The location at which to compute the cumulative distribution function</param>
            <returns>the cumulative distribution at location x</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ChiSquaredDistribution.InverseCumulativeDistribution(System.Double)">
            <summary>Computes the inverse of the cumulative distribution function(InvCDF) for the distribution at the given probability.This is also known as the quantile or percent point function</summary>
            <param name="p">The location at which to compute the inverse cumulative density</param>
            <returns>the inverse cumulative density at p</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ChiSquaredDistribution.ProbabilityDensity(System.Double)">
            <summary>Computes the probability density of the distribution(PDF) at x, i.e. ∂P(X ≤ x)/∂x</summary>
            <param name="x">The location at which to compute the density</param>
            <returns>a <c>double</c></returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ChiSquaredDistribution.MomentGeneratingFunction(System.Double)">
            <summary>Evaluates the moment-generating function for a given t</summary>
            <param name="t">the argument</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ChiSquaredDistribution.ToString">
            <summary>Returns a string that represents this instance</summary>
            <returns>A string</returns>
        </member>
        <member name="T:Euclid.Distributions.Continuous.EmpiricUnivariateDistribution">
            <summary>Empiric univariate distribution based on kernel functions</summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.EmpiricUnivariateDistribution.Create(System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double},System.Double,Euclid.Distributions.Continuous.Kernels.IDensityKernel)">
            <summary>Creates a new empiric univariate distribution</summary>
            <param name="weights">the weights</param>
            <param name="values">the values</param>
            <param name="h">the bandwidth</param>
            <param name="kernel">the kernel function</param>
            <returns>a <c>EmpiricUnivariateDistribution</c></returns>
        </member>
        <member name="P:Euclid.Distributions.Continuous.EmpiricUnivariateDistribution.Median">
            <summary>Gets the distribution's median</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.EmpiricUnivariateDistribution.Mean">
            <summary>Gets the distribution's mean</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.EmpiricUnivariateDistribution.Mode">
            <summary>Gets the distribution's mode</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.EmpiricUnivariateDistribution.StandardDeviation">
            <summary>Gets the distribution's standard deviation</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.EmpiricUnivariateDistribution.Variance">
            <summary>Gets the distribution's variance</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.EmpiricUnivariateDistribution.Support">
            <summary>Gets the distribution's support</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.EmpiricUnivariateDistribution.Skewness">
            <summary>Gets the distribution's skewness</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.EmpiricUnivariateDistribution.Entropy">
            <summary>Gets the distribution's entropy</summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.EmpiricUnivariateDistribution.CumulativeDistribution(System.Double)">
            <summary>Computes the cumulative distribution(CDF) of the distribution at x, i.e.P(X ≤ x)</summary>
            <param name="x">the location at which to compute the function</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.EmpiricUnivariateDistribution.InverseCumulativeDistribution(System.Double)">
            <summary>Computes the inverse of the cumulative distribution function</summary>
            <param name="p">the target probablity</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.EmpiricUnivariateDistribution.ProbabilityDensity(System.Double)">
            <summary>Computes the probability density of the distribution(PDF) at x, i.e. ∂P(X ≤ x)/∂x</summary>
            <param name="x">The location at which to compute the density</param>
            <returns>a <c>double</c></returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.EmpiricUnivariateDistribution.MomentGeneratingFunction(System.Double)">
            <summary>Evaluates the moment-generating function for a given t</summary>
            <param name="t">the argument</param>
            <returns>a double</returns>
        </member>
        <member name="T:Euclid.Distributions.Continuous.ExponentialPowerDistribution">
            <summary>Exponential power distribution class</summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ExponentialPowerDistribution.#ctor(System.Double,System.Double,System.Double)">
            <summary> Builds a Exponential power distribution</summary>
            <param name="mu">the location</param>
            <param name="alpha">the scale</param>
            <param name="beta">the shape</param>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ExponentialPowerDistribution.Entropy">
            <summary>Gets the distribution's entropy</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ExponentialPowerDistribution.Mean">
            <summary>Gets the distribution's mean</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ExponentialPowerDistribution.Median">
            <summary>Gets the distribution's median</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ExponentialPowerDistribution.Mode">
            <summary>Gets the distribution's mode</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ExponentialPowerDistribution.Skewness">
            <summary>Gets the distribution's skewness</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ExponentialPowerDistribution.StandardDeviation">
            <summary>Gets the distribution's standard deviation</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ExponentialPowerDistribution.Support">
            <summary>Gets the distribution's support</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ExponentialPowerDistribution.Variance">
            <summary>Gets the distribution's variance</summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ExponentialPowerDistribution.Fit(Euclid.Distributions.FittingMethod,System.Double[])">
            <summary>Creates a new instance of the distribution fitted on the data sample</summary>
            <param name="sample">the sample of data to fit</param>
            <param name="method">the fitting method</param>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ExponentialPowerDistribution.CumulativeDistribution(System.Double)">
            <summary>Computes the cumulative distribution(CDF) of the distribution at x, i.e.P(X ≤ x)</summary>
            <param name="x">the location at which to compute the function</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ExponentialPowerDistribution.InverseCumulativeDistribution(System.Double)">
            <summary>Computes the inverse of the cumulative distribution function</summary>
            <param name="p">the target probablity</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ExponentialPowerDistribution.ProbabilityDensity(System.Double)">
            <summary>Computes the probability density of the distribution(PDF) at x, i.e. ∂P(X ≤ x)/∂x</summary>
            <param name="x">The location at which to compute the density</param>
            <returns>a <c>double</c></returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ExponentialPowerDistribution.MomentGeneratingFunction(System.Double)">
            <summary>Evaluates the moment-generating function for a given t</summary>
            <param name="t">the argument</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ExponentialPowerDistribution.ToString">
            <summary>Returns a string that represents this instance</summary>
            <returns>A string</returns>
        </member>
        <member name="T:Euclid.Distributions.Continuous.FisherDistribution">
            <summary>
            Fisher distribution class
            </summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.FisherDistribution.#ctor(System.Double,System.Double)">
            <summary>Initializes a new instance of the Fisher distribution</summary>
            <param name="d1">the first number of freedom degrees</param>
            <param name="d2">the second number of freedom degrees</param>
        </member>
        <member name="P:Euclid.Distributions.Continuous.FisherDistribution.Entropy">
            <summary>Gets the distribution's entropy</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.FisherDistribution.Mean">
            <summary>Gets the distribution's mean</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.FisherDistribution.Median">
            <summary>Gets the distribution's median</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.FisherDistribution.Mode">
            <summary>Gets the distribution's mode</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.FisherDistribution.Skewness">
            <summary>Gets the distribution's skewness</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.FisherDistribution.StandardDeviation">
            <summary>Gets the distribution's standard deviation</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.FisherDistribution.Support">
            <summary>Gets the distribution's support</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.FisherDistribution.Variance">
            <summary>Gets the distribution's variance</summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.FisherDistribution.Fit(Euclid.Distributions.FittingMethod,System.Double[])">
            <summary>Creates a new instance of the distribution fitted on the data sample</summary>
            <param name="sample">the sample of data to fit</param>
            <param name="method">the fitting method</param>
        </member>
        <member name="M:Euclid.Distributions.Continuous.FisherDistribution.CumulativeDistribution(System.Double)">
            <summary>Computes the cumulative distribution(CDF) of the distribution at x, i.e.P(X ≤ x)</summary>
            <param name="x">the location at which to compute the function</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.FisherDistribution.InverseCumulativeDistribution(System.Double)">
            <summary>Computes the inverse of the cumulative distribution function</summary>
            <param name="p">the target probablity</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.FisherDistribution.ProbabilityDensity(System.Double)">
            <summary>Computes the probability density of the distribution(PDF) at x, i.e. ∂P(X ≤ x)/∂x</summary>
            <param name="x">The location at which to compute the density</param>
            <returns>a <c>double</c></returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.FisherDistribution.MomentGeneratingFunction(System.Double)">
            <summary>Evaluates the moment-generating function for a given t</summary>
            <param name="t">the argument</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.FisherDistribution.ToString">
            <summary>Returns a string that represents this instance</summary>
            <returns>A string</returns>
        </member>
        <member name="T:Euclid.Distributions.Continuous.GammaDistribution">
            <summary>Gamma distribution class</summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.GammaDistribution.#ctor(System.Double,System.Double)">
            <summary>Builds a Gamma distribution</summary>
            <param name="k">the shapee</param>
            <param name="theta">the scale</param>
        </member>
        <member name="P:Euclid.Distributions.Continuous.GammaDistribution.Entropy">
            <summary>Gets the distribution's entropy</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.GammaDistribution.Support">
            <summary>Gets the distribution's support </summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.GammaDistribution.Mean">
            <summary>Gets the distribution's mean </summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.GammaDistribution.Median">
            <summary>Gets the distribution's median </summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.GammaDistribution.Mode">
            <summary>Gets the distribution's mode</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.GammaDistribution.Skewness">
            <summary>Gets the distribution's skewness </summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.GammaDistribution.StandardDeviation">
            <summary>Gets the distribution's standard deviation </summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.GammaDistribution.Variance">
            <summary>Gets the distribution's variance </summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.GammaDistribution.Fit(Euclid.Distributions.FittingMethod,System.Double[])">
            <summary>Creates a new instance of the distribution fitted on the data sample</summary>
            <param name="sample">the sample of data to fit</param>
            <param name="method">the fitting method</param>
        </member>
        <member name="M:Euclid.Distributions.Continuous.GammaDistribution.CumulativeDistribution(System.Double)">
            <summary>Computes the cumulative distribution(CDF) of the distribution at x, i.e.P(X ≤ x)</summary>
            <param name="x">The location at which to compute the cumulative distribution function</param>
            <returns>the cumulative distribution at location x</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.GammaDistribution.InverseCumulativeDistribution(System.Double)">
            <summary>Computes the inverse of the cumulative distribution function(InvCDF) for the distribution at the given probability.This is also known as the quantile or percent point function</summary>
            <param name="p">The location at which to compute the inverse cumulative density</param>
            <returns>the inverse cumulative density at p</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.GammaDistribution.ProbabilityDensity(System.Double)">
            <summary>Computes the probability density of the distribution(PDF) at x, i.e. ∂P(X ≤ x)/∂x</summary>
            <param name="x">The location at which to compute the density</param>
            <returns>a <c>double</c></returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.GammaDistribution.MomentGeneratingFunction(System.Double)">
            <summary>Evaluates the moment-generating function for a given t</summary>
            <param name="t">the argument</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.GammaDistribution.Sample(System.Int32)">
            <summary>Generates a sequence of samples using the Ahrens-Dieter algorithm</summary>
            <param name="numberOfPoints">the sample's size</param>
            <returns>an array of double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.GammaDistribution.ToString">
            <summary>Returns a string that represents this instance</summary>
            <returns>A string</returns>
        </member>
        <member name="T:Euclid.Distributions.Continuous.Kernels.CosineKernel">
            <summary>
            Cosine kernel
            </summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.Kernels.CosineKernel.K(System.Double)">
            <summary>
            the kernel function
            </summary>
            <param name="x"></param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.Kernels.CosineKernel.IntegralK(System.Double)">
            <summary>
            the left hand side integral of the kernel function
            </summary>
            <param name="x"></param>
            <returns>a double</returns>
        </member>
        <member name="P:Euclid.Distributions.Continuous.Kernels.CosineKernel.Variance">
            <summary>Returns the integral of t^2*K(t)</summary>
        </member>
        <member name="T:Euclid.Distributions.Continuous.Kernels.EpanechnikovKernel">
            <summary>
            Epanechnikov kernel
            </summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.Kernels.EpanechnikovKernel.K(System.Double)">
            <summary>
            the kernel function
            </summary>
            <param name="x"></param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.Kernels.EpanechnikovKernel.IntegralK(System.Double)">
            <summary>
            the left hand side integral of the kernel function
            </summary>
            <param name="x"></param>
            <returns>a double</returns>
        </member>
        <member name="P:Euclid.Distributions.Continuous.Kernels.EpanechnikovKernel.Variance">
            <summary>Returns the integral of t^2*K(t)</summary>
        </member>
        <member name="T:Euclid.Distributions.Continuous.Kernels.IDensityKernel">
            <summary>
            Interface for all density kernels
            </summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.Kernels.IDensityKernel.K(System.Double)">
            <summary>
            the kernel function
            </summary>
            <param name="x"></param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.Kernels.IDensityKernel.IntegralK(System.Double)">
            <summary>
            the left hand side integral of the kernel function
            </summary>
            <param name="x"></param>
            <returns>a double</returns>
        </member>
        <member name="P:Euclid.Distributions.Continuous.Kernels.IDensityKernel.Variance">
            <summary>
            Returns the integral of t^2*K(t)
            </summary>
        </member>
        <member name="T:Euclid.Distributions.Continuous.Kernels.TriangularKernel">
            <summary>
            Triangular kernel
            </summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.Kernels.TriangularKernel.K(System.Double)">
            <summary>
            the kernel function
            </summary>
            <param name="x"></param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.Kernels.TriangularKernel.IntegralK(System.Double)">
            <summary>
            the left hand side integral of the kernel function
            </summary>
            <param name="x"></param>
            <returns>a double</returns>
        </member>
        <member name="P:Euclid.Distributions.Continuous.Kernels.TriangularKernel.Variance">
            <summary>Returns the integral of t^2*K(t)</summary>
        </member>
        <member name="T:Euclid.Distributions.Continuous.Kernels.UniformKernel">
            <summary>
            Uniform kernel
            </summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.Kernels.UniformKernel.K(System.Double)">
            <summary>
            the kernel function
            </summary>
            <param name="x"></param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.Kernels.UniformKernel.IntegralK(System.Double)">
            <summary>
            the left hand side integral of the kernel function
            </summary>
            <param name="x"></param>
            <returns>a double</returns>
        </member>
        <member name="P:Euclid.Distributions.Continuous.Kernels.UniformKernel.Variance">
            <summary>
            Returns the integral of t^2*K(t)
            </summary>
        </member>
        <member name="T:Euclid.Distributions.Continuous.LaplaceDistribution">
            <summary>
            Laplace distribution class
            </summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.LaplaceDistribution.#ctor(System.Double,System.Double)">
            <summary>Initializes a new instance of the Laplace distribution</summary>
            <param name="mu">the location</param>
            <param name="b">the scale</param>
        </member>
        <member name="P:Euclid.Distributions.Continuous.LaplaceDistribution.Entropy">
            <summary>Gets the distribution's entropy</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.LaplaceDistribution.Support">
            <summary>Gets the distribution's support</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.LaplaceDistribution.Mean">
            <summary>Gets the distribution's mean</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.LaplaceDistribution.Median">
            <summary>Gets the distribution's median</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.LaplaceDistribution.Mode">
            <summary>Gets the distribution's mode</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.LaplaceDistribution.Skewness">
            <summary>Gets the distribution's skewness</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.LaplaceDistribution.StandardDeviation">
            <summary>Gets the distribution's standard deviation</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.LaplaceDistribution.Variance">
            <summary>Gets the distribution's variance</summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.LaplaceDistribution.Fit(Euclid.Distributions.FittingMethod,System.Double[])">
            <summary>Creates a new instance of the distribution fitted on the data sample</summary>
            <param name="sample">the sample of data to fit</param>
            <param name="method">the fitting method</param>
        </member>
        <member name="M:Euclid.Distributions.Continuous.LaplaceDistribution.CumulativeDistribution(System.Double)">
            <summary>Computes the cumulative distribution(CDF) of the distribution at x, i.e.P(X ≤ x)</summary>
            <param name="x">the location at which to compute the function</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.LaplaceDistribution.InverseCumulativeDistribution(System.Double)">
            <summary>Computes the inverse of the cumulative distribution function</summary>
            <param name="p">the target probablity</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.LaplaceDistribution.ProbabilityDensity(System.Double)">
            <summary>Computes the probability density of the distribution(PDF) at x, i.e. ∂P(X ≤ x)/∂x</summary>
            <param name="x">The location at which to compute the density</param>
            <returns>a <c>double</c></returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.LaplaceDistribution.ProbabilityLnDensity(System.Double)">
            <summary>Computes the probability density function's logarithm at x</summary>
            <param name="x">the location at which to compute the density</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.LaplaceDistribution.MomentGeneratingFunction(System.Double)">
            <summary>Evaluates the moment-generating function for a given t</summary>
            <param name="t">the argument</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.LaplaceDistribution.ToString">
            <summary>Returns a string that represents this instance</summary>
            <returns>A string</returns>
        </member>
        <member name="T:Euclid.Distributions.Continuous.LogisticDistribution">
            <summary>Logistic distribution class</summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.LogisticDistribution.#ctor(System.Double,System.Double)">
            <summary>Builds a Logistic distribution</summary>
            <param name="mu">the location</param>
            <param name="s">the scale</param>
        </member>
        <member name="P:Euclid.Distributions.Continuous.LogisticDistribution.Entropy">
            <summary>Gets the distribution's entropy</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.LogisticDistribution.Mean">
            <summary>Gets the distribution's mean</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.LogisticDistribution.Median">
            <summary>Gets the distribution's median</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.LogisticDistribution.Mode">
            <summary>Gets the distribution's mode</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.LogisticDistribution.Skewness">
            <summary>Gets the distribution's skewness</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.LogisticDistribution.StandardDeviation">
            <summary>Gets the distribution's standard deviation</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.LogisticDistribution.Support">
            <summary>Gets the distribution's support</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.LogisticDistribution.Variance">
            <summary>Gets the distribution's variance</summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.LogisticDistribution.Fit(Euclid.Distributions.FittingMethod,System.Double[])">
            <summary>Creates a new instance of the distribution fitted on the data sample</summary>
            <param name="sample">the sample of data to fit</param>
            <param name="method">the fitting method</param>
        </member>
        <member name="M:Euclid.Distributions.Continuous.LogisticDistribution.CumulativeDistribution(System.Double)">
            <summary>Computes the cumulative distribution(CDF) of the distribution at x, i.e.P(X ≤ x)</summary>
            <param name="x">the location at which to compute the function</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.LogisticDistribution.InverseCumulativeDistribution(System.Double)">
            <summary>Computes the inverse of the cumulative distribution function(InvCDF) for the distribution at the given probability.This is also known as the quantile or percent point function</summary>
            <param name="p">The location at which to compute the inverse cumulative density</param>
            <returns>the inverse cumulative density at p</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.LogisticDistribution.ProbabilityDensity(System.Double)">
            <summary>Computes the probability density of the distribution(PDF) at x, i.e. ∂P(X ≤ x)/∂x</summary>
            <param name="x">The location at which to compute the density</param>
            <returns>a <c>double</c></returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.LogisticDistribution.MomentGeneratingFunction(System.Double)">
            <summary>Evaluates the moment-generating function for a given t</summary>
            <param name="t">the argument</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.LogisticDistribution.ToString">
            <summary>Returns a string that represents this instance</summary>
            <returns>A string</returns>
        </member>
        <member name="T:Euclid.Distributions.Continuous.LogNormalDistribution">
            <summary>
            Log Normal distribution class
            </summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.LogNormalDistribution.#ctor(System.Double,System.Double)">
            <summary>Builds a log normal distribution</summary>
            <param name="mu">the average</param>
            <param name="sigma">the standard deviation</param>
        </member>
        <member name="P:Euclid.Distributions.Continuous.LogNormalDistribution.Entropy">
            <summary>Gets the distribution's entropy</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.LogNormalDistribution.Support">
            <summary>Gets the distribution's support</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.LogNormalDistribution.Mean">
            <summary>Gets the distribution's mean</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.LogNormalDistribution.Median">
            <summary>Gets the distribution's median</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.LogNormalDistribution.Mode">
            <summary>Gets the distribution's mode</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.LogNormalDistribution.Skewness">
            <summary>Gets the distribution's skewness</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.LogNormalDistribution.StandardDeviation">
            <summary>Gets the distribution's standard deviation</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.LogNormalDistribution.Variance">
            <summary>Gets the distributions's variance</summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.LogNormalDistribution.Fit(Euclid.Distributions.FittingMethod,System.Double[])">
            <summary>Creates a new instance of the distribution fitted on the data sample</summary>
            <param name="sample">the sample of data to fit</param>
            <param name="method">the fitting method</param>
        </member>
        <member name="M:Euclid.Distributions.Continuous.LogNormalDistribution.CumulativeDistribution(System.Double)">
            <summary>Computes the cumulative distribution(CDF) of the distribution at x, i.e.P(X ≤ x)</summary>
            <param name="x">The location at which to compute the cumulative distribution function</param>
            <returns>the cumulative distribution at location x</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.LogNormalDistribution.InverseCumulativeDistribution(System.Double)">
            <summary>Computes the inverse of the cumulative distribution function(InvCDF) for the distribution at the given probability.This is also known as the quantile or percent point function</summary>
            <param name="p">The location at which to compute the inverse cumulative density</param>
            <returns>the inverse cumulative density at p</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.LogNormalDistribution.ProbabilityDensity(System.Double)">
            <summary>Computes the probability density of the distribution(PDF) at x, i.e. ∂P(X ≤ x)/∂x</summary>
            <param name="x">The location at which to compute the density</param>
            <returns>a <c>double</c></returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.LogNormalDistribution.Sample(System.Int32)">
            <summary>Generates a sequence of samples from the log normal distribution</summary>
            <param name="numberOfPoints">the sample's size</param>
            <returns>an array of double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.LogNormalDistribution.MomentGeneratingFunction(System.Double)">
            <summary>Evaluates the moment-generating function for a given t</summary>
            <param name="t">the argument</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.LogNormalDistribution.ToString">
            <summary>Returns a string that represents this instance</summary>
            <returns>A string</returns>
        </member>
        <member name="T:Euclid.Distributions.Continuous.ParetoDistribution">
            <summary>Pareto distribution class</summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ParetoDistribution.#ctor(System.Double,System.Double)">
            <summary>
            Builds a Pareto distribution
            </summary>
            <param name="xm">the scale</param>
            <param name="alpha">the shape</param>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ParetoDistribution.Entropy">
            <summary>Gets the distribution's entropy</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ParetoDistribution.Support">
            <summary>Gets the distribution's support</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ParetoDistribution.Mean">
            <summary>Gets the distribution's mean</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ParetoDistribution.Median">
            <summary>Gets the distribution's median</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ParetoDistribution.Mode">
            <summary>Gets the distribution's mode</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ParetoDistribution.Skewness">
            <summary>Gets the distribution's skewness</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ParetoDistribution.StandardDeviation">
            <summary>Gets the distribution's standard deviation</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ParetoDistribution.Variance">
            <summary>Gets the distribution's variance</summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ParetoDistribution.Fit(Euclid.Distributions.FittingMethod,System.Double[])">
            <summary>Fits the distribution to a sample of data</summary>
            <param name="sample">the sample of data to fit</param>
            <param name="method">the fitting method</param>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ParetoDistribution.CumulativeDistribution(System.Double)">
            <summary>Computes the cumulative distribution(CDF) of the distribution at x, i.e.P(X ≤ x)</summary>
            <param name="x">The location at which to compute the cumulative distribution function</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ParetoDistribution.InverseCumulativeDistribution(System.Double)">
            <summary>Computes the inverse of the cumulative distribution function(InvCDF) for the distribution at the given probability.This is also known as the quantile or percent point function</summary>
            <param name="p">The location at which to compute the inverse cumulative density</param>
            <returns>the inverse cumulative density at p</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ParetoDistribution.ProbabilityDensity(System.Double)">
            <summary> Computes the probability density of the distribution(PDF) at x, i.e. ∂P(X ≤ x)/∂x </summary>
            <param name="x">The location at which to compute the density</param>
            <returns>a <c>double</c></returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ParetoDistribution.MomentGeneratingFunction(System.Double)">
            <summary>Evaluates the moment-generating function for a given t</summary>
            <param name="t">the argument</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ParetoDistribution.Sample(System.Int32)">
            <summary> Builds a sample of random variables under this distribution </summary>
            <param name="size">the sample's size</param>
            <returns>an array of double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ParetoDistribution.ToString">
            <summary>Returns a string that represents this instance</summary>
            <returns>A string</returns>
        </member>
        <member name="T:Euclid.Distributions.Continuous.NormalDistribution">
            <summary>Normal distribution class</summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.NormalDistribution.#ctor(System.Double,System.Double,System.Random)">
            <summary>Builds a normal distribution</summary>
            <param name="mean">the distribution's mean</param>
            <param name="standardDeviation">the distributions's standard deviation</param>
            <param name="randomSource">the random source</param>
        </member>
        <member name="M:Euclid.Distributions.Continuous.NormalDistribution.#ctor">
            <summary>Builds a standard normal distribution</summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.NormalDistribution.#ctor(System.Double,System.Double)">
            <summary>Builds a normal distribution</summary>
            <param name="mean">the average</param>
            <param name="standardDeviation">the standard deviation</param>
        </member>
        <member name="M:Euclid.Distributions.Continuous.NormalDistribution.Fit(Euclid.Distributions.FittingMethod,System.Double[])">
            <summary>Creates a new instance of the distribution fitted on the data sample</summary>
            <param name="sample">the sample of data to fit</param>
            <param name="method">the fitting method</param>
        </member>
        <member name="M:Euclid.Distributions.Continuous.NormalDistribution.CumulativeDistribution(System.Double)">
            <summary>Computes the cumulative distribution(CDF) of the distribution at x, i.e.P(X ≤ x)</summary>
            <param name="x">The location at which to compute the cumulative distribution function</param>
            <returns>the cumulative distribution at location x</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.NormalDistribution.ProbabilityDensity(System.Double)">
            <summary>Computes the probability density of the distribution(PDF) at x, i.e. ∂P(X ≤ x)/∂x</summary>
            <param name="x">The location at which to compute the density</param>
            <returns>a <c>double</c></returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.NormalDistribution.InverseCumulativeDistribution(System.Double)">
            <summary>Computes the inverse of the cumulative distribution function(InvCDF) for the distribution at the given probability.This is also known as the quantile or percent point function</summary>
            <param name="p">The location at which to compute the inverse cumulative density</param>
            <returns>the inverse cumulative density at p</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.NormalDistribution.Sample(System.Int32)">
            <summary>Generates a sequence of samples from the normal distribution using the algorithm</summary>
            <param name="numberOfPoints">the sample's size</param>
            <returns>an array of double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.NormalDistribution.MomentGeneratingFunction(System.Double)">
            <summary>Evaluates the moment-generating function for a given t</summary>
            <param name="t">the argument</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.NormalDistribution.ToString">
            <summary>Returns a string that represents this instance</summary>
            <returns>A string</returns>
        </member>
        <member name="P:Euclid.Distributions.Continuous.NormalDistribution.Entropy">
            <summary>Gets the entropy of the normal distribution</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.NormalDistribution.Support">
            <summary>Gets the distribution's support</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.NormalDistribution.Mean">
            <summary>Gets the mean(μ) of the normal distribution</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.NormalDistribution.Median">
            <summary>Gets the median of the normal distribution</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.NormalDistribution.Mode">
            <summary>Gets the mode of the normal distribution</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.NormalDistribution.Skewness">
            <summary>Gets the skewness of the normal distribution</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.NormalDistribution.StandardDeviation">
            <summary>Gets the distribution's standard deviation</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.NormalDistribution.Variance">
            <summary>Gets the distribution's variance</summary>
        </member>
        <member name="T:Euclid.Distributions.Continuous.ExponentialDistribution">
            <summary>Exponential distribution class</summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ExponentialDistribution.#ctor(System.Double)">
            <summary>
            Builds a Exponential distribution
            </summary>
            <param name="lambda">the rate</param>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ExponentialDistribution.Fit(Euclid.Distributions.FittingMethod,System.Double[])">
            <summary>Creates a new instance of the distribution fitted on the data sample</summary>
            <param name="sample">the sample of data to fit</param>
            <param name="method">the fitting method</param>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ExponentialDistribution.CumulativeDistribution(System.Double)">
            <summary>Computes the cumulative distribution(CDF) of the distribution at x, i.e.P(X ≤ x)</summary>
            <param name="x">The location at which to compute the cumulative distribution function</param>
            <returns>the cumulative distribution at location x</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ExponentialDistribution.InverseCumulativeDistribution(System.Double)">
            <summary>Computes the inverse of the cumulative distribution function(InvCDF) for the distribution at the given probability.This is also known as the quantile or percent point function</summary>
            <param name="p">The location at which to compute the inverse cumulative density</param>
            <returns>the inverse cumulative density at p</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ExponentialDistribution.ProbabilityDensity(System.Double)">
            <summary>Computes the probability density of the distribution(PDF) at x, i.e. ∂P(X ≤ x)/∂x</summary>
            <param name="x">The location at which to compute the density</param>
            <returns>a <c>double</c></returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ExponentialDistribution.MomentGeneratingFunction(System.Double)">
            <summary>Evaluates the moment-generating function for a given t</summary>
            <param name="t">the argument</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ExponentialDistribution.Sample(System.Int32)">
            <summary> Generates a sequence of samples from the normal distribution using the algorithm</summary>
            <param name="numberOfPoints">the sample's size</param>
            <returns>an array of double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ExponentialDistribution.ToString">
            <summary>Returns a string that represents this instance</summary>
            <returns>A string</returns>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ExponentialDistribution.Support">
            <summary>Gets the distribution's support</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ExponentialDistribution.Entropy">
            <summary>Gets the distribution's entropy </summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ExponentialDistribution.Mean">
            <summary>Gets the distribution's mean</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ExponentialDistribution.Median">
            <summary>Gets the distribution's median</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ExponentialDistribution.Mode">
            <summary>Gets the distribution's mode </summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ExponentialDistribution.Skewness">
            <summary> Gets the distribution's mode</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ExponentialDistribution.Variance">
            <summary>Gets the distribution's variance</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ExponentialDistribution.StandardDeviation">
            <summary>Gets the distribution's standard deviation</summary>
        </member>
        <member name="T:Euclid.Distributions.Continuous.ContinuousDistribution">
            <summary>Abstract class base for continuous distributions</summary>
        </member>
        <member name="F:Euclid.Distributions.Continuous.ContinuousDistribution._randomSource">
            <summary>The random number generator</summary>
        </member>
        <member name="F:Euclid.Distributions.Continuous.ContinuousDistribution._support">
            <summary>The distribution's support </summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ContinuousDistribution.Entropy">
            <summary>Gets the distribution's entropy</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ContinuousDistribution.Support">
            <summary>Gets the distribution's support</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ContinuousDistribution.Mean">
            <summary>Gets the distribution's mean</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ContinuousDistribution.Median">
            <summary>Gets the distribution's median</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ContinuousDistribution.Mode">
            <summary>Gets the distribution's mode</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ContinuousDistribution.Skewness">
            <summary>Gets the distribution's skewness</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ContinuousDistribution.StandardDeviation">
            <summary>Gets the distribution's standard deviation</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ContinuousDistribution.Variance">
            <summary>Gets the distribution's variance</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.ContinuousDistribution.RandomSource">
            <summary>
            Gets or sets the random number generator which is used to draw random samples
            </summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ContinuousDistribution.CumulativeDistribution(System.Double)">
            <summary>Computes the cumulative distribution(CDF) of the distribution at x, i.e.P(X ≤ x)</summary>
            <param name="x">the location at which to compute the function</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ContinuousDistribution.CumulativeDistributionBetween(System.Double,System.Double)">
            <summary>Computes the cumulative distribution(CDF) of the distribution between x and y, i.e. P(x ≤ X ≤ y) </summary>
            <param name="x">the lower bound of the interval</param>
            <param name="y">the upper bound of the interval</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ContinuousDistribution.InverseCumulativeDistribution(System.Double)">
            <summary>Computes the inverse of the cumulative distribution function</summary>
            <param name="p">the target probablity</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ContinuousDistribution.ProbabilityDensity(System.Double)">
            <summary>Computes the probability density of the distribution(PDF) at x, i.e. ∂P(X ≤ x)/∂x</summary>
            <param name="x">The location at which to compute the density</param>
            <returns>a <c>double</c></returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ContinuousDistribution.ProbabilityLnDensity(System.Double)">
            <summary>Computes the probability density function's logarithm at x</summary>
            <param name="x">the location at which to compute the density</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ContinuousDistribution.Sample(System.Int32)">
            <summary>Generates a sequence of samples from the normal distribution using th algorithm</summary>
            <param name="size">the sample's size</param>
            <returns>an array of double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.ContinuousDistribution.MomentGeneratingFunction(System.Double)">
            <summary>Evaluates the moment-generating function for a given t</summary>
            <param name="t">the argument</param>
            <returns>a double</returns>
        </member>
        <member name="T:Euclid.Distributions.Continuous.BoundedNormalDistribution">
            <summary>
            Bounded normal distribution class
            </summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.BoundedNormalDistribution.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Builds a truncated normal distribution
            </summary>
            <param name="mu">the location</param>
            <param name="sigma">the scale</param>
            <param name="a">the interval's lower bound</param>
            <param name="b">the interval's upper bound</param>
        </member>
        <member name="P:Euclid.Distributions.Continuous.BoundedNormalDistribution.Entropy">
            <summary>Gets the distribution's entropy</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.BoundedNormalDistribution.Support">
            <summary>Gets the distribution's support</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.BoundedNormalDistribution.Mean">
            <summary>Gets the distribution's mean</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.BoundedNormalDistribution.Median">
            <summary>Gets the distribution's median</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.BoundedNormalDistribution.Mode">
            <summary>Gets the distribution's mode</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.BoundedNormalDistribution.Skewness">
            <summary>
            Gets the distribution's skewness
            </summary>
            <remarks>using Shah and Jaiswal (1966)</remarks>
        </member>
        <member name="P:Euclid.Distributions.Continuous.BoundedNormalDistribution.StandardDeviation">
            <summary>Gets the distribution's standard deviation</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.BoundedNormalDistribution.Variance">
            <summary>Gets the distribution's variance</summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.BoundedNormalDistribution.Fit(Euclid.Distributions.FittingMethod,System.Double[])">
            <summary>Creates a new instance of the distribution fitted on the data sample</summary>
            <param name="sample">the sample of data to fit</param>
            <param name="method">the fitting method</param>
        </member>
        <member name="M:Euclid.Distributions.Continuous.BoundedNormalDistribution.CumulativeDistribution(System.Double)">
            <summary>Computes the cumulative distribution function at x</summary>
            <param name="x">the location at which to compute the function</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.BoundedNormalDistribution.InverseCumulativeDistribution(System.Double)">
            <summary>Computes the inverse of the cumulative distribution function</summary>
            <param name="p">the target probablity</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.BoundedNormalDistribution.ProbabilityDensity(System.Double)">
            <summary>Computes the probability density of the distribution(PDF) at x, i.e. ∂P(X ≤ x)/∂x</summary>
            <param name="x">The location at which to compute the density</param>
            <returns>a <c>double</c></returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.BoundedNormalDistribution.MomentGeneratingFunction(System.Double)">
            <summary>Evaluates the moment-generating function for a given t</summary>
            <param name="t">the argument</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.BoundedNormalDistribution.ToString">
            <summary>Returns a string that represents this instance</summary>
            <returns>A string</returns>
        </member>
        <member name="T:Euclid.Distributions.Continuous.UniformDistribution">
            <summary>Uniform distribution class</summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.UniformDistribution.#ctor(System.Double,System.Double)">
            <summary>Builds a Uniform distribution</summary>
            <param name="a">the support's lower bound</param>
            <param name="b">the support's upper bound</param>
        </member>
        <member name="M:Euclid.Distributions.Continuous.UniformDistribution.#ctor">
            <summary>Builds a standard Uniform distribution </summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.UniformDistribution.Entropy">
            <summary>Gets the distribution's entropy</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.UniformDistribution.Mean">
            <summary>Gets the distribution's mean</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.UniformDistribution.Median">
            <summary>Gets the distribution's median</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.UniformDistribution.Mode">
            <summary>Gets the distribution's mode</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.UniformDistribution.Skewness">
            <summary>Gets the distribution's skewness</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.UniformDistribution.StandardDeviation">
            <summary>Gets the distribution's standard deviation</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.UniformDistribution.Support">
            <summary>Gets the distribution's support</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.UniformDistribution.Variance">
            <summary>Gets the distribution's variance</summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.UniformDistribution.Fit(Euclid.Distributions.FittingMethod,System.Double[])">
            <summary>Creates a new instance of the distribution fitted on the data sample</summary>
            <param name="sample">the sample of data to fit</param>
            <param name="method">the fitting method</param>
        </member>
        <member name="M:Euclid.Distributions.Continuous.UniformDistribution.CumulativeDistribution(System.Double)">
            <summary>
            Computes the cumulative distribution(CDF) of the distribution at x, i.e.P(X ≤ x)
            </summary>
            <param name="x">The location at which to compute the cumulative distribution function</param>
            <returns>the cumulative distribution at location x</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.UniformDistribution.InverseCumulativeDistribution(System.Double)">
            <summary>Computes the inverse of the cumulative distribution function(InvCDF) for the distribution at the given probability.This is also known as the quantile or percent point function</summary>
            <param name="p">The location at which to compute the inverse cumulative density</param>
            <returns>the inverse cumulative density at p</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.UniformDistribution.ProbabilityDensity(System.Double)">
            <summary>Computes the probability density of the distribution(PDF) at x, i.e. ∂P(X ≤ x)/∂x</summary>
            <param name="x">The location at which to compute the density</param>
            <returns>a <c>double</c></returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.UniformDistribution.MomentGeneratingFunction(System.Double)">
            <summary>Evaluates the moment-generating function for a given t</summary>
            <param name="t">the argument</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.UniformDistribution.Sample(System.Int32)">
            <summary>Generates a sequence of samples from the normal distribution using the algorithm</summary>
            <param name="numberOfPoints">the sample's size</param>
            <returns>an array of double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.UniformDistribution.ToString">
            <summary>Returns a string that represents this instance</summary>
            <returns>A string</returns>
        </member>
        <member name="T:Euclid.Distributions.Continuous.WeibullDistribution">
            <summary>
            Weibull distribution class
            </summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.WeibullDistribution.#ctor(System.Double,System.Double)">
            <summary>
            Builds a Weibull distribution
            </summary>
            <param name="lambda">the scale</param>
            <param name="k">the shape</param>
        </member>
        <member name="P:Euclid.Distributions.Continuous.WeibullDistribution.Entropy">
            <summary>Gets the distribution's entropy</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.WeibullDistribution.Mean">
            <summary>Gets the distribution's mean</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.WeibullDistribution.Median">
            <summary>Gets the distribution's median</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.WeibullDistribution.Mode">
            <summary>Gets the distribution's mode</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.WeibullDistribution.Skewness">
            <summary>Gets the distribution's skewness</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.WeibullDistribution.StandardDeviation">
            <summary>Gets the distribution's standard deviation</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.WeibullDistribution.Support">
            <summary>Gets the distribution's support</summary>
        </member>
        <member name="P:Euclid.Distributions.Continuous.WeibullDistribution.Variance">
            <summary>Gets the distribution's variance</summary>
        </member>
        <member name="M:Euclid.Distributions.Continuous.WeibullDistribution.Fit(Euclid.Distributions.FittingMethod,System.Double[])">
            <summary>Creates a new instance of the distribution fitted on the data sample</summary>
            <param name="sample">the sample of data to fit</param>
            <param name="method">the fitting method</param>
        </member>
        <member name="M:Euclid.Distributions.Continuous.WeibullDistribution.CumulativeDistribution(System.Double)">
            <summary>Computes the cumulative distribution(CDF) of the distribution at x, i.e.P(X ≤ x)</summary>
            <param name="x">The location at which to compute the cumulative distribution function</param>
            <returns>the cumulative distribution at location x</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.WeibullDistribution.InverseCumulativeDistribution(System.Double)">
            <summary>Computes the inverse of the cumulative distribution function(InvCDF) for the distribution at the given probability.This is also known as the quantile or percent point function</summary>
            <param name="p">The location at which to compute the inverse cumulative density</param>
            <returns>the inverse cumulative density at p</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.WeibullDistribution.ProbabilityDensity(System.Double)">
            <summary>Computes the probability density of the distribution(PDF) at x, i.e. ∂P(X ≤ x)/∂x</summary>
            <param name="x">The location at which to compute the density</param>
            <returns>a <c>double</c></returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.WeibullDistribution.MomentGeneratingFunction(System.Double)">
            <summary>Evaluates the moment-generating function for a given t</summary>
            <param name="t">the argument</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Continuous.WeibullDistribution.ToString">
            <summary>Returns a string that represents this instance</summary>
            <returns>A string</returns>
        </member>
        <member name="T:Euclid.Distributions.Discrete.BinomialDistribution">
            <summary> Binonmial distribution class</summary>
        </member>
        <member name="M:Euclid.Distributions.Discrete.BinomialDistribution.#ctor(System.Int32,System.Double)">
            <summary>Initializes a new instance of the binomial distribution</summary>
            <param name="n">the number of runs</param>
            <param name="p">the unitary probability</param>
        </member>
        <member name="P:Euclid.Distributions.Discrete.BinomialDistribution.Entropy">
            <summary>Gets the distribution's entropy</summary>
        </member>
        <member name="P:Euclid.Distributions.Discrete.BinomialDistribution.Mean">
            <summary>Gets the distribution's mean</summary>
        </member>
        <member name="P:Euclid.Distributions.Discrete.BinomialDistribution.Median">
            <summary>Gets the distribution's median</summary>
        </member>
        <member name="P:Euclid.Distributions.Discrete.BinomialDistribution.Mode">
            <summary>Gets the distribution's mode</summary>
        </member>
        <member name="P:Euclid.Distributions.Discrete.BinomialDistribution.Skewness">
            <summary>Gets the distribution's skewness</summary>
        </member>
        <member name="P:Euclid.Distributions.Discrete.BinomialDistribution.StandardDeviation">
            <summary>Gets the distribution's standard deviation</summary>
        </member>
        <member name="P:Euclid.Distributions.Discrete.BinomialDistribution.Variance">
            <summary>Gets the distribution's variance</summary>
        </member>
        <member name="P:Euclid.Distributions.Discrete.BinomialDistribution.Support">
            <summary>Gets the distribution's support</summary>
        </member>
        <member name="M:Euclid.Distributions.Discrete.BinomialDistribution.CumulativeDistribution(System.Double)">
            <summary>Computes the cumulative distribution(CDF) of the distribution at x, i.e.P(X ≤ x).</summary>
            <param name="x">The location at which to compute the cumulative distribution function</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Discrete.BinomialDistribution.InverseCumulativeDistribution(System.Double)">
            <summary>Computes the inverse of the cumulative distribution function(InvCDF) for the distribution at the given probability.This is also known as the quantile or percent point function</summary>
            <param name="p">The location at which to compute the inverse cumulative density</param>
            <returns>the inverse cumulative density at p</returns>
        </member>
        <member name="M:Euclid.Distributions.Discrete.BinomialDistribution.ProbabilityDensity(System.Double)">
            <summary>Computes the probability density of the distribution(PDF) at x, i.e. ∂P(X ≤ x)/∂x</summary>
            <param name="x">The location at which to compute the density</param>
            <returns>a <c>double</c></returns>
        </member>
        <member name="M:Euclid.Distributions.Discrete.BinomialDistribution.MomentGeneratingFunction(System.Double)">
            <summary>Evaluates the moment-generating function for a given t</summary>
            <param name="t">the argument</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Discrete.BinomialDistribution.Sample(System.Int32)">
            <summary>Generates a sequence of samples from the distribution</summary>
            <param name="size">the sample's size</param>
            <returns>an array of double</returns>
        </member>
        <member name="M:Euclid.Distributions.Discrete.BinomialDistribution.Fit(Euclid.Distributions.FittingMethod,System.Double[])">
            <summary>Fits the distribution to a sample of data</summary>
            <param name="sample">the sample of data to fit</param>
            <param name="method">the fitting method</param>
        </member>
        <member name="M:Euclid.Distributions.Discrete.BinomialDistribution.ToString">
            <summary>Returns a string that represents this instance</summary>
            <returns>A string</returns>
        </member>
        <member name="T:Euclid.Distributions.Discrete.DiscreteDistribution">
            <summary>Abstract class base for continuous distributions</summary>
        </member>
        <member name="F:Euclid.Distributions.Discrete.DiscreteDistribution._randomSource">
            <summary>The random number generator</summary>
        </member>
        <member name="F:Euclid.Distributions.Discrete.DiscreteDistribution._support">
            <summary>The distribution's support </summary>
        </member>
        <member name="P:Euclid.Distributions.Discrete.DiscreteDistribution.Entropy">
            <summary>Gets the distribution's entropy</summary>
        </member>
        <member name="P:Euclid.Distributions.Discrete.DiscreteDistribution.Support">
            <summary>Gets the distribution's support</summary>
        </member>
        <member name="P:Euclid.Distributions.Discrete.DiscreteDistribution.Mean">
            <summary>Gets the distribution's mean</summary>
        </member>
        <member name="P:Euclid.Distributions.Discrete.DiscreteDistribution.Median">
            <summary>Gets the distribution's median</summary>
        </member>
        <member name="P:Euclid.Distributions.Discrete.DiscreteDistribution.Mode">
            <summary>Gets the distribution's mode</summary>
        </member>
        <member name="P:Euclid.Distributions.Discrete.DiscreteDistribution.Skewness">
            <summary>Gets the distribution's skewness</summary>
        </member>
        <member name="P:Euclid.Distributions.Discrete.DiscreteDistribution.StandardDeviation">
            <summary>Gets the distribution's standard deviation</summary>
        </member>
        <member name="P:Euclid.Distributions.Discrete.DiscreteDistribution.Variance">
            <summary>Gets the distribution's variance</summary>
        </member>
        <member name="P:Euclid.Distributions.Discrete.DiscreteDistribution.RandomSource">
            <summary>
            Gets or sets the random number generator which is used to draw random samples
            </summary>
        </member>
        <member name="M:Euclid.Distributions.Discrete.DiscreteDistribution.CumulativeDistribution(System.Double)">
            <summary>Computes the cumulative distribution(CDF) of the distribution at x, i.e.P(X ≤ x)</summary>
            <param name="x">the location at which to compute the function</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Discrete.DiscreteDistribution.CumulativeDistributionBetween(System.Double,System.Double)">
            <summary>Computes the cumulative distribution(CDF) of the distribution between x and y, i.e. P(x ≤ X ≤ y) </summary>
            <param name="x">the lower bound of the interval</param>
            <param name="y">the upper bound of the interval</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Discrete.DiscreteDistribution.InverseCumulativeDistribution(System.Double)">
            <summary>Computes the inverse of the cumulative distribution function</summary>
            <param name="p">the target probablity</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Discrete.DiscreteDistribution.ProbabilityDensity(System.Double)">
            <summary>Computes the probability density of the distribution(PDF) at x, i.e. ∂P(X ≤ x)/∂x</summary>
            <param name="x">The location at which to compute the density</param>
            <returns>a <c>double</c></returns>
        </member>
        <member name="M:Euclid.Distributions.Discrete.DiscreteDistribution.ProbabilityLnDensity(System.Double)">
            <summary>Computes the probability density function's logarithm at x</summary>
            <param name="x">the location at which to compute the density</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Discrete.DiscreteDistribution.Sample(System.Int32)">
            <summary>Generates a sequence of samples from the distribution using the algorithm</summary>
            <param name="size">the sample's size</param>
            <returns>an array of double</returns>
        </member>
        <member name="M:Euclid.Distributions.Discrete.DiscreteDistribution.MomentGeneratingFunction(System.Double)">
            <summary>Evaluates the moment-generating function for a given t</summary>
            <param name="t">the argument</param>
            <returns>a double</returns>
        </member>
        <member name="T:Euclid.Distributions.Discrete.PoissonDistribution">
            <summary>Poisson distribution</summary>
        </member>
        <member name="M:Euclid.Distributions.Discrete.PoissonDistribution.#ctor(System.Double)">
            <summary>Initializes a new instance of the Poisson distribution</summary>
            <param name="lambda">the rate</param>
        </member>
        <member name="P:Euclid.Distributions.Discrete.PoissonDistribution.Entropy">
            <summary>Gets the distribution's entropy</summary>
        </member>
        <member name="P:Euclid.Distributions.Discrete.PoissonDistribution.Mean">
            <summary>Gets the distribution's mean</summary>
        </member>
        <member name="P:Euclid.Distributions.Discrete.PoissonDistribution.Median">
            <summary>Gets the distribution's median</summary>
        </member>
        <member name="P:Euclid.Distributions.Discrete.PoissonDistribution.Mode">
            <summary>Gets the distribution's mode</summary>
        </member>
        <member name="P:Euclid.Distributions.Discrete.PoissonDistribution.Skewness">
            <summary>Gets the distribution's skewness</summary>
        </member>
        <member name="P:Euclid.Distributions.Discrete.PoissonDistribution.StandardDeviation">
            <summary>Gets the distribution's standard deviation</summary>
        </member>
        <member name="P:Euclid.Distributions.Discrete.PoissonDistribution.Variance">
            <summary>Gets the distribution's variance</summary>
        </member>
        <member name="P:Euclid.Distributions.Discrete.PoissonDistribution.Support">
            <summary>Gets the distribution's support</summary>
        </member>
        <member name="M:Euclid.Distributions.Discrete.PoissonDistribution.CumulativeDistribution(System.Double)">
            <summary>Computes the cumulative distribution(CDF) of the distribution at x, i.e.P(X ≤ x).</summary>
            <param name="x">The location at which to compute the cumulative distribution function</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Discrete.PoissonDistribution.InverseCumulativeDistribution(System.Double)">
            <summary>Computes the inverse of the cumulative distribution function(InvCDF) for the distribution at the given probability.This is also known as the quantile or percent point function</summary>
            <param name="p">The location at which to compute the inverse cumulative density</param>
            <returns>the inverse cumulative density at p</returns>
        </member>
        <member name="M:Euclid.Distributions.Discrete.PoissonDistribution.ProbabilityDensity(System.Double)">
            <summary>Computes the probability density of the distribution(PDF) at x, i.e. ∂P(X ≤ x)/∂x</summary>
            <param name="x">The location at which to compute the density</param>
            <returns>a <c>double</c></returns>
        </member>
        <member name="M:Euclid.Distributions.Discrete.PoissonDistribution.Probability(System.Double,System.Int32)">
            <summary>Computes the probability density of the distribution</summary>
            <param name="x">the rate</param>
            <param name="k">the value</param>
            <returns>a <c>double</c></returns>
        </member>
        <member name="M:Euclid.Distributions.Discrete.PoissonDistribution.LogProbability(System.Double,System.Int32)">
            <summary>Computes the log-probability density of the distribution</summary>
            <param name="x">the rate</param>
            <param name="k">the value</param>
            <returns>a <c>double</c></returns>
        </member>
        <member name="M:Euclid.Distributions.Discrete.PoissonDistribution.LogProbabilityDerivative(System.Double,System.Int32)">
            <summary>Computes the derivative of the log-probability according to the rate</summary>
            <param name="x">the rate</param>
            <param name="k">the value</param>
            <returns>a <c>double</c></returns>
        </member>
        <member name="M:Euclid.Distributions.Discrete.PoissonDistribution.MomentGeneratingFunction(System.Double)">
            <summary>Evaluates the moment-generating function for a given t</summary>
            <param name="t">the argument</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Discrete.PoissonDistribution.Sample(System.Int32)">
            <summary>Generates a sequence of samples from the distribution</summary>
            <param name="size">the sample's size</param>
            <returns>an array of double</returns>
        </member>
        <member name="M:Euclid.Distributions.Discrete.PoissonDistribution.Fit(Euclid.Distributions.FittingMethod,System.Double[])">
            <summary>Creates a new instance of the distribution fitted on the data sample</summary>
            <param name="sample">the sample of data to fit</param>
            <param name="method">the fitting method</param>
        </member>
        <member name="M:Euclid.Distributions.Discrete.PoissonDistribution.ToString">
            <summary>Returns a string that represents this instance</summary>
            <returns>A string</returns>
        </member>
        <member name="T:Euclid.Distributions.Discrete.SkellamDistribution">
            <summary>Skellam distribution</summary>
        </member>
        <member name="M:Euclid.Distributions.Discrete.SkellamDistribution.#ctor(System.Double,System.Double)">
            <summary>Initializes a new instance of the Skellam distribution</summary>
            <param name="mu1">the rate of the first Poisson</param>
            <param name="mu2">the rate of the second Poisson</param>
            <remarks>Allows to compute the probabilities of a Poisson race</remarks>
        </member>
        <member name="P:Euclid.Distributions.Discrete.SkellamDistribution.Mean">
            <summary>Gets the distribution's mean</summary>
        </member>
        <member name="P:Euclid.Distributions.Discrete.SkellamDistribution.Skewness">
            <summary>Gets the distribution's skewness</summary>
        </member>
        <member name="P:Euclid.Distributions.Discrete.SkellamDistribution.StandardDeviation">
            <summary>Gets the distribution's standard deviation</summary>
        </member>
        <member name="P:Euclid.Distributions.Discrete.SkellamDistribution.Variance">
            <summary>Gets the distribution's variance</summary>
        </member>
        <member name="P:Euclid.Distributions.Discrete.SkellamDistribution.Support">
            <summary>Gets the distribution's support</summary>
        </member>
        <member name="P:Euclid.Distributions.Discrete.SkellamDistribution.Mode">
            <summary>Gets the distribution's mode</summary>
        </member>
        <member name="P:Euclid.Distributions.Discrete.SkellamDistribution.Entropy">
            <summary>Gets the distribution's entropy</summary>
        </member>
        <member name="P:Euclid.Distributions.Discrete.SkellamDistribution.Median">
            <summary>Gets the distribution's median</summary>
        </member>
        <member name="M:Euclid.Distributions.Discrete.SkellamDistribution.InverseCumulativeDistribution(System.Double)">
            <summary>Computes the inverse of the cumulative distribution function(InvCDF) for the distribution at the given probability.This is also known as the quantile or percent point function</summary>
            <param name="p">The location at which to compute the inverse cumulative density</param>
            <returns>the inverse cumulative density at p</returns>
        </member>
        <member name="M:Euclid.Distributions.Discrete.SkellamDistribution.ProbabilityDensity(System.Double)">
            <summary>Computes the probability density of the distribution(PDF) at x, i.e. ∂P(X ≤ x)/∂x</summary>
            <param name="x">The location at which to compute the density</param>
            <returns>a <c>double</c></returns>
        </member>
        <member name="M:Euclid.Distributions.Discrete.SkellamDistribution.Fit(Euclid.Distributions.FittingMethod,System.Double[])">
            <summary>Creates a new instance of the distribution fitted on the data sample</summary>
            <param name="sample">the sample of data to fit</param>
            <param name="method">the fitting method</param>
        </member>
        <member name="M:Euclid.Distributions.Discrete.SkellamDistribution.MomentGeneratingFunction(System.Double)">
            <summary>Evaluates the moment-generating function for a given t</summary>
            <param name="t">the argument</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Discrete.SkellamDistribution.Sample(System.Int32)">
            <summary>Generates a sequence of samples from the distribution</summary>
            <param name="size">the sample's size</param>
            <returns>an array of double</returns>
        </member>
        <member name="M:Euclid.Distributions.Discrete.SkellamDistribution.CumulativeDistribution(System.Double)">
            <summary>Computes the cumulative distribution(CDF) of the distribution at x, i.e.P(X ≤ x).</summary>
            <param name="x">The location at which to compute the cumulative distribution function</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.Discrete.SkellamDistribution.ToString">
            <summary>Returns a string that represents this instance</summary>
            <returns>A string</returns>
        </member>
        <member name="T:Euclid.Distributions.FittingMethod">
            <summary>Defines the method used to fit data to a distribution</summary>
        </member>
        <member name="F:Euclid.Distributions.FittingMethod.Moments">
            <summary>Fits the parameters to the moments</summary>
        </member>
        <member name="F:Euclid.Distributions.FittingMethod.MaximumLikelihood">
            <summary>Fits the parameters by using the maximum likehood</summary>
        </member>
        <member name="T:Euclid.Distributions.IDistribution">
            <summary>Interface for all continuous distributions</summary>
        </member>
        <member name="M:Euclid.Distributions.IDistribution.CumulativeDistribution(System.Double)">
            <summary>Evaluates the cumulative distribution function (left hand side)</summary>
            <param name="x">the argument</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.IDistribution.InverseCumulativeDistribution(System.Double)">
            <summary>Evaluates the cumulative distribution's antecedant for a given probability</summary>
            <param name="p">the probability</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.IDistribution.ProbabilityDensity(System.Double)">
            <summary>Evaluates the probability density function</summary>
            <param name="x">the argument</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.IDistribution.MomentGeneratingFunction(System.Double)">
            <summary>Evaluates the moment-generating function for a given t</summary>
            <param name="t">the argument</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Distributions.IDistribution.ProbabilityLnDensity(System.Double)">
            <summary>Evaluates the log of the probability density function</summary>
            <param name="x">the argument</param>
            <returns>a double</returns>
        </member>
        <member name="P:Euclid.Distributions.IDistribution.Entropy">
            <summary>Returns the distribution's entropy</summary>
        </member>
        <member name="P:Euclid.Distributions.IDistribution.Mean">
            <summary>Returns the distribution's mean</summary>
        </member>
        <member name="P:Euclid.Distributions.IDistribution.Median">
            <summary>Returns the distribution's median </summary>
        </member>
        <member name="P:Euclid.Distributions.IDistribution.Mode">
            <summary>Returns the distribution's mode</summary>
        </member>
        <member name="P:Euclid.Distributions.IDistribution.Skewness">
            <summary>Returns the distribution's skewness</summary>
        </member>
        <member name="P:Euclid.Distributions.IDistribution.StandardDeviation">
            <summary>Returns the distribution's standard deviation</summary>
        </member>
        <member name="P:Euclid.Distributions.IDistribution.Variance">
            <summary>Returns the distribution's variance</summary>
        </member>
        <member name="T:Euclid.Extensions.Arrays">
            <summary>Helper class for generic array manipulations</summary>
        </member>
        <member name="M:Euclid.Extensions.Arrays.Build``1(System.Int32,System.Int32)">
            <summary>
            Build a two dimensional jagged array
            </summary>
            <typeparam name="T">Type of the jagged array</typeparam>
            <param name="rows">Nb rows</param>
            <param name="columns">Nb Columns</param>
            <returns>Initialized two dimensional jagged array</returns>
        </member>
        <member name="M:Euclid.Extensions.Arrays.Build``1(System.Int32,System.Int32,``0)">
            <summary>
            Build a two dimensional jagged array
            </summary>
            <typeparam name="T">Type of the jagged array</typeparam>
            <param name="rows">Nb rows</param>
            <param name="columns">Nb Columns</param>
            <param name="defaultValue">Default value for initilization</param>
            <returns>Initialized two dimensional jagged array</returns>
        </member>
        <member name="M:Euclid.Extensions.Arrays.Clone``1(``0[][])">
            <summary>Clones a 2D jagged array</summary>
            <typeparam name="T">template type</typeparam>
            <param name="data">the 2d array of data</param>
            <returns>a shallow copy of data</returns>
        </member>
        <member name="M:Euclid.Extensions.Arrays.FastClone``1(``0[][])">
            <summary>Fast Clone a 2D jagged array</summary>
            <typeparam name="T">template type</typeparam>
            <param name="data">the 2d array of data</param>
            <returns>a shallow copy of data</returns>
        </member>
        <member name="M:Euclid.Extensions.Arrays.Clone``1(``0[])">
            <summary>clones a generic array</summary>
            <typeparam name="T">template type</typeparam>
            <param name="data">the array of data</param>
            <returns>a shallow copy of data</returns>
        </member>
        <member name="M:Euclid.Extensions.Arrays.Clone``1(``0[0:,0:])">
            <summary>Clones a generic 2D array</summary>
            <typeparam name="T">template type</typeparam>
            <param name="data">the 2d array of data</param>
            <returns>a shallow copy of data</returns>
        </member>
        <member name="M:Euclid.Extensions.Arrays.Clone``1(``0[0:,0:,0:])">
            <summary>Clones a generic 3D array</summary>
            <typeparam name="T">template type</typeparam>
            <param name="data">the 2d array of data</param>
            <returns>a shallow copy of data</returns>
        </member>
        <member name="M:Euclid.Extensions.Arrays.SubArray``1(``0[],System.Int32,System.Int32)">
            <summary>Extract a sub array of data</summary>
            <typeparam name="T"> template type</typeparam>
            <param name="data">the array from which the data will be extracted</param>
            <param name="index">the starting index</param>
            <param name="length">the number of values to copy</param>
            <returns>the extracted array</returns>
        </member>
        <member name="M:Euclid.Extensions.Arrays.Apply``1(``0[],System.Func{``0,``0})">
            <summary>Applies a function to all the values in an arrzy</summary>
            <typeparam name="T">template type</typeparam>
            <param name="data">the array to transform</param>
            <param name="function">the function to apply to the values</param>
            <returns>an array with the transformed data</returns>
        </member>
        <member name="M:Euclid.Extensions.Arrays.IndexOfNearest(System.Double[],System.Double)">
            <summary>Returns the index of the nearest value in the array</summary>
            <param name="data">the array to search</param>
            <param name="value">the sought value</param>
            <returns>the index in the array</returns>
        </member>
        <member name="M:Euclid.Extensions.Arrays.Split``1(``0[],System.Int32)">
            <summary>Splits an array into smaller size arrays</summary>
            <typeparam name="T">the generic type</typeparam>
            <param name="data">the array to split</param>
            <param name="size">the target size for the smaller arrays</param>
            <returns>a List of arrays</returns>
        </member>
        <member name="M:Euclid.Extensions.Arrays.FindIndices``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>Find indices according to a predicate</summary>
            <typeparam name="T">the item type</typeparam>
            <param name="items">the candidates</param>
            <param name="predicate">the predicate</param>
            <returns>the matching indices</returns>
        </member>
        <member name="M:Euclid.Extensions.Arrays.IsSorted``1(``0[])">
            <summary>Checks if an array is sorted</summary>
            <typeparam name="T">the template type</typeparam>
            <param name="data">the input array</param>
            <returns><c>true</c> is the array is sorted, <c>false</c> otherwise</returns>
        </member>
        <member name="T:Euclid.Extensions.Loops">
            <summary>Handles the loops</summary>
        </member>
        <member name="M:Euclid.Extensions.Loops.For(System.Int32,System.Int32,System.Boolean,System.Action{System.Int32})">
            <summary>Executes a loop which can be made sequential or parallel on demand</summary>
            <param name="fromInclusive">the start index, included</param>
            <param name="toExclusive">the end index, excluded</param>
            <param name="body">the action executed on every loop</param>
            <param name="isParallel">determines whether the loop is sequential or parallel</param>
        </member>
        <member name="T:Euclid.Extensions.Parser">
            <summary>Parser helper class
            </summary>
        </member>
        <member name="M:Euclid.Extensions.Parser.Parse``1(System.String)">
            <summary>Parses any data generic type when possible</summary>
            <typeparam name="T">the generic type</typeparam>
            <param name="text"></param>
            <returns>a T</returns>
        </member>
        <member name="T:Euclid.Extensions.Randomizer">
            <summary>Helper class for random number generation</summary>
        </member>
        <member name="M:Euclid.Extensions.Randomizer.NextDouble(System.Random,System.Double,System.Double)">
            <summary>Generates random numbers in an Interval</summary>
            <param name="random">the random number generator</param>
            <param name="min">the lower bound of the interval</param>
            <param name="max">the upper bound of the interval</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Extensions.Randomizer.Shuffle``1(System.Collections.Generic.IList{``0},System.Random)">
            <summary>Shuffles a list of template type</summary>
            <typeparam name="T">the template type</typeparam>
            <param name="list">the list to shuffle</param>
            <param name="random">the random number generator</param>
        </member>
        <member name="M:Euclid.Extensions.Randomizer.CloneAndShuffle``1(System.Collections.Generic.IList{``0},System.Random)">
            <summary>Creates a shuffled version of a list</summary>
            <typeparam name="T">the template type</typeparam>
            <param name="list">the list to shuffle</param>
            <param name="random">the random number generator</param>
            <returns>a shuffled version of the list</returns>
        </member>
        <member name="M:Euclid.Extensions.Randomizer.PickRandomNumbers(System.Int32,System.Int32,System.Int32,System.Random)">
            <summary>Picks random number</summary>
            <param name="fromIncluded"></param>
            <param name="toExcluded"></param>
            <param name="numberOfPicks"></param>
            <param name="randomNumberGenerator"></param>
            <returns></returns>
        </member>
        <member name="M:Euclid.Extensions.Randomizer.PickRandomNumbers(System.Int32,System.Int32,System.Int32,System.Collections.Generic.IEnumerable{System.Int32},System.Random)">
            <summary>Picks random number</summary>
            <param name="fromIncluded">the lower bound (included)</param>
            <param name="toExcluded">the upper bound (excluded)</param>
            <param name="numberOfPicks">the number of number wanted</param>
            <param name="forbiddenValues">the forbidden values</param>
            <param name="randomNumberGenerator">a random object</param>
            <returns>a list of numbers</returns>
        </member>
        <member name="T:Euclid.Helpers.Geodesic.Coordinates">
            <summary>Coordinates class, used to carry GPS coordinates and altitude in meters</summary>
        </member>
        <member name="M:Euclid.Helpers.Geodesic.Coordinates.#ctor(System.Double,System.Double,System.Double)">
            <summary>Builds a <c>Coordinates</c></summary>
            <param name="latitude">the latitude</param>
            <param name="longitude">the longitude</param>
            <param name="altitude">the altitude</param>
        </member>
        <member name="P:Euclid.Helpers.Geodesic.Coordinates.Latitude">
            <summary>Gets he geodesic latitude (negative in the southern hemisphere)</summary>
        </member>
        <member name="P:Euclid.Helpers.Geodesic.Coordinates.Longitude">
            <summary>Gets the geodesic longitude</summary>
        </member>
        <member name="P:Euclid.Helpers.Geodesic.Coordinates.Altitude">
            <summary>Gets the altitude in meters</summary>
        </member>
        <member name="T:Euclid.Helpers.Geodesic.Ellipsoid">
            <summary>Ellipsoid class, used for distance calculations</summary>
        </member>
        <member name="F:Euclid.Helpers.Geodesic.Ellipsoid.WorldGeodeticSystem84">
            <summary>The World Geodetic System 1984</summary>
        </member>
        <member name="F:Euclid.Helpers.Geodesic.Ellipsoid.GeodeticReferenceSystem80">
            <summary>The Geodesic Reference System 1980</summary>
        </member>
        <member name="F:Euclid.Helpers.Geodesic.Ellipsoid.GeodeticReferenceSystem67">
            <summary>The Geodesic Reference System 1967</summary>
        </member>
        <member name="F:Euclid.Helpers.Geodesic.Ellipsoid.Clarke1880">
            <summary>The Clarke1880 ellipsoid parameters</summary>
        </member>
        <member name="P:Euclid.Helpers.Geodesic.Ellipsoid.EquatorialRadius">
            <summary>Gets the semi-major axis of the ellipsoid</summary>
        </member>
        <member name="P:Euclid.Helpers.Geodesic.Ellipsoid.PolarRadius">
            <summary>Gets the semi-minor axis of the ellipsoid</summary>
        </member>
        <member name="P:Euclid.Helpers.Geodesic.Ellipsoid.Flattening">
            <summary>Gets the flattening of the ellipsoid</summary>
        </member>
        <member name="M:Euclid.Helpers.Geodesic.Ellipsoid.EllipsoidDistance(Euclid.Helpers.Geodesic.Coordinates,Euclid.Helpers.Geodesic.Coordinates)">
            <summary>Calculates the distance (in meters) between two Coordinates</summary>
            <param name="point1">The first point</param>
            <param name="point2">The second point</param>
            <returns>the distance between the points (expressed in meters)</returns>
        </member>
        <member name="T:Euclid.Helpers.Geodesic.Helper">
            <summary>Used to calculate distances on the surface of earth</summary>
        </member>
        <member name="M:Euclid.Helpers.Geodesic.Helper.SphericalDistance(Euclid.Helpers.Geodesic.Coordinates,Euclid.Helpers.Geodesic.Coordinates)">
            <summary>Calculates the distance (in meters) between two Coordinates</summary>
            <param name="point1">The first point</param>
            <param name="point2">The second point</param>
            <returns>the distance between the points (expressed in meters)</returns>
        </member>
        <member name="T:Euclid.Helpers.Quantilizer">
            <summary>Static helper for the quantilisation of time series</summary>
        </member>
        <member name="M:Euclid.Helpers.Quantilizer.QuantileIntervals(System.Int32,System.Collections.Generic.IList{System.Double},System.Boolean)">
            <summary>Builds the empirical quantiles from a given set of datas</summary>
            <param name="buckets">the number of buckets (ie for quartiles, should be 4 though there are only 3 quartiles)</param>
            <param name="values">the set of data</param>
            <param name="open">specifies if the end intervals should be semi infinite</param>
            <returns>a set of intervals</returns>
        </member>
        <member name="T:Euclid.Histograms.Bound">
            <summary>
            Bound class : mainly used in intervals
            </summary>
        </member>
        <member name="M:Euclid.Histograms.Bound.#ctor(System.Double,System.Boolean)">
            <summary>
            Builds a bound
            </summary>
            <param name="value">the value</param>
            <param name="isIncluded">specifies whether this value is included or not</param>
        </member>
        <member name="P:Euclid.Histograms.Bound.Value">
            <summary>Gets the bound's value</summary>
        </member>
        <member name="P:Euclid.Histograms.Bound.IsIncluded">
            <summary>Gets the bound's status</summary>
        </member>
        <member name="M:Euclid.Histograms.Bound.op_Equality(Euclid.Histograms.Bound,Euclid.Histograms.Bound)">
            <summary>Checks the equality between two bounds (reference equality then null coincidence, then content coincidence)</summary>
            <param name="b1">the left hand side <c>Bound</c></param>
            <param name="b2">the right hand side <c>Bound</c></param>
            <returns>true if equal, false otherwise</returns>
        </member>
        <member name="M:Euclid.Histograms.Bound.op_Inequality(Euclid.Histograms.Bound,Euclid.Histograms.Bound)">
            <summary>Checks the inequality between two bounds (based on the equal comparer)</summary>
            <param name="b1">the left hand side <c>Bound</c></param>
            <param name="b2">the right hand side <c>Bound</c></param>
            <returns>false if equal, true otherwise</returns>
        </member>
        <member name="M:Euclid.Histograms.Bound.op_LessThan(Euclid.Histograms.Bound,Euclid.Histograms.Bound)">
            <summary>Compares two Bounds</summary>
            <param name="b1">the left hand side Bound</param>
            <param name="b2">the right hand side Bound</param>
            <returns><c>true</c> if b1 is lower, <c>false</c> otherwise</returns>
        </member>
        <member name="M:Euclid.Histograms.Bound.op_GreaterThan(Euclid.Histograms.Bound,Euclid.Histograms.Bound)">
            <summary>Compares two Bounds</summary>
            <param name="b1">the left hand side Bound</param>
            <param name="b2">the right hand side Bound</param>
            <returns><c>true</c> if b1 is higher, <c>false</c> otherwise</returns>
        </member>
        <member name="M:Euclid.Histograms.Bound.op_LessThanOrEqual(Euclid.Histograms.Bound,Euclid.Histograms.Bound)">
            <summary>
            Compares two Bounds
            </summary>
            <param name="b1">the left hand side Bound</param>
            <param name="b2">the right hand side Bound</param>
            <returns><c>true</c> if b1 is lower or equal, <c>false</c> otherwise</returns>
        </member>
        <member name="M:Euclid.Histograms.Bound.op_GreaterThanOrEqual(Euclid.Histograms.Bound,Euclid.Histograms.Bound)">
            <summary>
            Compares two Bounds
            </summary>
            <param name="b1">the left hand side Bound</param>
            <param name="b2">the right hand side Bound</param>
            <returns><c>true</c> if b1 is greater or equal, <c>false</c> otherwise</returns>
        </member>
        <member name="M:Euclid.Histograms.Bound.Equals(Euclid.Histograms.Bound)">
            <summary>Checks the equality to another <c>Bound</c></summary>
            <param name="other">the other <c>Bound</c></param>
            <returns>a bool</returns>
        </member>
        <member name="M:Euclid.Histograms.Bound.Equals(System.Object)">
            <summary>Checks the equality to an object (inherited from IEquatable)</summary>
            <param name="other">the object </param>
            <returns>a bool</returns>
        </member>
        <member name="M:Euclid.Histograms.Bound.GetHashCode">
            <summary>Returns this instance's hashcode</summary>
            <returns>an int</returns>
        </member>
        <member name="M:Euclid.Histograms.Bound.CompareTo(Euclid.Histograms.Bound)">
            <summary> Compares this instance to another <c>Bound</c>
            </summary>
            <param name="other">the <c>Bound</c> to compare to</param>
            <returns>-1 if &lt;, +1 if &gt;, 0 otherwise</returns>
        </member>
        <member name="T:Euclid.Histograms.Interval">
            <summary>
            Interval representation class
            </summary>
        </member>
        <member name="M:Euclid.Histograms.Interval.#ctor(System.Double,System.Double,System.Boolean,System.Boolean)">
            <summary>Builds an interval</summary>
            <param name="lowerBound">the interval's lower bound</param>
            <param name="upperBound">the interval's upper bound</param>
            <param name="lowerIncluded">the lower bound's status </param>
            <param name="upperIncluded">the upper bound's status</param>
        </member>
        <member name="M:Euclid.Histograms.Interval.#ctor(Euclid.Histograms.Bound,Euclid.Histograms.Bound)">
            <summary>Builds an interval</summary>
            <param name="lower">the lower bound</param>
            <param name="upper">the upper bound</param>
        </member>
        <member name="M:Euclid.Histograms.Interval.#ctor(Euclid.Histograms.Interval)">
            <summary>
            Duplicates an <c>Interval</c>
            </summary>
            <param name="interval">the <c>Interval</c> to copy</param>
        </member>
        <member name="P:Euclid.Histograms.Interval.LowerBound">
            <summary>Gets the interval's lower bound</summary>
        </member>
        <member name="P:Euclid.Histograms.Interval.UpperBound">
            <summary>Gets the interval's upper bound</summary>
        </member>
        <member name="P:Euclid.Histograms.Interval.Clone">
            <summary>Gets a deep copy of the interval</summary>
        </member>
        <member name="M:Euclid.Histograms.Interval.Contains(System.Double)">
            <summary> Checks if the double is inside the interval </summary>
            <param name="x">the value</param>
            <returns><c>true</c> if x is inside the interval, <c>false</c> otherwise</returns>
        </member>
        <member name="M:Euclid.Histograms.Interval.ToString">
            <summary>
            Gives a string representation of the Interval
            </summary>
            <returns>a string</returns>
        </member>
        <member name="M:Euclid.Histograms.Interval.Intersection(Euclid.Histograms.Interval[])">
            <summary>Returns the intersection of a group of intervals</summary>
            <param name="intervals">the Intervals to intersect</param>
            <returns>an Interval</returns>
        </member>
        <member name="M:Euclid.Histograms.Interval.Equals(Euclid.Histograms.Interval)">
            <summary>Equality comparer</summary>
            <param name="other">the other Interval</param>
            <returns>true if the bounds match, false otherwise</returns>
        </member>
        <member name="T:Euclid.Histograms.Histogram">
            <summary>
            Histogram class
            </summary>
        </member>
        <member name="M:Euclid.Histograms.Histogram.#ctor(Euclid.Histograms.Interval[])">
            <summary>Builds an <c>Histogram</c></summary>
            <param name="intervals">the initial intervals</param>
        </member>
        <member name="P:Euclid.Histograms.Histogram.Count">
            <summary>Gets the number of intervals</summary>
        </member>
        <member name="P:Euclid.Histograms.Histogram.TotalItems">
            <summary>Gets the total number of items in the histogram</summary>
        </member>
        <member name="P:Euclid.Histograms.Histogram.Intervals">
            <summary>Gets the intervals</summary>
        </member>
        <member name="P:Euclid.Histograms.Histogram.Item(System.Int32)">
            <summary>Gets the number of items in the i-th bucket</summary>
            <param name="bucket">the bucket's index</param>
            <returns>an int</returns>
        </member>
        <member name="M:Euclid.Histograms.Histogram.Tabulate(System.Double,System.Int32)">
            <summary>Tabulates the value into to this instance</summary>
            <param name="value">the value</param>
            <param name="occurences">the number of occurences of the value</param>
        </member>
        <member name="M:Euclid.Histograms.Histogram.Tabulate(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>Tabulates these values into to this instance</summary>
            <param name="values">the value</param>
        </member>
        <member name="M:Euclid.Histograms.Histogram.Rank(System.Double)">
            <summary>
            Get the rank of the value from the distribution in (%)
            </summary>
            <param name="value">Target</param>
        </member>
        <member name="M:Euclid.Histograms.Histogram.Create(System.Double,System.Double,System.Int32)">
            <summary>Creates an <c>Histogram</c> with regular buckets</summary>
            <param name="lowerBound">the support's lower bound</param>
            <param name="upperBound">the support's upper bound</param>
            <param name="numberOfIntervals">the number of intervals</param>
            <returns>an <c>Histogram</c></returns>
        </member>
        <member name="T:Euclid.LinearAlgebra.EigenDecomposition">
            <summary>Class used to diagonalize symmetric matrices</summary>
        </member>
        <member name="M:Euclid.LinearAlgebra.EigenDecomposition.#ctor(Euclid.Matrix)">
            <summary>Initiates the class</summary>
            <param name="matrix">the <c>Matrix</c> to decompose</param>
        </member>
        <member name="P:Euclid.LinearAlgebra.EigenDecomposition.EigenValues">
            <summary>Returns the <c>Complex</c> eigen values of the matrix</summary>
        </member>
        <member name="P:Euclid.LinearAlgebra.EigenDecomposition.RealEigenValues">
            <summary>Returns the real eigen values of the matrix</summary>
        </member>
        <member name="P:Euclid.LinearAlgebra.EigenDecomposition.DiagonalMatrix">
            <summary>Returns the diagonal <c>Matrix</c> which is the diagonalized form of the initial matrix</summary>
        </member>
        <member name="P:Euclid.LinearAlgebra.EigenDecomposition.EigenVectors">
            <summary>Returns an array of all the eigen vectors of the matrix</summary>
        </member>
        <member name="P:Euclid.LinearAlgebra.EigenDecomposition.RealEigenVectors">
            <summary>Returns an array of the eigen vectors attached to the real eigen values of the matrix</summary>
        </member>
        <member name="P:Euclid.LinearAlgebra.EigenDecomposition.RealEigenPairs">
            <summary>Returns an array of pairs of eigen values and eigen vectors</summary>
        </member>
        <member name="M:Euclid.LinearAlgebra.EigenDecomposition.Solve">
            <summary>Tridiagonalizes the matrix and then diagonalize it in the complex space</summary>
        </member>
        <member name="M:Euclid.LinearAlgebra.EigenDecomposition.SymmetricTridiagonalize">
            <summary>Symmetric Householder reduction to tridiagonal form.</summary>
        </member>
        <member name="M:Euclid.LinearAlgebra.EigenDecomposition.SymmetricDiagonalize">
            <summary>Symmetric tridiagonal QL algorithm</summary>
        </member>
        <member name="M:Euclid.LinearAlgebra.EigenDecomposition.NonsymmetricReduceToHessenberg">
            <summary>Nonsymmetric reduction to Hessenberg form</summary>
        </member>
        <member name="M:Euclid.LinearAlgebra.EigenDecomposition.NonsymmetricReduceHessenberToRealSchur">
            <summary>Nonsymmetric reduction from Hessenberg to real Schur form</summary>
        </member>
        <member name="T:Euclid.Logging.LogContainer">
            <summary>Log container class for display, organized for event handling</summary>
        </member>
        <member name="M:Euclid.Logging.LogContainer.#ctor(Euclid.Logging.Level,Euclid.Logging.Level)">
            <summary>Builds a log container aimed at catching the records for a given range of levels</summary>
            <param name="minLevel">the minimun level</param>
            <param name="maxLevel">the maximum level</param>
        </member>
        <member name="M:Euclid.Logging.LogContainer.Add(Euclid.Logging.LogRecord)">
            <summary>Adds a record to the logger</summary>
            <param name="record">the <c>LogRecord</c> to add</param>
        </member>
        <member name="M:Euclid.Logging.LogContainer.Debug(System.String,System.String)">
            <summary>Adds a debug record</summary>
            <param name="context">the log context</param>
            <param name="message">the message</param>
        </member>
        <member name="M:Euclid.Logging.LogContainer.Info(System.String,System.String)">
            <summary>Adds an info record</summary>
            <param name="context">the log context</param>
            <param name="message">the message</param>
        </member>
        <member name="M:Euclid.Logging.LogContainer.Warning(System.String,System.String)">
            <summary>Adds a warning record</summary>
            <param name="context">the log context</param>
            <param name="message">the message</param>
        </member>
        <member name="M:Euclid.Logging.LogContainer.Error(System.String,System.String)">
            <summary>Adds an error record</summary>
            <param name="context">the log context</param>
            <param name="message">the message</param>
        </member>
        <member name="M:Euclid.Logging.LogContainer.Fatal(System.String,System.String)">
            <summary>Adds a fatal record</summary>
            <param name="context">the log context</param>
            <param name="message">the message</param>
        </member>
        <member name="P:Euclid.Logging.LogContainer.Records">
            <summary>Returns the logs</summary>
        </member>
        <member name="M:Euclid.Logging.LogContainer.Clear">
            <summary>Clears the log</summary>
        </member>
        <member name="M:Euclid.Logging.LogContainer.Remove(Euclid.Logging.Level)">
            <summary>Removes the logs by the level</summary>
            <param name="level">the sought level</param>
        </member>
        <member name="M:Euclid.Logging.LogContainer.RemoveBefore(System.DateTime)">
            <summary>Removes the logs by date </summary>
            <param name="dateTime">the cut-off date time</param>
        </member>
        <member name="E:Euclid.Logging.LogContainer.DataChanged">
            <summary>Event handler</summary>
        </member>
        <member name="T:Euclid.Logging.FileLogger">
            <summary>Represents a logger that dumps itself into a file</summary>
        </member>
        <member name="M:Euclid.Logging.FileLogger.#ctor(System.Int32,System.String,Euclid.Logging.Level,Euclid.Logging.Level)">
            <summary>Builds a file logger</summary>
            <param name="maxRecords">the maximum number of logs before dumping to a file</param>
            <param name="pathFormat">the general format of the file path</param>
            <param name="minLevel">the minimum level needed to be logged</param>
            <param name="maxLevel">the maximum level needed to be logged</param>
        </member>
        <member name="M:Euclid.Logging.FileLogger.Add(Euclid.Logging.LogRecord)">
            <summary>Adds a record to the logger</summary>
            <param name="record">the <c>LogRecord</c> to add</param>
        </member>
        <member name="M:Euclid.Logging.FileLogger.Debug(System.String,System.String)">
            <summary>Adds a debug line to the log</summary>
            <param name="context">the logging context</param>
            <param name="message">the message</param>
        </member>
        <member name="M:Euclid.Logging.FileLogger.Info(System.String,System.String)">
            <summary>Adds an information line to the log</summary>
            <param name="context">the logging context</param>
            <param name="message">the message</param>
        </member>
        <member name="M:Euclid.Logging.FileLogger.Warning(System.String,System.String)">
            <summary>Adds a warning line to the log</summary>
            <param name="context">the logging context</param>
            <param name="message">the message</param>
        </member>
        <member name="M:Euclid.Logging.FileLogger.Error(System.String,System.String)">
            <summary>Adds a error line to the log</summary>
            <param name="context">the logging context</param>
            <param name="message">the message</param>
        </member>
        <member name="M:Euclid.Logging.FileLogger.Fatal(System.String,System.String)">
            <summary>Adds a fatal line to the log</summary>
            <param name="context">the logging context</param>
            <param name="message">the message</param>
        </member>
        <member name="T:Euclid.Logging.ILogger">
            <summary>Represents a logger object</summary>
        </member>
        <member name="M:Euclid.Logging.ILogger.Add(Euclid.Logging.LogRecord)">
            <summary>Adds a log to the logger</summary>
            <param name="record">the log record</param>
        </member>
        <member name="M:Euclid.Logging.ILogger.Debug(System.String,System.String)">
            <summary>Adds an debug information to the logger</summary>
            <param name="context">the debug info's context</param>
            <param name="message">the debug info message</param>
        </member>
        <member name="M:Euclid.Logging.ILogger.Info(System.String,System.String)">
            <summary>Adds an information to the logger</summary>
            <param name="context">the info's context</param>
            <param name="message">the info message</param>
        </member>
        <member name="M:Euclid.Logging.ILogger.Warning(System.String,System.String)">
            <summary>Adds a warning to the logger</summary>
            <param name="context">the warning's context</param>
            <param name="message">the warning message</param>
        </member>
        <member name="M:Euclid.Logging.ILogger.Error(System.String,System.String)">
            <summary>Adds an error to the logger</summary>
            <param name="context">the error's context</param>
            <param name="message">the error message</param>
        </member>
        <member name="M:Euclid.Logging.ILogger.Fatal(System.String,System.String)">
            <summary>Adds a fatal error to the logger</summary>
            <param name="context">the fatal error's context</param>
            <param name="message">the fatal error's message</param>
        </member>
        <member name="T:Euclid.Logging.LogRecord">
            <summary>Log record class</summary>
        </member>
        <member name="M:Euclid.Logging.LogRecord.#ctor(System.String,Euclid.Logging.Level,System.String)">
            <summary>Builds a log record</summary>
            <param name="context">the logging context</param>
            <param name="level">the level</param>
            <param name="message">the message</param>
        </member>
        <member name="P:Euclid.Logging.LogRecord.TimeStamp">
            <summary>Returns the log's timestamp</summary>
        </member>
        <member name="P:Euclid.Logging.LogRecord.Level">
            <summary>Returns the level</summary>
        </member>
        <member name="P:Euclid.Logging.LogRecord.Context">
            <summary>Returns the context</summary>
        </member>
        <member name="P:Euclid.Logging.LogRecord.Message">
            <summary>Returns the log's message</summary>
        </member>
        <member name="M:Euclid.Logging.LogRecord.ToString">
            <summary>Serializes the record</summary>
            <returns>a <c>String</c></returns>
        </member>
        <member name="T:Euclid.Logging.Level">
            <summary>Represents the level for a log record</summary>
        </member>
        <member name="F:Euclid.Logging.Level.Off">
            <summary>No log level</summary>
        </member>
        <member name="F:Euclid.Logging.Level.Debug">
            <summary>Debug</summary>
        </member>
        <member name="F:Euclid.Logging.Level.Info">
            <summary>Information</summary>
        </member>
        <member name="F:Euclid.Logging.Level.Warn">
            <summary>Warning</summary>
        </member>
        <member name="F:Euclid.Logging.Level.Error">
            <summary>Error</summary>
        </member>
        <member name="F:Euclid.Logging.Level.Fatal">
            <summary>Fatal</summary>
        </member>
        <member name="T:Euclid.Matrix">
            <summary>
            Matrix of double
            </summary>
        </member>
        <member name="M:Euclid.Matrix.#ctor(System.Int32,System.Int32,System.Double)">
            <summary>Builds a rectangular matrix filled with the specified value</summary>
            <param name="rows">the number of rows</param>
            <param name="cols">the number of columns</param>
            <param name="value">the value for all the fields of the matrix</param>
        </member>
        <member name="P:Euclid.Matrix.Columns">
            <summary>Returns the number of columns of the <c>Matrix</c></summary>
        </member>
        <member name="P:Euclid.Matrix.Rows">
            <summary>Returns the number of rows of the <c>Matrix</c></summary>
        </member>
        <member name="P:Euclid.Matrix.IsSquare">
            <summary>Specifies whether the <c>Matrix</c> is square</summary>
        </member>
        <member name="P:Euclid.Matrix.IsSymetric">
            <summary>Specifies whether the <c>Matrix</c> is square and symmetric</summary>
        </member>
        <member name="P:Euclid.Matrix.Size">
            <summary>Returns the number of values in the <c>Matrix</c></summary>
        </member>
        <member name="P:Euclid.Matrix.Data">
            <summary>Returns the data of the matrix as a array of double with the rows one after the other</summary>
        </member>
        <member name="P:Euclid.Matrix.Array">
            <summary>Gets the matrix' data as a 2d-array</summary>
        </member>
        <member name="P:Euclid.Matrix.JaggedArray">
            <summary>Gets the matrix' data as a jagged array</summary>
        </member>
        <member name="P:Euclid.Matrix.Item(System.Int32,System.Int32)">
            <summary>Allows reading and modifying the coefficients of the <c>Matrix</c></summary>
            <param name="i">the row</param>
            <param name="j">the column</param>
            <returns>a double value</returns>
        </member>
        <member name="P:Euclid.Matrix.Item(System.Int32)">
            <summary> Allows reading and modifying the coefficients of the <c>Matrix</c></summary>
            <param name="i">the coefficient index</param>
            <returns>a double value</returns>
        </member>
        <member name="P:Euclid.Matrix.Clone">
            <summary>Returns a deep copy of the <c>Matrix</c></summary>
        </member>
        <member name="P:Euclid.Matrix.Diagonal">
            <summary>Returns the diagonal matrix of the current Matrix</summary>
        </member>
        <member name="P:Euclid.Matrix.L">
            <summary>The Lower triangular part of the LU decomposition</summary>
        </member>
        <member name="P:Euclid.Matrix.U">
            <summary>Returns the upper triangular part of the LU decomposition</summary>
        </member>
        <member name="P:Euclid.Matrix.Determinant">
            <summary>Returns the determinant of the <c>Matrix</c></summary>
        </member>
        <member name="P:Euclid.Matrix.Inverse">
            <summary>Returns the inverse of the <c>Matrix</c> when possible, null otherwise</summary>
        </member>
        <member name="P:Euclid.Matrix.FastInverse">
            <summary>Returns the inverse of the <c>Matrix</c> when possible, null otherwise. Done using multithreading !</summary>
        </member>
        <member name="P:Euclid.Matrix.CoMatrix">
            <summary>Returns the co-matrix of the current matrix</summary>
        </member>
        <member name="P:Euclid.Matrix.CholeskyLower">
            <summary>Returns the lower Cholesky factor</summary>
        </member>
        <member name="P:Euclid.Matrix.Trace">
            <summary>Returns the trace of the <c>Matrix</c></summary>
        </member>
        <member name="P:Euclid.Matrix.Transpose">
            <summary>Returns the transposed <c>Matrix</c></summary>
        </member>
        <member name="P:Euclid.Matrix.FastTranspose">
            <summary>Returns the transposed <c>Matrix</c> filled using multithreading</summary>
        </member>
        <member name="P:Euclid.Matrix.SymmetricPart">
            <summary>Returns the symmetric part of the <c>Matrix</c> ( 1/2 . (A^T + A))</summary>
        </member>
        <member name="P:Euclid.Matrix.AntiSymmetricPart">
            <summary>Returns the symmetric part of the <c>Matrix</c> (1/2 . (A - A^T))</summary>
        </member>
        <member name="P:Euclid.Matrix.Norm1">
            <summary>Returns the sum of the absolute values</summary>
        </member>
        <member name="P:Euclid.Matrix.Norm2">
            <summary>Returns the square root of the sum of squares</summary>
        </member>
        <member name="P:Euclid.Matrix.NormSup">
            <summary>Returns the largest value of the <c>Matrix</c> in absolute value</summary>
        </member>
        <member name="P:Euclid.Matrix.SumOfSquares">
            <summary>Returns the sum of the squared values</summary>
        </member>
        <member name="P:Euclid.Matrix.Sum">
            <summary>Returns the sum of the values</summary>
        </member>
        <member name="M:Euclid.Matrix.MakeLU">
            <summary>Evaluates the LU decomposition of the matrix and stores the results in the private attributes _L and _U.</summary>
        </member>
        <member name="M:Euclid.Matrix.SubMatrix(System.Int32,System.Int32)">
            <summary>Returns the matrix from which one row and one column have been excluded (indexed by row and col)</summary>
            <param name="row">The index of the row to exclude</param>
            <param name="col">The index of the column to exclude</param>
            <returns>The matrix without the speficied line and the column</returns>
        </member>
        <member name="M:Euclid.Matrix.SetCol(Euclid.Vector,System.Int32)">
            <summary>Replaces the column of index k with the input Vector v</summary>
            <param name="v">Column replacing the old one</param>
            <param name="k">Index of the column to replace</param>
        </member>
        <member name="M:Euclid.Matrix.SetRow(Euclid.Vector,System.Int32)">
            <summary>Replaces the row of index k with the input Vector v</summary>
            <param name="v">Row replacing the old one</param>
            <param name="k">Index of the row to replace</param>
        </member>
        <member name="M:Euclid.Matrix.SolveWith(Euclid.Vector)">
            <summary>Solves the equation : A*x=v, where A is the Matrix, x the unknown, v the input argument</summary>
            <param name="v">The right hand side of the equation</param>
            <returns>The solution x of A*x=v</returns>
        </member>
        <member name="M:Euclid.Matrix.Column(System.Int32)">
            <summary>Extracts a specific column</summary>
            <param name="j">the specified column</param>
            <returns>a column Vector</returns>
        </member>
        <member name="M:Euclid.Matrix.Row(System.Int32)">
            <summary> Extracts a specific row</summary>
            <param name="i">the specified row</param>
            <returns>a row Vector</returns>
        </member>
        <member name="M:Euclid.Matrix.op_Multiply(Euclid.Matrix,System.Double)">
            <summary>Multiplies a <c>Matrix</c> by a scalar</summary>
            <param name="m">the left hand side <c>Matrix</c></param>
            <param name="f">the scalar</param>
            <returns>the <c>Matrix</c> result of the multiplication</returns>
        </member>
        <member name="M:Euclid.Matrix.op_Multiply(System.Double,Euclid.Matrix)">
            <summary> Multiplies a <c>Matrix</c> by a scalar</summary>
            <param name="f">the scalar</param>
            <param name="m">the right hand side <c>Matrix</c></param>
            <returns>the <c>Matrix</c> result of the multiplication</returns>
        </member>
        <member name="M:Euclid.Matrix.op_Division(Euclid.Matrix,System.Double)">
            <summary>Divides all the coefficients of a <c>Matrix</c> by a scalar</summary>
            <param name="m">the left hand side <c>Matrix</c></param>
            <param name="f">the scalar</param>
            <returns>the <c>Matrix</c> result of the division</returns>
        </member>
        <member name="M:Euclid.Matrix.op_Multiply(Euclid.Matrix,Euclid.Matrix)">
            <summary>Multiplies two matrices</summary>
            <param name="m1">the left hand side <c>Matrix</c></param>
            <param name="m2">the right hand side <c>Matrix</c></param>
            <returns>the <c>Matrix</c> result of the multiplication</returns>
        </member>
        <member name="M:Euclid.Matrix.op_ExclusiveOr(Euclid.Matrix,Euclid.Matrix)">
            <summary>Multiplies two matrices using multithreading</summary>
            <param name="m1">the left hand side <c>Matrix</c></param>
            <param name="m2">the right hand side <c>Matrix</c></param>
            <returns>the <c>Matrix</c> result of the multiplication</returns>
        </member>
        <member name="M:Euclid.Matrix.Add(Euclid.Matrix,Euclid.Matrix)">
            <summary>Performs a matrix addition, after going through dimension compatibility verifications.</summary>
            <param name="m1">First matrix</param>
            <param name="m2">Second matrix</param>
            <returns>The sum of m1 and m2</returns>
        </member>
        <member name="M:Euclid.Matrix.LinearCombination(System.Double,Euclid.Matrix,System.Double,Euclid.Matrix)">
            <summary>Builds a Matrix as a linear combination of two matrices</summary>
            <param name="f1">the first Matrix' factor</param>
            <param name="m1">the first Matrix</param>
            <param name="f2">the second Matrix' factor</param>
            <param name="m2">the second Matrix</param>
            <returns>the Matrix result of f1*m1 + f2*m2</returns>
        </member>
        <member name="M:Euclid.Matrix.LinearCombination(System.Double[],Euclid.Matrix[])">
            <summary>Builds a Matrix as a linear combination of matrices</summary>
            <param name="factors">the factors</param>
            <param name="matrices">the matrices</param>
            <returns>the Matrix result of Sum i  fi*mi</returns>
        </member>
        <member name="M:Euclid.Matrix.op_Addition(Euclid.Matrix,System.Double)">
            <summary>Adds a scalar to all the coefficients of a <c>Matrix</c></summary>
            <param name="m">the left hand side <c>Matrix</c></param>
            <param name="c">the scalar</param>
            <returns>the <c>Matrix</c> result of the addition</returns>
        </member>
        <member name="M:Euclid.Matrix.op_Addition(System.Double,Euclid.Matrix)">
            <summary>Adds a scalar to all the coefficients of a <c>Matrix</c></summary>
            <param name="c">the scalar</param>
            <param name="m">the right hand side <c>Matrix</c></param>
            <returns>the <c>Matrix</c> result of the addition</returns>
        </member>
        <member name="M:Euclid.Matrix.op_Subtraction(Euclid.Matrix,System.Double)">
            <summary>Substracts a scalar to all the coefficients of a <c>Matrix</c></summary>
            <param name="m">the left hand side <c>Matrix</c></param>
            <param name="c">the scalar</param>
            <returns>the <c>Matrix</c> result of the substraction</returns>
        </member>
        <member name="M:Euclid.Matrix.op_Subtraction(System.Double,Euclid.Matrix)">
            <summary>Adds a scalar to the opposite of a <c>Matrix</c></summary>
            <param name="c">the scalar</param>
            <param name="m">the right hand side <c>Matrix</c></param>
            <returns>the <c>Matrix</c> result of the substraction</returns>
        </member>
        <member name="M:Euclid.Matrix.op_UnaryNegation(Euclid.Matrix)">
            <summary>Returns the opposite of the <c>Matrix</c></summary>
            <param name="m">the input matrix</param>
            <returns>the <c>Matrix</c> opposite</returns>
        </member>
        <member name="M:Euclid.Matrix.op_Addition(Euclid.Matrix,Euclid.Matrix)">
            <summary>Performs the matrix addition</summary>
            <param name="m1">the left hand side matrix</param>
            <param name="m2">the right hand side matrix</param>
            <returns>a <c>Matrix</c></returns>
        </member>
        <member name="M:Euclid.Matrix.op_Subtraction(Euclid.Matrix,Euclid.Matrix)">
            <summary>Performs a matrix substraction</summary>
            <param name="m1">the left hand side</param>
            <param name="m2">the right hand side</param>
            <returns>the <c>Matrix</c> result of the substraction</returns>
        </member>
        <member name="M:Euclid.Matrix.Power(Euclid.Matrix,System.Int32)">
            <summary>Evaluates the matrix raised to a power specified by pow</summary>
            <param name="matrix">the matrix</param>
            <param name="pow">The power to raise the matrix to</param>
            <returns>The matrix, raised to the power pow</returns>
        </member>
        <member name="M:Euclid.Matrix.Create(System.Double[0:,0:])">
            <summary>Builds a <c>Matrix</c> from a 2d-array of double</summary>
            <param name="model">the 2d-array of data</param>
        </member>
        <member name="M:Euclid.Matrix.Create(System.Double[][])">
            <summary>Builds a <c>Matrix</c> from a 2d-array of double</summary>
            <param name="model">the 2d-array of data</param>
        </member>
        <member name="M:Euclid.Matrix.Create(System.Int32,System.Int32)">
            <summary>Creates an empty rectangular Matrix </summary>
            <param name="rows">the number of rows</param>
            <param name="cols">the number of columns</param>
            <returns>a Matrix</returns>
        </member>
        <member name="M:Euclid.Matrix.Create(System.Int32,System.Int32,System.Double)">
            <summary>Creates a rectangular Matrix </summary>
            <param name="rows">the number of rows</param>
            <param name="cols">the number of cols</param>
            <param name="value">the value of the coefficients</param>
            <returns>a Matrix</returns>
        </member>
        <member name="M:Euclid.Matrix.CreateSquare(System.Int32)">
            <summary>Creates an empty square Matrix</summary>
            <param name="dimension">the Matrix's number of rows/columns</param>
            <returns>a Matrix</returns>
        </member>
        <member name="M:Euclid.Matrix.Create">
            <summary>Creates a 2x2 Matrix</summary>
            <returns>a Matrix</returns>
        </member>
        <member name="M:Euclid.Matrix.CreateIdentityMatrix(System.Int32,System.Int32)">
            <summary>Returns a matrix with ones on the diagonal of ones starting at the (0,0) element.
            When the matrix is squared, this is the identity matrix</summary>
            <param name="iRows">The number of rows of the output</param>
            <param name="iCols">The number of columns of the output</param>
            <returns>A  matrix with ones on the diagonal of ones starting at the (0,0) element</returns>
        </member>
        <member name="M:Euclid.Matrix.CreateBandMatrix(System.Int32,System.Double[])">
            <summary>Builds a square symmetric band-matrix</summary>
            <param name="size">the size of the matrix</param>
            <param name="values">the values of the diagonals and sub-diagonals</param>
            <returns>a square matrix</returns>
        </member>
        <member name="M:Euclid.Matrix.CreateTridiagonalMatrix(System.Int32,System.Double,System.Double,System.Double)">
            <summary>Builds a square tridiagonal matrix</summary>
            <param name="size">the size of the matrix</param>
            <param name="diagonal">the value on the matrix's diagonal</param>
            <param name="upper">the value on the matrix's first super diagonal</param>
            <param name="lower">the value on the matrix's first sub diagonal</param>
            <returns>a square matrix</returns>
        </member>
        <member name="M:Euclid.Matrix.CreateDiagonalMatrix(System.Double[])">
            <summary>Creates a diagonal matrix</summary>
            <param name="values">the values to be set on the diagonal</param>
            <returns>a <c>Matrix</c> </returns>
        </member>
        <member name="M:Euclid.Matrix.CreateSquareRandom(System.Int32)">
            <summary>Returns a square matrix full of uniform random values</summary>
            <param name="size">the number of rows / cols</param>
            <returns>a square <c>Matrix</c></returns>
        </member>
        <member name="M:Euclid.Matrix.CreateRandom(System.Int32,System.Int32)">
            <summary>Returns a rectangular matrix full of uniform random values</summary>
            <param name="rows">the number of rows</param>
            <param name="columns">the number of columns</param>
            <returns>a rectangular matrix</returns>
        </member>
        <member name="M:Euclid.Matrix.CreateFromColumns(Euclid.Vector[])">
            <summary>Returns a Matrix made of the given Vectors</summary>
            <param name="vectors">the Vectors</param>
            <returns>a Matrix</returns>
        </member>
        <member name="M:Euclid.Matrix.TransposeBySelf(Euclid.Matrix)">
            <summary>Returns the product X^T . X</summary>
            <param name="X">the <c>Matrix</c></param>
            <returns>the <c>Matrix</c> result of the product</returns>
        </member>
        <member name="M:Euclid.Matrix.FastTransposeBySelf(Euclid.Matrix)">
            <summary>Returns the product X^T . X using multithreading</summary>
            <param name="X">the <c>Matrix</c></param>
            <returns>the <c>Matrix</c> result of the product</returns>
        </member>
        <member name="M:Euclid.Matrix.Apply(Euclid.Matrix,System.Func{System.Double,System.Double})">
            <summary>Applies a function to transform the data of the matrix</summary>
            <param name="m">the matrix to transform</param>
            <param name="func">the transforming function</param>
            <returns>a <c>Matrix</c></returns>
        </member>
        <member name="M:Euclid.Matrix.Hadamard(Euclid.Matrix,Euclid.Matrix)">
            <summary>Returns the Hadamard product</summary>
            <param name="m1">the left hand side</param>
            <param name="m2">the right hand side</param>
            <returns>a <c>Matrix</c> containing the Hadamard product</returns>
        </member>
        <member name="M:Euclid.Matrix.Scalar(Euclid.Matrix,Euclid.Matrix)">
            <summary>Returns the scalar product of the matrices</summary>
            <param name="m1">the left hand side</param>
            <param name="m2">the right hand side</param>
            <returns>a double value</returns>
        </member>
        <member name="M:Euclid.Matrix.Max(Euclid.Matrix,Euclid.Matrix)">
            <summary>Returns the point-to-point maximum between two matrices</summary>
            <param name="m1">the left hand side</param>
            <param name="m2">the right hand side</param>
            <returns>a <c>Matrix</c></returns>
        </member>
        <member name="M:Euclid.Matrix.Equals(Euclid.Matrix)">
            <summary>Determines whether the specified object is equal to the current object</summary>
            <param name="other">the object to compare with the current object</param>
            <returns><c>true</c> if the specified object is equal to the current object; otherwise, <c>false</c></returns>
        </member>
        <member name="M:Euclid.Matrix.ToString">
            <summary>Returns a string that represents the matrix</summary>
            <returns>a string that represents the matrix</returns>
        </member>
        <member name="T:Euclid.Numerics.FiniteDifferenceScheme">
            <summary>Represents a finite difference scheme</summary>
        </member>
        <member name="F:Euclid.Numerics.FiniteDifferenceScheme.Implicit">
            <summary>Implicit scheme</summary>
        </member>
        <member name="F:Euclid.Numerics.FiniteDifferenceScheme.Explicit">
            <summary>Explicit scheme</summary>
        </member>
        <member name="F:Euclid.Numerics.FiniteDifferenceScheme.CrankNicholson">
            <summary>Crank Nicholson scheme</summary>
        </member>
        <member name="T:Euclid.Numerics.DifferenceForm">
            <summary>
            The difference form used to differentiate
            </summary>
        </member>
        <member name="F:Euclid.Numerics.DifferenceForm.Forward">
            <summary>the forward-rule</summary>
        </member>
        <member name="F:Euclid.Numerics.DifferenceForm.Backward">
            <summary>the backward-rule</summary>
        </member>
        <member name="F:Euclid.Numerics.DifferenceForm.Central">
            <summary>the central-rule</summary>
        </member>
        <member name="T:Euclid.Numerics.Differentiator">
            <summary>Numeric differentiation class</summary>
        </member>
        <member name="M:Euclid.Numerics.Differentiator.Differentiate(System.Func{System.Double,System.Double})">
            <summary> First degree numerical differentiation</summary>
            <param name="function">the function to differentiate</param>
            <returns>the derivative</returns>
        </member>
        <member name="M:Euclid.Numerics.Differentiator.Differentiate(System.Func{System.Double,System.Double},Euclid.Numerics.DifferenceForm,System.Double)">
            <summary>First degree numerical differentiation</summary>
            <param name="function">the function to differentiate</param>
            <param name="form">the differentiation form</param>
            <param name="step">the differentiation step</param>
            <returns>the derivative</returns>
        </member>
        <member name="M:Euclid.Numerics.Differentiator.Differentiate(System.Func{System.Double,System.Double},System.Int32,Euclid.Numerics.DifferenceForm,System.Double)">
            <summary> High degree numerical differentiation</summary>
            <param name="function">the function to differentiate</param>
            <param name="n">the degree</param>
            <param name="form">the differentiation form</param>
            <param name="step">the differentiation step</param>
            <returns>the n-degree derivative</returns>
        </member>
        <member name="M:Euclid.Numerics.Differentiator.Hessian(System.Func{Euclid.Vector,System.Double},Euclid.Vector)">
            <summary> High degree numerical differentiation</summary>
            <param name="function">the function to differentiate</param>
            <param name="bump">the differentiation step</param>
            <returns>the hessian matrix</returns>
        </member>
        <member name="T:Euclid.Numerics.IntegrationForm">
            <summary>
            The integration method
            </summary>
        </member>
        <member name="F:Euclid.Numerics.IntegrationForm.Left">
            <summary>Left-point rule</summary>
        </member>
        <member name="F:Euclid.Numerics.IntegrationForm.Right">
            <summary>Right-point rule</summary>
        </member>
        <member name="F:Euclid.Numerics.IntegrationForm.Middle">
            <summary>Middle-point rule</summary>
        </member>
        <member name="F:Euclid.Numerics.IntegrationForm.Trapeze">
            <summary>Trapeze rule</summary>
        </member>
        <member name="F:Euclid.Numerics.IntegrationForm.Simpson">
            <summary>Simpson rule</summary>
        </member>
        <member name="T:Euclid.Numerics.Integrator">
            <summary>
            Iterative processor to calculate the integral of a function over an interval
            </summary>
        </member>
        <member name="M:Euclid.Numerics.Integrator.#ctor(System.Double,System.Double,System.Func{System.Double,System.Double},Euclid.Numerics.IntegrationForm,System.Int32)">
            <summary>
            Builds a <c>Integrator</c>
            </summary>
            <param name="a">the lower bound of the interval</param>
            <param name="b">the upper bound of the interval</param>
            <param name="f">the function to integrate</param>
            <param name="form">the IntegrationForm use to approximate</param>
            <param name="maxIterations">the maximum iterations </param>
        </member>
        <member name="P:Euclid.Numerics.Integrator.Function">
            <summary>
            Gets and sets the function to integrate
            </summary>
        </member>
        <member name="P:Euclid.Numerics.Integrator.MaxIterations">
            <summary>
            Gets and sets the maximum number of iterations
            </summary>
        </member>
        <member name="P:Euclid.Numerics.Integrator.LowerBound">
            <summary>
            Gets and sets the lower bound of the interval
            </summary>
        </member>
        <member name="P:Euclid.Numerics.Integrator.UpperBound">
            <summary>
            Gets and sets the upper bound of the interval
            </summary>
        </member>
        <member name="P:Euclid.Numerics.Integrator.Form">
            <summary>
            Gets and sets the integration form
            </summary>
        </member>
        <member name="P:Euclid.Numerics.Integrator.Error">
            <summary>
            Returns the error of the integration
            </summary>
        </member>
        <member name="P:Euclid.Numerics.Integrator.Status">
            <summary>Returns the status of the solver after the integration process</summary>
        </member>
        <member name="P:Euclid.Numerics.Integrator.Result">
            <summary>Returns the integral value of the function</summary>
        </member>
        <member name="P:Euclid.Numerics.Integrator.Convergence">
            <summary>Returns the details of the convergence sequence (integral and error)</summary>
        </member>
        <member name="M:Euclid.Numerics.Integrator.Integrate">
            <summary>
            Performs the iterative integration of the function
            </summary>
        </member>
        <member name="T:Euclid.Numerics.NumericalSeriesCumulator">
            <summary>Calculates the sum of the numerical series</summary>
        </member>
        <member name="M:Euclid.Numerics.NumericalSeriesCumulator.#ctor(System.Int64,System.Func{System.Int64,System.Double},System.Int32)">
            <summary>Builds a cumulative calculator of numerical series</summary>
            <param name="initialIndex">the initial index of the sum</param>
            <param name="series">the series function</param>
            <param name="maxIterations">the maximum number of iterations</param>
        </member>
        <member name="P:Euclid.Numerics.NumericalSeriesCumulator.InitialIndex">
            <summary>Gets and sets the initial index of the sum</summary>
        </member>
        <member name="P:Euclid.Numerics.NumericalSeriesCumulator.MaxIterations">
            <summary>Gets and sets the maximum number of iterations</summary>
        </member>
        <member name="P:Euclid.Numerics.NumericalSeriesCumulator.Tolerance">
            <summary>
            Gets and sets the tolerance for the target (threshold for target reached)
            </summary>
        </member>
        <member name="P:Euclid.Numerics.NumericalSeriesCumulator.Iterations">
            <summary>Gets the number of interations of the cumulator</summary>
        </member>
        <member name="P:Euclid.Numerics.NumericalSeriesCumulator.Sum">
            <summary>Gets the cumulated sum of the series</summary>
        </member>
        <member name="P:Euclid.Numerics.NumericalSeriesCumulator.Status">
            <summary>Gets the final status of the cumulator</summary>
        </member>
        <member name="P:Euclid.Numerics.NumericalSeriesCumulator.Convergence">
            <summary>Gets the details of the convergence (value)</summary>
        </member>
        <member name="M:Euclid.Numerics.NumericalSeriesCumulator.Calculate">
            <summary>Sums the series until convergence or exhaustion of the iterations</summary>
        </member>
        <member name="M:Euclid.Numerics.NumericalSeriesCumulator.CalculateAitken">
            <summary>Sums the series until convergence or exhaustion of the iterations (using the Aitken Delta Squared method)</summary>
        </member>
        <member name="T:Euclid.Numerics.NumericalSeriesStatus">
            <summary>The status of the numerical series status</summary>
        </member>
        <member name="F:Euclid.Numerics.NumericalSeriesStatus.NotRan">
            <summary>The cumulator did not run</summary>
        </member>
        <member name="F:Euclid.Numerics.NumericalSeriesStatus.Diverged">
            <summary>The cumulator diverged</summary>
        </member>
        <member name="F:Euclid.Numerics.NumericalSeriesStatus.Normal">
            <summary>The cumulator ran as expected</summary>
        </member>
        <member name="F:Euclid.Numerics.NumericalSeriesStatus.IterationExceeded">
            <summary>The cumulator exceeded its maximum number of iterations</summary>
        </member>
        <member name="T:Euclid.Numerics.PartialDifferentialEquations.UnivariateGridConfiguration">
            <summary>Represents a grid configuration for univariate PDEs</summary>
        </member>
        <member name="M:Euclid.Numerics.PartialDifferentialEquations.UnivariateGridConfiguration.#ctor(System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double})">
            <summary>Builds a univariate EDP grid configuration</summary>
            <param name="tBuckets">the time buckets</param>
            <param name="xBuckets">the x-buckets</param>
        </member>
        <member name="P:Euclid.Numerics.PartialDifferentialEquations.UnivariateGridConfiguration.TimeCount">
            <summary>Returns the number of time buckets</summary>
        </member>
        <member name="P:Euclid.Numerics.PartialDifferentialEquations.UnivariateGridConfiguration.TimeBuckets">
            <summary>Returns the time buckets</summary>
        </member>
        <member name="P:Euclid.Numerics.PartialDifferentialEquations.UnivariateGridConfiguration.TimeIncrements">
            <summary>Returns the time increments</summary>
        </member>
        <member name="P:Euclid.Numerics.PartialDifferentialEquations.UnivariateGridConfiguration.XCount">
            <summary>Returns the number of X buckets</summary>
        </member>
        <member name="P:Euclid.Numerics.PartialDifferentialEquations.UnivariateGridConfiguration.XBuckets">
            <summary>Returns the X buckets</summary>
        </member>
        <member name="P:Euclid.Numerics.PartialDifferentialEquations.UnivariateGridConfiguration.XIncrements">
            <summary>Returns the X increments</summary>
        </member>
        <member name="T:Euclid.Numerics.PartialDifferentialEquations.BivariatePDE">
            <summary>Represents a bivariate partial derivative equation</summary>
        </member>
        <member name="M:Euclid.Numerics.PartialDifferentialEquations.BivariatePDE.#ctor(Euclid.Numerics.PartialDifferentialEquations.BivariateGridConfiguration)">
            <summary>Builds a Bivariate Partial Derivative Equation grid</summary>
            <param name="configuration">the grid configuration</param>
        </member>
        <member name="M:Euclid.Numerics.PartialDifferentialEquations.BivariatePDE.Value(System.Int32,System.Int32,System.Int32)">
            <summary>Returns the grid value for a given date, x index, and y index</summary>
            <param name="t">the date index</param>
            <param name="xIndex">the x index</param>
            <param name="yIndex">the y index</param>
            <returns>a double</returns>
        </member>
        <member name="F:Euclid.Numerics.PartialDifferentialEquations.BivariatePDE.VALUE">
            <summary>Index of the value matrix</summary>
        </member>
        <member name="F:Euclid.Numerics.PartialDifferentialEquations.BivariatePDE.XDERIVATIVE">
            <summary>Index of the x derivative matrix</summary>
        </member>
        <member name="F:Euclid.Numerics.PartialDifferentialEquations.BivariatePDE.YDERIVATIVE">
            <summary>Index of the y derivative matrix</summary>
        </member>
        <member name="F:Euclid.Numerics.PartialDifferentialEquations.BivariatePDE.XCONVEXITY">
            <summary>Index of the x second order derivative matrix</summary>
        </member>
        <member name="F:Euclid.Numerics.PartialDifferentialEquations.BivariatePDE.YCONVEXITY">
            <summary>Index of the y second order derivative matrix</summary>
        </member>
        <member name="F:Euclid.Numerics.PartialDifferentialEquations.BivariatePDE.XYCONVECITY">
            <summary>Index of the xy cross derivative matrix</summary>
        </member>
        <member name="M:Euclid.Numerics.PartialDifferentialEquations.BivariatePDE.Matrices(System.Int32)">
            <summary>Returns the value and spatial first and second order derivatives for a given date</summary>
            <param name="t">the date index</param>
            <returns>a set of <c>Matrix</c></returns>
        </member>
        <member name="M:Euclid.Numerics.PartialDifferentialEquations.BivariatePDE.Set(System.Int32,Euclid.Matrix)">
            <summary>Sets the grid value for a given date</summary>
            <param name="t">the date index</param>
            <param name="value">the value grid</param>
        </member>
        <member name="M:Euclid.Numerics.PartialDifferentialEquations.BivariatePDE.ExerciceFrontier(Euclid.Matrix,Euclid.Matrix)">
            <summary>Computes the exercice frontier</summary>
            <param name="expected">the expected value matrix</param>
            <param name="intrinsic">the intrinsic value matrix</param>
            <returns>a <c>Matrix</c></returns>
        </member>
        <member name="T:Euclid.Numerics.PartialDifferentialEquations.BivariateGridConfiguration">
            <summary>Represents a grid configuration for bivariate PDEs</summary>
        </member>
        <member name="M:Euclid.Numerics.PartialDifferentialEquations.BivariateGridConfiguration.#ctor(System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double})">
            <summary>Builds a bivariate EDP grid configuration</summary>
            <param name="tBuckets">the time buckets</param>
            <param name="xBuckets">the x-buckets</param>
            <param name="yBuckets">the y-buckets</param>
        </member>
        <member name="P:Euclid.Numerics.PartialDifferentialEquations.BivariateGridConfiguration.TimeCount">
            <summary>Returns the number of time buckets</summary>
        </member>
        <member name="P:Euclid.Numerics.PartialDifferentialEquations.BivariateGridConfiguration.TimeBuckets">
            <summary>Returns the time buckets</summary>
        </member>
        <member name="P:Euclid.Numerics.PartialDifferentialEquations.BivariateGridConfiguration.TimeIncrements">
            <summary>Returns the time increments</summary>
        </member>
        <member name="P:Euclid.Numerics.PartialDifferentialEquations.BivariateGridConfiguration.XCount">
            <summary>Returns the number of X buckets</summary>
        </member>
        <member name="P:Euclid.Numerics.PartialDifferentialEquations.BivariateGridConfiguration.XBuckets">
            <summary>Returns the X buckets</summary>
        </member>
        <member name="P:Euclid.Numerics.PartialDifferentialEquations.BivariateGridConfiguration.XIncrements">
            <summary>Returns the X increments</summary>
        </member>
        <member name="P:Euclid.Numerics.PartialDifferentialEquations.BivariateGridConfiguration.YCount">
            <summary>Returns the number of Y buckets</summary>
        </member>
        <member name="P:Euclid.Numerics.PartialDifferentialEquations.BivariateGridConfiguration.YBuckets">
            <summary>Returns the Y buckets</summary>
        </member>
        <member name="P:Euclid.Numerics.PartialDifferentialEquations.BivariateGridConfiguration.YIncrements">
            <summary>Returns the Y increments</summary>
        </member>
        <member name="T:Euclid.Numerics.PartialDifferentialEquations.UnivariatePDE">
            <summary>Represents a one-dimensional PDE</summary>
        </member>
        <member name="M:Euclid.Numerics.PartialDifferentialEquations.UnivariatePDE.#ctor(Euclid.Numerics.PartialDifferentialEquations.UnivariateGridConfiguration)">
            <summary>Builds a univariate PDE (1D)</summary>
            <param name="configuration">the grid configuration</param>
        </member>
        <member name="M:Euclid.Numerics.PartialDifferentialEquations.UnivariatePDE.Value(System.Int32,System.Int32)">
            <summary>Returns the grid value for a given date, x index</summary>
            <param name="t">the date index</param>
            <param name="xIndex">the x index</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Numerics.PartialDifferentialEquations.UnivariatePDE.Retropropagate(Euclid.Matrix,System.Int32,System.Int32)">
            <summary>
            Retropropagates for the given index to the previous step
            using the given matrix representation of the PDE operator
            </summary>
            <param name="operatorMatrix">the operator matrix</param>
            <param name="anteriorIndex">the index <b>to</b> which the data is retropropagated</param>
            <param name="posteriorIndex">the index <b>from</b> which the data is retropropagated</param>
        </member>
        <member name="P:Euclid.Numerics.PartialDifferentialEquations.UnivariatePDE.Item(System.Int32)">
            <summary>Sets the grid value for a given date</summary>
            <param name="t">the date index</param>
            <param name="value">the value grid</param>
        </member>
        <member name="T:Euclid.Optimizers.PatternSearch">
            <summary>Pattern search class</summary>
        </member>
        <member name="M:Euclid.Optimizers.PatternSearch.#ctor(System.Func{Euclid.Vector,System.Boolean},System.Func{Euclid.Vector,System.Double},Euclid.Vector,Euclid.Vector,Euclid.Optimizers.OptimizationType,System.Int32,System.Int32,System.Double,System.Double)">
            <summary>Builds a Particle Swarm Optimizer</summary>
            <param name="fitnessFunction">the function to optimize</param>
            <param name="feasabilityFunction">the feasability function</param>
            <param name="optimizationType">the optimization type</param>
            <param name="initialPoint">the initial point</param>
            <param name="shocks">the shocks' values</param>
            <param name="maxIterations">the maximum number of iterations</param>
            <param name="maxStaticIterations">the maximum number of static iterations</param>
            <param name="epsilon">the convergence threshold</param>
            <param name="shrinkageFactor">the shrinkage factor</param>
        </member>
        <member name="P:Euclid.Optimizers.PatternSearch.Epsilon">
            <summary>Gets the tolerance used to check if the optimization process is stationary</summary>
        </member>
        <member name="P:Euclid.Optimizers.PatternSearch.MaxIterations">
            <summary>Gets the maximum number of iterations allowed to the optimization process</summary>
        </member>
        <member name="P:Euclid.Optimizers.PatternSearch.MaxStaticIterations">
            <summary>Gets the maximum number of stationary iterations allowed to the optimization process</summary>
        </member>
        <member name="P:Euclid.Optimizers.PatternSearch.Status">
            <summary>Gets the current status of the optimization process</summary>
        </member>
        <member name="P:Euclid.Optimizers.PatternSearch.OptimizationType">
            <summary>Gets the type of optimization performed (min or max)</summary>
        </member>
        <member name="P:Euclid.Optimizers.PatternSearch.ShrinkageFactor">
            <summary>Gets the shrinkage factor</summary>
        </member>
        <member name="P:Euclid.Optimizers.PatternSearch.Result">
            <summary>The result of the solver</summary>
        </member>
        <member name="P:Euclid.Optimizers.PatternSearch.Convergence">
            <summary>Gets the details of the convergence (Vector, error)</summary>
        </member>
        <member name="M:Euclid.Optimizers.PatternSearch.Optimize(System.Boolean)">
            <summary>Optimizes the function using Pattern Search</summary>
        </member>
        <member name="T:Euclid.Optimizers.SimulatedAnnealing">
            <summary>Simulated annealing optimization class </summary>
        </member>
        <member name="M:Euclid.Optimizers.SimulatedAnnealing.#ctor(Euclid.Vector,System.Func{Euclid.Vector,System.Double},System.Func{Euclid.Vector,System.Boolean},System.Func{System.Int32,System.Double},System.Func{Euclid.Vector,Euclid.Vector},Euclid.Optimizers.OptimizationType,System.Int32)">
            <summary>Builds a solver using the simulated annealing method</summary>
            <param name="initialGuess">the initial guess</param>
            <param name="f">the function to optimize for</param>
            <param name="feasibility">defines the feasible territory</param>
            <param name="temperatureFunc">provides the cooling trajectory</param>
            <param name="neighbourGenerator">generates random neighbours</param>
            <param name="maxIterations">the maximum number of iterations</param>
            <param name="optimizationType">the optimization type</param>
        </member>
        <member name="P:Euclid.Optimizers.SimulatedAnnealing.Function">
            <summary>Gets and sets the function to solve for</summary>
        </member>
        <member name="P:Euclid.Optimizers.SimulatedAnnealing.InitialGuess">
            <summary>Gets and sets the initial guess</summary>
        </member>
        <member name="P:Euclid.Optimizers.SimulatedAnnealing.MaxIterations">
            <summary>Gets and sets the maximum number of iterations</summary>
        </member>
        <member name="P:Euclid.Optimizers.SimulatedAnnealing.TrackConvergence">
            <summary>Gets and sets whether the details of the convergence are tracked</summary>
        </member>
        <member name="P:Euclid.Optimizers.SimulatedAnnealing.Result">
            <summary> Gets the result of the solver</summary>
        </member>
        <member name="P:Euclid.Optimizers.SimulatedAnnealing.Convergence">
            <summary>Gets the details of the convergence (value, error)</summary>
        </member>
        <member name="M:Euclid.Optimizers.SimulatedAnnealing.Optimize">
            <summary>Optimizes the function</summary>
        </member>
        <member name="T:Euclid.Optimizers.GaussianHillClimb1D">
            <summary>Gaussian hill-climbing optimization  algorithm for a 1D function</summary>
        </member>
        <member name="M:Euclid.Optimizers.GaussianHillClimb1D.#ctor(System.Double,System.Func{System.Double,System.Double},System.Func{System.Double,System.Boolean},Euclid.Optimizers.OptimizationType,System.Double,System.Double,System.Int32)">
            <summary>Builds a solver using the simulated annealing method</summary>
            <param name="initialGuess">the initial guess</param>
            <param name="fitness">the function to solve for</param>
            <param name="feasibility">the feasibility function</param>
            <param name="sigma0">the initial standard deviation</param>
            <param name="gamma">the cooling down speed</param>
            <param name="iterations">the maximum number of iterations</param>
            <param name="optimizationType">the optimization type</param>
        </member>
        <member name="M:Euclid.Optimizers.GaussianHillClimb1D.#ctor(System.Double,System.Func{System.Double,System.Double},Euclid.Optimizers.OptimizationType,System.Double,System.Double,System.Double,System.Int32)">
            <summary>Builds a solver using the simulated annealing method</summary>
            <param name="initialGuess">the initial guess</param>
            <param name="fitness">the function to solve for</param>
            <param name="optimizationType">the optimization type</param>
            <param name="lowerBound">the lower bound of the searching scope</param>
            <param name="upperBound">the upper bound of the searching scope</param>
            <param name="tolerance">the final accuracy</param>
            <param name="iterations">the maximum number of iterations</param>
        </member>
        <member name="P:Euclid.Optimizers.GaussianHillClimb1D.Function">
            <summary>Gets and sets the function to solve for</summary>
        </member>
        <member name="P:Euclid.Optimizers.GaussianHillClimb1D.InitialGuess">
            <summary>Gets and sets the initial guess</summary>
        </member>
        <member name="P:Euclid.Optimizers.GaussianHillClimb1D.Iterations">
            <summary>Gets and sets the number of iterations</summary>
        </member>
        <member name="P:Euclid.Optimizers.GaussianHillClimb1D.TrackConvergence">
            <summary>Gets and sets whether the details of the convergence are tracked</summary>
        </member>
        <member name="P:Euclid.Optimizers.GaussianHillClimb1D.Result">
            <summary> Gets the result of the solver</summary>
        </member>
        <member name="P:Euclid.Optimizers.GaussianHillClimb1D.Convergence">
            <summary>Gets the details of the convergence (value, error)</summary>
        </member>
        <member name="M:Euclid.Optimizers.GaussianHillClimb1D.Optimize">
            <summary>Optimizes the function</summary>
        </member>
        <member name="T:Euclid.Optimizers.GradientDescent">
            <summary>Class used to perform a gradient descent on any multivariate function</summary>
        </member>
        <member name="M:Euclid.Optimizers.GradientDescent.#ctor(Euclid.Vector,Euclid.Optimizers.LineSearch,System.Func{Euclid.Vector,System.Double},Euclid.Optimizers.OptimizationType,System.Int32,System.Int32,System.Double)">
            <summary>Builds a GradientDescent helper</summary>
            <param name="initialGuess">the initial guess Vector</param>
            <param name="lineSearch">the line search method</param>
            <param name="function">the function to minimize</param>
            <param name="optimizationType">the optimization type</param>
            <param name="maxIterations">the maximum number of iterations in the gradient</param>
            <param name="maxLineSearchIterations">the maximum number of iterations in the line search</param>
            <param name="gradientNormThreshold">the threshold for the gradient norm</param>
        </member>
        <member name="M:Euclid.Optimizers.GradientDescent.#ctor(Euclid.Vector,Euclid.Optimizers.LineSearch,System.Func{Euclid.Vector,System.Double},System.Func{Euclid.Vector,Euclid.Vector},Euclid.Optimizers.OptimizationType,System.Int32,System.Int32,System.Double)">
            <summary>Gradient descent constructor</summary>
            <param name="initialGuess">the initial guess Vector</param>
            <param name="lineSearch">the line search method</param>
            <param name="function">the function to minimize</param>
            <param name="gradient">the gradient function to minimize</param>
            <param name="optimizationType">the optimization type</param>
            <param name="maxIterations">the maximum number of iterations in the gradient</param>
            <param name="maxLineSearchIterations">the maximum number of iterations in the line search</param>
            <param name="gradientNormThreshold">the threshold for the gradient norm</param>
        </member>
        <member name="M:Euclid.Optimizers.GradientDescent.#ctor(Euclid.Vector,Euclid.Optimizers.LineSearch,System.Func{Euclid.Vector,System.Double},System.Func{Euclid.Vector,Euclid.Vector},System.Func{Euclid.Vector,Euclid.Matrix},Euclid.Optimizers.OptimizationType,System.Int32,System.Int32,System.Double)">
            <summary>Gradient descent constructor</summary>
            <param name="initialGuess">the initial guess Vector</param>
            <param name="lineSearch">the line search method</param>
            <param name="function">the function to minimize</param>
            <param name="gradient">the gradient of the function to minimize</param>
            <param name="hessian">the hessian matrix of the function to minimize</param>
            <param name="optimizationType">the optimization type</param>
            <param name="maxIterations">the maximum number of iterations in the gradient</param>
            <param name="maxLineSearchIterations">the maximum number of iterations in the line search</param>
            <param name="gradientNormThreshold">the threshold for the gradient norm</param>
        </member>
        <member name="P:Euclid.Optimizers.GradientDescent.LineSearch">
            <summary>Gets and sets the line search method used to optimize the step</summary>
        </member>
        <member name="P:Euclid.Optimizers.GradientDescent.Function">
            <summary>Gets and sets the function to minimize</summary>
        </member>
        <member name="P:Euclid.Optimizers.GradientDescent.Status">
            <summary>The final status of the solver</summary>
        </member>
        <member name="P:Euclid.Optimizers.GradientDescent.Error">
            <summary> Returns the final value of the function</summary>
        </member>
        <member name="P:Euclid.Optimizers.GradientDescent.Result">
            <summary>The result of the solver</summary>
        </member>
        <member name="P:Euclid.Optimizers.GradientDescent.Convergence">
            <summary>Gets the details of the convergence (gradient norm, error)</summary>
        </member>
        <member name="P:Euclid.Optimizers.GradientDescent.Evaluations">
            <summary>Gets the number of times the function was evaluated </summary>
        </member>
        <member name="P:Euclid.Optimizers.GradientDescent.MaxIterations">
            <summary>Gets the maximum number of iterations </summary>
        </member>
        <member name="P:Euclid.Optimizers.GradientDescent.MaxLineSearchIterations">
            <summary>Gets the maxium number of iterations in the line search </summary>
        </member>
        <member name="P:Euclid.Optimizers.GradientDescent.OptimizationType">
            <summary>Gets the optimization type</summary>
        </member>
        <member name="M:Euclid.Optimizers.GradientDescent.Optimize(System.Double)">
            <summary>Minimizes the function using classic Gradient Descent algorithm</summary>
            <param name="momentum">the momentum of the descent</param>
        </member>
        <member name="M:Euclid.Optimizers.GradientDescent.OptimizeBFGS">
            <summary>Minimizes the function using the BFGS gradient descent</summary>
        </member>
        <member name="M:Euclid.Optimizers.GradientDescent.OptimizeConjugate">
            <summary>Optimizes the function using the conjugate gradient descent</summary>
        </member>
        <member name="M:Euclid.Optimizers.GradientDescent.OptimizeUnderBoxConstraint(System.Double,Euclid.Vector,Euclid.Vector)">
            <summary>Optimizes the function using classic Gradient Descent inside a box</summary>
            <param name="momentum">the momentum of the descent</param>
            <param name="lowBound">the lower bounds of the box</param>
            <param name="upBound">the upper bounds of the box</param>
        </member>
        <member name="M:Euclid.Optimizers.GradientDescent.ConstrainedDirection(Euclid.Vector,Euclid.Vector,Euclid.Vector,Euclid.Vector)">
            <summary>Returns a corrected version of the descent direction in order to avoid breaching the box constraints</summary>
            <param name="x">the position</param>
            <param name="d">the direction</param>
            <param name="l">the upper bound</param>
            <param name="u">the lower bound</param>
            <returns>a <c>Vector</c></returns>
        </member>
        <member name="T:Euclid.Optimizers.LineSearch">
            <summary>Line search methods used for the gradient descent</summary>
        </member>
        <member name="F:Euclid.Optimizers.LineSearch.Naive">
            <summary>Naïve line search by dividing the alpha until the functional is lowered</summary>
        </member>
        <member name="F:Euclid.Optimizers.LineSearch.Lowest">
            <summary>Line search by finding the lowest point in all the powers of the alpha factor</summary>
        </member>
        <member name="F:Euclid.Optimizers.LineSearch.Armijo">
            <summary>Armijo criteria</summary>
        </member>
        <member name="F:Euclid.Optimizers.LineSearch.ArmijoGoldStein">
            <summary>Armijo Goldstein criteria </summary>
        </member>
        <member name="F:Euclid.Optimizers.LineSearch.StrongWolfe">
            <summary>Strong Wolfe criteria </summary>
        </member>
        <member name="T:Euclid.Optimizers.OptimizationType">
            <summary>The type of optimization</summary>
        </member>
        <member name="F:Euclid.Optimizers.OptimizationType.Min">
            <summary>Minimization</summary>
        </member>
        <member name="F:Euclid.Optimizers.OptimizationType.Max">
            <summary>Maximization</summary>
        </member>
        <member name="T:Euclid.Optimizers.NelderMead">
            <summary>Nelder-Mead optimization class</summary>
        </member>
        <member name="M:Euclid.Optimizers.NelderMead.#ctor(System.Func{Euclid.Vector,System.Boolean},System.Func{Euclid.Vector,System.Double},System.Collections.Generic.IEnumerable{Euclid.Vector},Euclid.Optimizers.OptimizationType,System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Builds a Nelder Mead optimizer</summary>
            <param name="feasibility">the feasibility function</param>
            <param name="function">the function to optimize</param>
            <param name="optimizationType">the optimization type</param>
            <param name="initialSimplex">the initial population</param>
            <param name="maxIterations">the maximum number of iterations</param>
            <param name="epsilon">the convergence threshold</param>
            <param name="alpha">the reflection coefficient</param>
            <param name="gamma">the expansion coefficient</param>
            <param name="rho">the contaction coefficient</param>
            <param name="sigma">the shrink coefficient</param>
        </member>
        <member name="P:Euclid.Optimizers.NelderMead.Epsilon">
            <summary>Gets the tolerance used to check if the optimization process is stationary</summary>
        </member>
        <member name="P:Euclid.Optimizers.NelderMead.MaxIterations">
            <summary>Gets the maximum number of iterations allowed to the optimization process</summary>
        </member>
        <member name="P:Euclid.Optimizers.NelderMead.Status">
            <summary>Gets the current status of the optimization process</summary>
        </member>
        <member name="P:Euclid.Optimizers.NelderMead.OptimizationType">
            <summary>Gets the type of optimization performed (min or max)</summary>
        </member>
        <member name="P:Euclid.Optimizers.NelderMead.Dimension">
            <summary> Returns the problem's dimension</summary>
        </member>
        <member name="P:Euclid.Optimizers.NelderMead.Alpha">
            <summary>Returns the reflexion coefficient</summary>
        </member>
        <member name="P:Euclid.Optimizers.NelderMead.Gamma">
            <summary>Returns the expansion coefficient</summary>
        </member>
        <member name="P:Euclid.Optimizers.NelderMead.Rho">
            <summary>Returns the contraction coefficient</summary>
        </member>
        <member name="P:Euclid.Optimizers.NelderMead.Sigma">
            <summary>Returns the shrink coefficient</summary>
        </member>
        <member name="P:Euclid.Optimizers.NelderMead.Result">
            <summary>The result of the solver</summary>
        </member>
        <member name="P:Euclid.Optimizers.NelderMead.Convergence">
            <summary>Gets the details of the convergence (Vector, error)</summary>
        </member>
        <member name="T:Euclid.Optimizers.NelderMead.VectorValuePair">
            <summary>Minimizes the function using the Nelder Mead algorithm</summary>
        </member>
        <member name="M:Euclid.Optimizers.NelderMead.Optimize">
            <summary>Minimizes the function</summary>
        </member>
        <member name="T:Euclid.Optimizers.DifferentialEvolutionOptimizer">
            <summary>Optimizes a function on a space using Differential Evolution</summary>
        </member>
        <member name="M:Euclid.Optimizers.DifferentialEvolutionOptimizer.#ctor(System.Collections.Generic.IEnumerable{Euclid.Vector},Euclid.Optimizers.OptimizationType,System.Func{Euclid.Vector,System.Double},System.Func{Euclid.Vector,System.Boolean},System.Int32,System.Double,System.Double)">
            <summary>Builds a differential evolution optimizer for a constrained space</summary>
            <param name="initialPopulation">the initial population of agents</param>
            <param name="optimizationType">the optimization type (maximize or minimize)</param>
            <param name="fitnessFunction">the fitness function</param>
            <param name="feasabilityFunction">the feasability function</param>
            <param name="maxIterations">the maximum iterations</param>
            <param name="crossoverProbability">the crossover probability (handles the frequency of crossover)</param>
            <param name="differentialWeight">the differential weight (handles the intensity of mutation)</param>
        </member>
        <member name="M:Euclid.Optimizers.DifferentialEvolutionOptimizer.#ctor(System.Collections.Generic.IEnumerable{Euclid.Vector},Euclid.Optimizers.OptimizationType,System.Func{Euclid.Vector,System.Double},System.Int32,System.Double,System.Double)">
            <summary>Builds a differential evolution optimizer for a constrained space</summary>
            <param name="initialPopulation">the initial population of agents</param>
            <param name="optimizationType">the optimization type (maximize or minimize)</param>
            <param name="fitnessFunction">the fitness function</param>
            <param name="maxIterations">the maximum iterations</param>
            <param name="crossoverProbability">the crossover probability (handles the frequency of crossover)</param>
            <param name="differentialWeight">the differential weight (handles the intensity of mutation)</param>
        </member>
        <member name="P:Euclid.Optimizers.DifferentialEvolutionOptimizer.MaxIterations">
            <summary>Gets the maximum number of iterations allowed to the optimization process</summary>
        </member>
        <member name="P:Euclid.Optimizers.DifferentialEvolutionOptimizer.Status">
            <summary>Gets the current status of the optimization process</summary>
        </member>
        <member name="P:Euclid.Optimizers.DifferentialEvolutionOptimizer.OptimizationType">
            <summary>Gets the type of optimization performed (min or max)</summary>
        </member>
        <member name="P:Euclid.Optimizers.DifferentialEvolutionOptimizer.CrossoverProbability">
            <summary>Returns the crossover probability</summary>
        </member>
        <member name="P:Euclid.Optimizers.DifferentialEvolutionOptimizer.DifferentialWeight">
            <summary>Returns the differential weight</summary>
        </member>
        <member name="P:Euclid.Optimizers.DifferentialEvolutionOptimizer.Result">
            <summary>The result of the solver</summary>
        </member>
        <member name="P:Euclid.Optimizers.DifferentialEvolutionOptimizer.Convergence">
            <summary>Gets the details of the convergence (Vector, error)</summary>
        </member>
        <member name="M:Euclid.Optimizers.DifferentialEvolutionOptimizer.Optimize(System.Boolean)">
            <summary>Optimizes the fitness function using Differential Evolution</summary>
        </member>
        <member name="T:Euclid.Optimizers.ParticleSwarmOptimizer">
            <summary>Particle Swarm Optimization class</summary>
        </member>
        <member name="M:Euclid.Optimizers.ParticleSwarmOptimizer.#ctor(System.Func{Euclid.Vector,System.Boolean},System.Func{Euclid.Vector,System.Double},System.Collections.Generic.IEnumerable{Euclid.Vector},Euclid.Optimizers.OptimizationType,System.Int32,System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Builds a Particle Swarm Optimizer</summary>
            <param name="function">the function to optimize</param>
            <param name="feasability">the feasability function</param>
            <param name="optimizationType">the optimization type</param>
            <param name="initialPopulation">a generator of seed vectors</param>
            <param name="maxIterations">the maximum number of iterations</param>
            <param name="maxStaticIterations">the maximum number of static iterations</param>
            <param name="epsilon">the convergence threshold</param>
            <param name="attractionToParticleBest">the attraction to particle best factor</param>
            <param name="attractionToOverallBest">the attraction to overall best factor</param>
            <param name="velocityInertia">the velocity inertia</param>
            <param name="shrinkageFactor">the shrinkage factor</param>
        </member>
        <member name="M:Euclid.Optimizers.ParticleSwarmOptimizer.#ctor(System.Func{Euclid.Vector,System.Double},System.Collections.Generic.IEnumerable{Euclid.Vector},Euclid.Optimizers.OptimizationType,System.Int32,System.Int32,System.Double,System.Double,System.Double,System.Double)">
            <summary>Builds a Particle Swarm Optimizer</summary>
            <param name="function">the function to optimize</param>
            <param name="optimizationType">the optimization type</param>
            <param name="initialPopulation">a generator of seed vectors</param>
            <param name="maxIterations">the maximum number of iterations</param>
            <param name="maxStaticIterations">the maximum number of static iterations</param>
            <param name="epsilon">the convergence threshold</param>
            <param name="attractionToParticleBest">the attraction to particle best factor</param>
            <param name="attractionToOverallBest">the attraction to overall best factor</param>
            <param name="velocityInertia">the velocity inertia</param>
        </member>
        <member name="P:Euclid.Optimizers.ParticleSwarmOptimizer.Epsilon">
            <summary>Gets the tolerance used to check if the optimization process is stationary</summary>
        </member>
        <member name="P:Euclid.Optimizers.ParticleSwarmOptimizer.MaxIterations">
            <summary>Gets the maximum number of iterations allowed to the optimization process</summary>
        </member>
        <member name="P:Euclid.Optimizers.ParticleSwarmOptimizer.MaxStaticIterations">
            <summary>Gets the maximum number of stationary iterations allowed to the optimization process</summary>
        </member>
        <member name="P:Euclid.Optimizers.ParticleSwarmOptimizer.Status">
            <summary>Gets the current status of the optimization process</summary>
        </member>
        <member name="P:Euclid.Optimizers.ParticleSwarmOptimizer.OptimizationType">
            <summary>Gets the type of optimization performed (min or max)</summary>
        </member>
        <member name="P:Euclid.Optimizers.ParticleSwarmOptimizer.SwarmSize">
            <summary> Gets the size of the swarm</summary>
        </member>
        <member name="P:Euclid.Optimizers.ParticleSwarmOptimizer.VelocityInertia">
            <summary>Gets the inertia applied to the velocity</summary>
        </member>
        <member name="P:Euclid.Optimizers.ParticleSwarmOptimizer.AttractionToParticleBest">
            <summary>Gets the attraction to particle best</summary>
        </member>
        <member name="P:Euclid.Optimizers.ParticleSwarmOptimizer.AttractionToOverallBest">
            <summary>Gets the attraction to overall best</summary>
        </member>
        <member name="P:Euclid.Optimizers.ParticleSwarmOptimizer.Result">
            <summary>The result of the solver</summary>
        </member>
        <member name="P:Euclid.Optimizers.ParticleSwarmOptimizer.Convergence">
            <summary>Gets the details of the convergence (Vector, error)</summary>
        </member>
        <member name="M:Euclid.Optimizers.ParticleSwarmOptimizer.Optimize(System.Boolean)">
            <summary>Optimizes the function using Particle Swarm Optimization</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Euclid.Overfitting.SharpeStats" -->
        <!-- Badly formed XML comment ignored for member "M:Euclid.Overfitting.SharpeStats.ComputePSR(System.Double,System.Double,System.Double,System.Int32,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:Euclid.Overfitting.SharpeStats.ComputeMinTRL(System.Double,System.Double,System.Double,System.Int32,System.Double,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:Euclid.Overfitting.SharpeStats.ComputeDSR(System.Double,System.Double,System.Double,System.Int32,System.Double,System.Double)" -->
        <member name="T:Euclid.Polynomial">
            <summary>
            Standard polynomial
            </summary>
        </member>
        <member name="M:Euclid.Polynomial.#ctor(System.Int32)">
            <summary>
            Builds a polynomial with no coefficients except the highest
            </summary>
            <param name="degree">the polynomial's degree</param>
        </member>
        <member name="M:Euclid.Polynomial.#ctor(System.Collections.Generic.IList{System.Double})">
            <summary>
            Builds a polynomial through the coefficients
            </summary>
            <param name="terms">the coefficients of the polynomial</param>
        </member>
        <member name="M:Euclid.Polynomial.#ctor(System.Double[])">
            <summary>
            Builds a <c>Polynomial</c> from a list of coefficients
            </summary>
            <param name="coefficients">the coefficients</param>
        </member>
        <member name="M:Euclid.Polynomial.Normalize">
            <summary>
            Divides all the terms by the leading term so the polynomial has one(1) as leading term
            </summary>
        </member>
        <member name="M:Euclid.Polynomial.Evaluate(System.Double)">
            <summary>
            Evaluates the polynomial's value for a given value
            </summary>
            <param name="x">The value for which the polynomial is evaluated</param>
            <returns></returns>
        </member>
        <member name="M:Euclid.Polynomial.Evaluate(Euclid.Complex)">
            <summary>Evaluates the polynomial's value for a given complex value</summary>
            <param name="x">the argument</param>
            <returns>a <c>Complex</c></returns>
        </member>
        <member name="M:Euclid.Polynomial.ComplexRoots">
            <summary>
            Computes the roots of polynomial p via Weierstrass iteration.
            </summary>
            <returns>the complex roots of the <c>Polynomial</c></returns>
        </member>
        <member name="M:Euclid.Polynomial.Roots">
            <summary>
            Computes the real roots of the <c>Polynomial</c>
            </summary>
            <returns>a list of double</returns>
        </member>
        <member name="M:Euclid.Polynomial.Equals(Euclid.Polynomial)">
            <summary>Verifies the equality between two Polynomials</summary>
            <param name="other">the other Polynomial</param>
            <returns><c>true</c> if they are equal, <c>false</c> otherwise</returns>
        </member>
        <member name="P:Euclid.Polynomial.Item(System.Int32)">
            <summary>Accesses the terms of the polynomial</summary>
            <param name="i">the index</param>
            <returns>a term of the polynomial</returns>
        </member>
        <member name="P:Euclid.Polynomial.Degree">
            <summary>Returns the polynomial's degree</summary>
        </member>
        <member name="P:Euclid.Polynomial.Derivative">
            <summary>Returns the derivative polynomial (one degree less)</summary>
        </member>
        <member name="M:Euclid.Polynomial.ToString">
            <summary>Returns a string representing the polynomial</summary>
            <returns>a <c>string</c></returns>
        </member>
        <member name="M:Euclid.Polynomial.ToString(System.String)">
            <summary>
            Returns a string representing the polynomial
            </summary>
            <param name="format">the format for all coefficients</param>
            <returns>a <c>String</c></returns>
        </member>
        <member name="P:Euclid.Polynomial.Clone">
            <summary>
            Returns a deep copy of the polynomial
            </summary>
        </member>
        <member name="M:Euclid.Polynomial.op_Multiply(Euclid.Polynomial,System.Double)">
            <summary>Multiplies a polynomial by a scalar</summary>
            <param name="p">the <c>Polynomial</c></param>
            <param name="f">the scalar</param>
            <returns>a <c>Polynomial</c></returns>
        </member>
        <member name="M:Euclid.Polynomial.op_Multiply(System.Double,Euclid.Polynomial)">
            <summary>Multiplies a polynomial by a scalar</summary>
            <param name="f">the scalar</param>
            <param name="p">the <c>Polynomial</c></param>
            <returns>a <c>Polynomial</c></returns>
        </member>
        <member name="M:Euclid.Polynomial.op_Multiply(Euclid.Polynomial,Euclid.Polynomial)">
            <summary> multiplies two polynomials </summary>
            <param name="p1">the left hand side</param>
            <param name="p2">the right hand side</param>
            <returns>the <c>Polynomial</c> result of the polynomial</returns>
        </member>
        <member name="M:Euclid.Polynomial.op_ExclusiveOr(Euclid.Polynomial,System.Int32)">
            <summary>Raises a Polynomial to an integer power</summary>
            <param name="p">the Polynomial</param>
            <param name="n">the power</param>
            <returns>a <c>Polynomial</c></returns>
        </member>
        <member name="M:Euclid.Polynomial.Add(Euclid.Polynomial,Euclid.Polynomial)">
            <summary>
            Performs a polynomial addition
            </summary>
            <param name="p1">First matrix</param>
            <param name="p2">Second matrix</param>
            <returns>The sum of m1 and m2</returns>
        </member>
        <member name="M:Euclid.Polynomial.op_Addition(Euclid.Polynomial,System.Double)">
            <summary>
            Adds a polynomial to a scalar
            </summary>
            <param name="p">the polynomial left hand side</param>
            <param name="c">the scalar right hand side</param>
            <returns>the <c>Polynomial</c> result of the adition</returns>
        </member>
        <member name="M:Euclid.Polynomial.op_Addition(System.Double,Euclid.Polynomial)">
            <summary>
            Adds a polynomial to a scalar
            </summary>
            <param name="c">the scalar left hand side</param>
            <param name="p">the polynomial right hand side</param>
            <returns>the <c>Polynomial</c> result of the addition</returns>
        </member>
        <member name="M:Euclid.Polynomial.op_Subtraction(Euclid.Polynomial,System.Double)">
            <summary>Substracts a scalar to a <c>Polynomial</c></summary>
            <param name="p">the <c>Polynomial</c></param>
            <param name="c">the scalar</param>
            <returns>a <c>Polynomial</c></returns>
        </member>
        <member name="M:Euclid.Polynomial.op_Subtraction(System.Double,Euclid.Polynomial)">
            <summary>Substracts a <c>Polynomial to a scalar</c></summary>
            <param name="c">the scalar left hand side</param>
            <param name="p">the <c>Polynomial</c> right hand side</param>
            <returns>a <c>Polynomial</c></returns>
        </member>
        <member name="M:Euclid.Polynomial.op_UnaryNegation(Euclid.Polynomial)">
            <summary>Returns the opposite of the <c>Polynomial</c></summary>
            <param name="p">the <c>Polynomial</c></param>
            <returns>a <c>Polynomial</c></returns>
        </member>
        <member name="M:Euclid.Polynomial.op_Addition(Euclid.Polynomial,Euclid.Polynomial)">
            <summary>
            Adds two polynomials
            </summary>
            <param name="p1">the left hand side</param>
            <param name="p2">the right hand side</param>
            <returns>the <c>Polynomial</c> result of the addition</returns>
        </member>
        <member name="M:Euclid.Polynomial.op_Subtraction(Euclid.Polynomial,Euclid.Polynomial)">
            <summary>
            Substracts one polynomial to another
            </summary>
            <param name="p1">the left hand side</param>
            <param name="p2">the right hand side</param>
            <returns>the <c>Polynomial</c> result of the substraction </returns>
        </member>
        <member name="M:Euclid.Polynomial.Power(Euclid.Polynomial,System.Int32)">
            <summary>
            Evaluates the Polynomial raised to a power specified by pow.
            </summary>
            <param name="p">the <c>Polynomial</c> target</param>
            <param name="pow">The power we want to raise the Polynomial to</param>
            <returns>The Polynomial, raised to the power pow</returns>
        </member>
        <member name="T:Euclid.Search.BinarySearch">
            <summary>
            Class which modelizes a glossary of methods that used binary search algorithm
            </summary>
        </member>
        <member name="M:Euclid.Search.BinarySearch.FindFirstIndexOf``1(System.Collections.Generic.IReadOnlyList{``0},System.Func{``0,System.Boolean},System.Nullable{System.UInt32},System.Nullable{System.UInt32})">
            <summary>
            Binary search to find the first index that satisfying a predicate from the items
            </summary>
            <typeparam name="T">TYpe of item</typeparam>
            <param name="items">Collection of items</param>
            <param name="predicate">Predicate</param>
            <param name="startRange">The starting index of the range to search</param>
            <param name="endRange">The ending index of the range to search</param>
            <returns>The first index that satisfying the predicate else -1</returns>
        </member>
        <member name="M:Euclid.Search.BinarySearch.FindLastIndexOf``1(System.Collections.Generic.IReadOnlyList{``0},System.Func{``0,System.Boolean},System.Nullable{System.UInt32},System.Nullable{System.UInt32})">
            <summary>
            Binary search to find the first index that satisfying a predicate from the items
            </summary>
            <typeparam name="T">TYpe of item</typeparam>
            <param name="items">Collection of items</param>
            <param name="predicate">Predicate</param>
            <param name="startRange">The starting index of the range to search</param>
            <param name="endRange">The ending index of the range to search</param>
            <returns>The first index that satisfying the predicate else -1</returns>
        </member>
        <member name="T:Euclid.Serialization.CsvHelper">
            <summary>
            CSV Helper
            </summary>
        </member>
        <member name="F:Euclid.Serialization.CsvHelper.Separator">
            <summary>The culture's list separator</summary>
        </member>
        <member name="M:Euclid.Serialization.CsvHelper.CsvContent(System.String,System.String)">
            <summary>Parses a Csv to a jagged array</summary>
            <param name="fileName"></param>
            <param name="separator"></param>
            <returns></returns>
        </member>
        <member name="M:Euclid.Serialization.CsvHelper.IsWellFormed(System.String[][])">
            <summary>Checks if the data read in the CSV is well formed (i.e. the jagged array is rectangular)</summary>
            <param name="data">the jagged array</param>
            <returns><c>true</c> if all subarrays have the same size</returns>
        </member>
        <member name="T:Euclid.Serialization.IXmlable">
            <summary>Interface allowing serialization to an XML files</summary>
        </member>
        <member name="M:Euclid.Serialization.IXmlable.ToXml(System.Xml.XmlWriter)">
            <summary>Serializes a class to Xml </summary>
            <param name="writer">the <c>XmlWriter</c></param>
        </member>
        <member name="T:Euclid.Serialization.ICSVable">
            <summary>
            Interface allowing serialization and de-serialization from/to CSV files
            </summary>
        </member>
        <member name="M:Euclid.Serialization.ICSVable.ToCSV(System.String)">
            <summary>Builds a string representation of the content of the class </summary>
            <param name="separator">Column separator</param>
            <returns>a <c>String</c></returns>
        </member>
        <member name="T:Euclid.Serialization.TextHelper">
            <summary>uncomplete helper class</summary>
        </member>
        <member name="M:Euclid.Serialization.TextHelper.ToShortString(System.TimeSpan)">
            <summary>Serializes a TimeSpan</summary>
            <param name="timeSpan">the time span</param>
            <returns>a string</returns>
        </member>
        <member name="T:Euclid.Serialization.XmlHelper">
            <summary>Helper class for IXmlable classes</summary>
        </member>
        <member name="M:Euclid.Serialization.XmlHelper.SaveXml(Euclid.Serialization.IXmlable,System.String)">
            <summary>Saves the class' XML representation</summary>
            <param name="xmlable">the IXmlable class</param>
            <param name="filePath">the target file path</param>
        </member>
        <member name="M:Euclid.Serialization.XmlHelper.GetXml(Euclid.Serialization.IXmlable)">
            <summary>Writes the class'XML representation to a string</summary>
            <param name="xmlable">the IXmlable class</param>
            <returns>a string</returns>
        </member>
        <member name="M:Euclid.Serialization.XmlHelper.ReadXml(System.String)">
            <summary>Reads a file to an XMl node </summary>
            <param name="filePath">the target file</param>
            <returns>an <c>XmlNode</c></returns>
        </member>
        <member name="M:Euclid.Serialization.XmlHelper.ToEuclidDateString(System.DateTime)">
            <summary>Serializes a date to Euclid's specific date format </summary>
            <param name="date">the date</param>
            <returns>a string</returns>
        </member>
        <member name="M:Euclid.Serialization.XmlHelper.FromEuclidDateString(System.String)">
            <summary>De-serializes a string to a date </summary>
            <param name="text">the text to convert to a date</param>
            <returns>a DateTime</returns>
        </member>
        <member name="T:Euclid.Serialization.BuildList`1">
            <summary>Helps building a list of objects from their serialized representation</summary>
            <typeparam name="T">the object type</typeparam>
        </member>
        <member name="M:Euclid.Serialization.BuildList`1.FromXmls(System.Xml.XmlNodeList,System.Func{System.Xml.XmlNode,`0})">
            <summary>Builds a list of objects from an XML node list</summary>
            <param name="nodeList">the node list</param>
            <param name="builder">the function that turns an XML node into an instance of an object </param>
            <returns>a list of objects</returns>
        </member>
        <member name="T:Euclid.Solvers.Descents">
            <summary>
            Default thresholds for iterative solvers
            </summary>
        </member>
        <member name="F:Euclid.Solvers.Descents.ERR_EPSILON">
            <summary>Default absolute tolerance for the solvers </summary>
        </member>
        <member name="F:Euclid.Solvers.Descents.GRADIENT_EPSILON">
            <summary>Default tolerance for gradients and derivatives </summary>
        </member>
        <member name="F:Euclid.Solvers.Descents.STEP_EPSILON">
            <summary>Default increment </summary>
        </member>
        <member name="T:Euclid.Solvers.EndCriteria">
            <summary>
            Class used to specify the end criterion or criteria for all iterative optimisation classes
            </summary>
        </member>
        <member name="M:Euclid.Solvers.EndCriteria.#ctor(System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Nullable{System.Double})">
            <summary>End criteria constructor</summary>
            <param name="maxIterations">the maximum number of iterations</param>
            <param name="maxStaticIterations">the maximum number of iterations without substancial change</param>
            <param name="functionEpsilon">the error tolerance (beyond that value, convergence is assumed)</param>
            <param name="gradientEpsilon">the gradient tolerance (beyond that value, convergence is assumed)</param>
        </member>
        <member name="M:Euclid.Solvers.EndCriteria.ShouldStop(System.Double,System.Double)">
            <summary>Specifies whether the end criteria are met for the current value</summary>
            <param name="value">the current value of the optimized function</param>
            <param name="gradient">the current gradient norm of the optimized function</param>
            <returns>a boolean</returns>
        </member>
        <member name="M:Euclid.Solvers.EndCriteria.ShouldStop(System.Double)">
            <summary>Specifies whether the end criteria are met for the current value</summary>
            <param name="value">the current value of the optimizated function</param>
            <returns>a boolean</returns>
        </member>
        <member name="M:Euclid.Solvers.EndCriteria.ShouldStop">
            <summary>Specifies whether the end criteria are met for the current value</summary>
            <returns>a boolean</returns>
        </member>
        <member name="P:Euclid.Solvers.EndCriteria.Status">
            <summary>Gets the current status of the optimization controlled by this end criteria</summary>
        </member>
        <member name="T:Euclid.Solvers.ISingleVariableSolver">
            <summary>
            Interface for single variable solvers
            </summary>
        </member>
        <member name="P:Euclid.Solvers.ISingleVariableSolver.Function">
            <summary>Gets and sets the function to solve for</summary>
        </member>
        <member name="P:Euclid.Solvers.ISingleVariableSolver.Status">
            <summary>Gets the solver's status</summary>
        </member>
        <member name="P:Euclid.Solvers.ISingleVariableSolver.MaxIterations">
            <summary>Gets and sets the maximum number of iterations</summary>
        </member>
        <member name="P:Euclid.Solvers.ISingleVariableSolver.Result">
            <summary>Gets the result</summary>
        </member>
        <member name="P:Euclid.Solvers.ISingleVariableSolver.Error">
            <summary>Gets the final error</summary>
        </member>
        <member name="P:Euclid.Solvers.ISingleVariableSolver.Convergence">
            <summary>Gets the convergence path</summary>
        </member>
        <member name="M:Euclid.Solvers.ISingleVariableSolver.Solve">
            <summary> Solves for the given function, parameters and initial conditions, target set @ 0</summary>
        </member>
        <member name="M:Euclid.Solvers.ISingleVariableSolver.Solve(System.Double)">
            <summary>Solves for the given function, parameters, initial conditions and target</summary>
            <param name="target">the target value for the function</param>
        </member>
        <member name="T:Euclid.Solvers.SingleVariableSolver.BrentMethod">
            <summary>Finds a root using the Brent method</summary>
        </member>
        <member name="M:Euclid.Solvers.SingleVariableSolver.BrentMethod.#ctor(System.Double,System.Double,System.Func{System.Double,System.Double},System.Int32)">
            <summary>Builds a solver using the Brent method</summary>
            <param name="initialLowerBound">the lower bound of the initial interval</param>
            <param name="initialUpperBound">the upper bound of the initial interval</param>
            <param name="f">the function to solve for</param>
            <param name="maxIterations">the maximum number of iterations</param>
        </member>
        <member name="P:Euclid.Solvers.SingleVariableSolver.BrentMethod.Function">
            <summary>Gets and sets the function to solve for</summary>
        </member>
        <member name="P:Euclid.Solvers.SingleVariableSolver.BrentMethod.LowerBound">
            <summary>Gets and sets the lower bound of the interval</summary>
        </member>
        <member name="P:Euclid.Solvers.SingleVariableSolver.BrentMethod.UpperBound">
            <summary>Gets and sets the upper bound of the interval</summary>
        </member>
        <member name="P:Euclid.Solvers.SingleVariableSolver.BrentMethod.MaxIterations">
            <summary>Gets and sets the maximum number of iterations</summary>
        </member>
        <member name="P:Euclid.Solvers.SingleVariableSolver.BrentMethod.AbsoluteTolerance">
            <summary>Gets and sets the tolerance for the target (threshold for target reached)</summary>
        </member>
        <member name="P:Euclid.Solvers.SingleVariableSolver.BrentMethod.SlopeTolerance">
            <summary>Gets and sets the tolerance for the slope (threshold for stationarity)</summary>
        </member>
        <member name="P:Euclid.Solvers.SingleVariableSolver.BrentMethod.TrackConvergence">
            <summary>Gets and sets whether the details of the convergence are tracked</summary>
        </member>
        <member name="P:Euclid.Solvers.SingleVariableSolver.BrentMethod.Error">
            <summary>Returns the final error</summary>
        </member>
        <member name="P:Euclid.Solvers.SingleVariableSolver.BrentMethod.Status">
            <summary>Gets The final status of the solver</summary>
        </member>
        <member name="P:Euclid.Solvers.SingleVariableSolver.BrentMethod.Result">
            <summary> Gets the result of the solver</summary>
        </member>
        <member name="P:Euclid.Solvers.SingleVariableSolver.BrentMethod.Convergence">
            <summary>Gets the details of the convergence (value, error)</summary>
        </member>
        <member name="M:Euclid.Solvers.SingleVariableSolver.BrentMethod.Solve">
            <summary>Solves the equation f(x)=0 using the Newton-Raphson method</summary>
        </member>
        <member name="M:Euclid.Solvers.SingleVariableSolver.BrentMethod.Solve(System.Double)">
            <summary>Solve the equation f(x)=target using the Newton-Raphson method</summary>
            <param name="target">the target</param>
        </member>
        <member name="T:Euclid.Solvers.SingleVariableSolver.NewtonRaphson">
            <summary>
            Finds a root using the Newton-Raphson method
            </summary>
        </member>
        <member name="M:Euclid.Solvers.SingleVariableSolver.NewtonRaphson.#ctor(System.Double,System.Func{System.Double,System.Double},System.Func{System.Double,System.Double},System.Int32)">
            <summary>Builds a solver using the Newton-Raphson method</summary>
            <param name="initialGuess">the initial guess</param>
            <param name="f">the function to solve for</param>
            <param name="df">the derivative of the function to solve for</param>
            <param name="maxIterations">the maximum number of iterations</param>
        </member>
        <member name="M:Euclid.Solvers.SingleVariableSolver.NewtonRaphson.#ctor(System.Double,System.Func{System.Double,System.Double},System.Int32)">
            <summary>Builds a solver using the Newton-Raphson method</summary>
            <param name="initialGuess">the initial guess</param>
            <param name="f">the function to solve for</param>
            <param name="maxIterations">the maximum number of iterations</param>
        </member>
        <member name="P:Euclid.Solvers.SingleVariableSolver.NewtonRaphson.Function">
            <summary>Gets and sets the function to solve for</summary>
        </member>
        <member name="P:Euclid.Solvers.SingleVariableSolver.NewtonRaphson.InitialGuess">
            <summary>Gets and sets the initial guess</summary>
        </member>
        <member name="P:Euclid.Solvers.SingleVariableSolver.NewtonRaphson.MaxIterations">
            <summary>Gets and sets the maximum number of iterations</summary>
        </member>
        <member name="P:Euclid.Solvers.SingleVariableSolver.NewtonRaphson.AbsoluteTolerance">
            <summary>Gets and sets the tolerance for the target (threshold for target reached)</summary>
        </member>
        <member name="P:Euclid.Solvers.SingleVariableSolver.NewtonRaphson.SlopeTolerance">
            <summary>Gets and sets the tolerance for the slope (threshold for stationarity)</summary>
        </member>
        <member name="P:Euclid.Solvers.SingleVariableSolver.NewtonRaphson.TrackConvergence">
            <summary>Gets and sets whether the details of the convergence are tracked</summary>
        </member>
        <member name="P:Euclid.Solvers.SingleVariableSolver.NewtonRaphson.Error">
            <summary>Returns the final error</summary>
        </member>
        <member name="P:Euclid.Solvers.SingleVariableSolver.NewtonRaphson.Status">
            <summary>Gets The final status of the solver</summary>
        </member>
        <member name="P:Euclid.Solvers.SingleVariableSolver.NewtonRaphson.Result">
            <summary> Gets the result of the solver</summary>
        </member>
        <member name="P:Euclid.Solvers.SingleVariableSolver.NewtonRaphson.Convergence">
            <summary>Gets the details of the convergence (value, error)</summary>
        </member>
        <member name="M:Euclid.Solvers.SingleVariableSolver.NewtonRaphson.Solve">
            <summary>Solves the equation f(x)=0 using the Newton-Raphson method</summary>
        </member>
        <member name="M:Euclid.Solvers.SingleVariableSolver.NewtonRaphson.Solve(System.Double)">
            <summary>Solve the equation f(x)=target using the Newton-Raphson method</summary>
            <param name="target">the target</param>
        </member>
        <member name="T:Euclid.Solvers.SingleVariableSolver.Bracketing">
            <summary>Finds a root using root bracketing methods</summary>
        </member>
        <member name="M:Euclid.Solvers.SingleVariableSolver.Bracketing.#ctor(System.Double,System.Double,System.Func{System.Double,System.Double},Euclid.Solvers.SingleVariableSolver.BracketingMethod,System.Int32)">
            <summary>Builds a solver using root bracketing methods</summary>
            <param name="initialLowerBound">the lower bound of the initial interval</param>
            <param name="initialUpperBound">the upper bound of the initial interval</param>
            <param name="f">the function to solve for</param>
            <param name="method">the root bracketing method</param>
            <param name="maxIterations">the maximum number of iterations</param>
        </member>
        <member name="P:Euclid.Solvers.SingleVariableSolver.Bracketing.Function">
            <summary>Gets and sets the function to solve for </summary>
        </member>
        <member name="P:Euclid.Solvers.SingleVariableSolver.Bracketing.LowerBound">
            <summary>Gets and sets the lower bound of the interval</summary>
        </member>
        <member name="P:Euclid.Solvers.SingleVariableSolver.Bracketing.UpperBound">
            <summary>Gets and sets the upper bound of the interval</summary>
        </member>
        <member name="P:Euclid.Solvers.SingleVariableSolver.Bracketing.MaxIterations">
            <summary>Gets and sets the maximum number of iterations</summary>
        </member>
        <member name="P:Euclid.Solvers.SingleVariableSolver.Bracketing.Method">
            <summary>Gets and sets the root bracketing method</summary>
        </member>
        <member name="P:Euclid.Solvers.SingleVariableSolver.Bracketing.Tolerance">
            <summary>Gets and sets the tolerance for the target (threshold for target reached)</summary>
        </member>
        <member name="P:Euclid.Solvers.SingleVariableSolver.Bracketing.TrackConvergence">
            <summary>Gets and sets whether the details of the convergence are tracked</summary>
        </member>
        <member name="P:Euclid.Solvers.SingleVariableSolver.Bracketing.Error">
            <summary>Returns the final error</summary>
        </member>
        <member name="P:Euclid.Solvers.SingleVariableSolver.Bracketing.Result">
            <summary>The result of the solver</summary>
        </member>
        <member name="P:Euclid.Solvers.SingleVariableSolver.Bracketing.Status">
            <summary>The final status of the solver</summary>
        </member>
        <member name="P:Euclid.Solvers.SingleVariableSolver.Bracketing.Convergence">
            <summary>Gets the details of the convergence (value, error) </summary>
        </member>
        <member name="M:Euclid.Solvers.SingleVariableSolver.Bracketing.Solve">
            <summary>Solve the equation f(x)=0 using the root bracketing method</summary>
        </member>
        <member name="M:Euclid.Solvers.SingleVariableSolver.Bracketing.Solve(System.Double)">
            <summary>Solve the equation f(x)=target using the root bracketing method</summary>
            <param name="target">the target</param>
        </member>
        <member name="T:Euclid.Solvers.SingleVariableSolver.BracketingMethod">
            <summary>Specifies a root bracketing method</summary>
        </member>
        <member name="F:Euclid.Solvers.SingleVariableSolver.BracketingMethod.Dichotomy">
            <summary>the dichotomy root bracketing</summary>
        </member>
        <member name="F:Euclid.Solvers.SingleVariableSolver.BracketingMethod.FalsePosition">
            <summary>the false position root bracketing</summary>
        </member>
        <member name="T:Euclid.Solvers.SolverStatus">
            <summary>The status of a solver</summary>
        </member>
        <member name="F:Euclid.Solvers.SolverStatus.NotRan">
            <summary> The solver did not run </summary>
        </member>
        <member name="F:Euclid.Solvers.SolverStatus.FunctionConvergence">
            <summary> The solver stopped because the error value reached it's target</summary>
        </member>
        <member name="F:Euclid.Solvers.SolverStatus.GradientConvergence">
            <summary> The solver stopped because the error gradient reached it's target</summary>
        </member>
        <member name="F:Euclid.Solvers.SolverStatus.IterationExceeded">
            <summary> The solver exceeded its maximum iterations </summary>
        </member>
        <member name="F:Euclid.Solvers.SolverStatus.StationaryFunction">
            <summary> The solver exceeded the number of evaluation without substantial change in error value</summary>
        </member>
        <member name="F:Euclid.Solvers.SolverStatus.BadFunction">
            <summary> The function is not adapted to the solver's requirements </summary>
        </member>
        <member name="F:Euclid.Solvers.SolverStatus.Diverged">
            <summary> The solver diverged </summary>
        </member>
        <member name="T:Euclid.Function">
            <summary>Analytically differentiable function</summary>
        </member>
        <member name="M:Euclid.Function.#ctor(System.Func{Euclid.Vector,System.Double},System.Func{Euclid.Vector,Euclid.Vector})">
            <summary>Builds an analytically differentiable function</summary>
            <param name="value">the value function</param>
            <param name="gradient">the gradient</param>
        </member>
        <member name="P:Euclid.Function.Value">
            <summary>Returns the value function</summary>
        </member>
        <member name="P:Euclid.Function.Gradient">
            <summary>Returns the gradient function</summary>
        </member>
        <member name="M:Euclid.Function.op_Multiply(Euclid.Function,System.Double)">
            <summary>Builds a function made of the product of a function and a scalar</summary>
            <param name="func">the function</param>
            <param name="factor">the scalar</param>
            <returns>a <c>Function</c> </returns>
        </member>
        <member name="M:Euclid.Function.op_Multiply(System.Double,Euclid.Function)">
            <summary>Builds a function made of the product of a function and a scalar</summary>
            <param name="func">the function</param>
            <param name="factor">the scalar</param>
            <returns>a <c>Function</c> </returns>
        </member>
        <member name="M:Euclid.Function.op_Addition(Euclid.Function,System.Double)">
            <summary>Builds a function made of the addition of a function and a scalar</summary>
            <param name="func">the function</param>
            <param name="qty">the scalar</param>
            <returns>a <c>Function</c> </returns>
        </member>
        <member name="M:Euclid.Function.op_Addition(System.Double,Euclid.Function)">
            <summary>Builds a function made of the addition of a function and a scalar</summary>
            <param name="func">the function</param>
            <param name="qty">the scalar</param>
            <returns>a <c>Function</c> </returns>
        </member>
        <member name="M:Euclid.Function.op_Subtraction(Euclid.Function,System.Double)">
            <summary>Builds a function made of the substraction of a scalar to a function</summary>
            <param name="func">the function</param>
            <param name="qty">the scalar</param>
            <returns>a <c>Function</c> </returns>
        </member>
        <member name="M:Euclid.Function.op_Subtraction(System.Double,Euclid.Function)">
            <summary>Builds a function made of the substraction of a function to a scalar</summary>
            <param name="func">the function</param>
            <param name="qty">the scalar</param>
            <returns>a <c>Function</c> </returns>
        </member>
        <member name="M:Euclid.Function.op_Division(Euclid.Function,System.Double)">
            <summary>Builds a function made of the division of a function by a scalar</summary>
            <param name="func">the function</param>
            <param name="dividor">the dividor</param>
            <returns>a <c>Function</c> </returns>
        </member>
        <member name="M:Euclid.Function.op_Addition(Euclid.Function,Euclid.Function)">
            <summary>Builds a function made of the addition of two functions</summary>
            <param name="lhs">the left-hand side function</param>
            <param name="rhs">the right-hand side function</param>
            <returns>a <c>Function</c> </returns>
        </member>
        <member name="M:Euclid.Function.op_Subtraction(Euclid.Function,Euclid.Function)">
            <summary>Builds a function made of the substraction of two functions</summary>
            <param name="lhs">the left-hand side function</param>
            <param name="rhs">the right-hand side function</param>
            <returns>a <c>Function</c> </returns>
        </member>
        <member name="M:Euclid.Function.op_Division(Euclid.Function,Euclid.Function)">
            <summary>Builds a function made of the division of two functions</summary>
            <param name="lhs">the left-hand side function</param>
            <param name="rhs">the right-hand side function</param>
            <returns>a <c>Function</c> </returns>
        </member>
        <member name="M:Euclid.Function.Power(Euclid.Function,System.Double)">
            <summary>Elevates a function to a power</summary>
            <param name="func">the function</param>
            <param name="pow">the power</param>
            <returns>a Function</returns>
        </member>
        <member name="M:Euclid.Function.Sqrt(Euclid.Function)">
            <summary>Applies square root to a Function</summary>
            <param name="func">the function</param>
            <returns>a Function</returns>
        </member>
        <member name="M:Euclid.Function.Exp(Euclid.Function)">
            <summary>Applies exponential to a Function</summary>
            <param name="func">the function</param>
            <returns>a Function</returns>
        </member>
        <member name="M:Euclid.Function.Log(Euclid.Function)">
            <summary>Applies Log to a Function</summary>
            <param name="func">the function</param>
            <returns>a Function</returns>
        </member>
        <member name="M:Euclid.Function.Scalar(Euclid.Vector)">
            <summary>Builds a function operating a scalar product vs the given vector</summary>
            <param name="alt">the vector</param>
            <returns>a Function</returns>
        </member>
        <member name="M:Euclid.Function.Quadratic(Euclid.Matrix)">
            <summary>Builds a function operating a quadratic product over a given vector</summary>
            <param name="a">the matrix</param>
            <returns>a <c>Function</c></returns>
        </member>
        <member name="T:Euclid.Fn">
             This class contains physical constants and special functions not found
             in the System.Math class.
             Like the System.Math class this class is final and cannot be
             subclassed.
             All physical constants are in cgs units.
             NOTE: These special functions do not necessarily use the fastest
             or most accurate algorithms.
            
             @version $Revision: 1.8 $, $Date: 2005/09/12 09:52:34 $
        </member>
        <member name="F:Euclid.Fn.EulerGamma">
            <summary>The Euler-Mascheroni constant</summary>
            <remarks>lim(n -> inf){ Sum(k=1 -> n) { 1/k - log(n) } }</remarks>
        </member>
        <member name="F:Euclid.Fn.BOLTZMAN">
            <summary>Boltzman Constant. Units erg/deg(K)</summary>
        </member>
        <member name="F:Euclid.Fn.ECHARGE">
            <summary>Elementary Charge. Units statcoulomb</summary>
        </member>
        <member name="F:Euclid.Fn.EMASS">
            <summary>Electron Mass. Units g</summary>
        </member>
        <member name="F:Euclid.Fn.PMASS">
            <summary>
            Proton Mass. Units g 
            </summary>
        </member>
        <member name="F:Euclid.Fn.GRAV">
            <summary>Gravitational Constant. Units dyne-cm^2/g^2</summary>
        </member>
        <member name="F:Euclid.Fn.PLANCK">
            <summary>
            Planck constant. Units erg-sec 
            </summary>
        </member>
        <member name="F:Euclid.Fn.LIGHTSPEED">
            <summary> Speed of Light in a Vacuum. Units cm/sec </summary>
        </member>
        <member name="F:Euclid.Fn.STEFANBOLTZ">
            <summary>
            Stefan-Boltzman Constant. Units erg/cm^2-sec-deg^4 
            </summary>
        </member>
        <member name="F:Euclid.Fn.AVOGADRO">
            <summary>
            Avogadro Number. Units  1/mol 
            </summary>
        </member>
        <member name="F:Euclid.Fn.GASCONSTANT">
            <summary>
            Gas Constant. Units erg/deg-mol 
            </summary>
        </member>
        <member name="F:Euclid.Fn.GRAVACC">
            <summary>
            Gravitational Acceleration at the Earths surface. Units cm/sec^2 
            </summary>
        </member>
        <member name="F:Euclid.Fn.SOLARMASS">
            <summary>
            Solar Mass. Units g 
            </summary>
        </member>
        <member name="F:Euclid.Fn.SOLARRADIUS">
            <summary>
            Solar Radius. Units cm
            </summary>
        </member>
        <member name="F:Euclid.Fn.SOLARLUM">
            <summary>
            Solar Luminosity. Units erg/sec
            </summary>
        </member>
        <member name="F:Euclid.Fn.SOLARFLUX">
            <summary>
            Solar Flux. Units erg/cm^2-sec
            </summary>
        </member>
        <member name="F:Euclid.Fn.AU">
            <summary>
            Astronomical Unit (radius of the Earth's orbit). Units cm
            </summary>
        </member>
        <member name="M:Euclid.Fn.Norm(System.Double,System.Double)">
            <summary>
            More precise way of calculating the norm
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>the norm</returns>
        </member>
        <member name="M:Euclid.Fn.Acosh(System.Double)">
            <summary>
            Returns the hyperbolic arc cosine of the specified number.
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Euclid.Fn.Asinh(System.Double)">
            <summary>
            Returns the hyperbolic arc sine of the specified number.
            </summary>
            <param name="xx"></param>
            <returns></returns>
        </member>
        <member name="M:Euclid.Fn.Atanh(System.Double)">
            <summary>
            Returns the hyperbolic arc tangent of the specified number.
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Euclid.Fn.j0(System.Double)">
            <summary>Returns the Bessel function of order 0 of the specified number.</summary>
            <param name="x"></param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Fn.j1(System.Double)">
            <summary>
            Returns the Bessel function of order 1 of the specified number.
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Euclid.Fn.jn(System.Int32,System.Double)">
            <summary> Returns the Bessel function of order n of the specified number.</summary>
            <param name="n"></param>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Euclid.Fn.i0(System.Double)">
            <summary>Returns the modified Bessel function of first type and order 0 of the specified number.</summary>
            <param name="x"></param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Fn.i1(System.Double)">
            <summary>Returns the modified Bessel function of first type and order 1 of the specified number.</summary>
            <param name="x">the argument</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Fn.ik(System.Int32,System.Double)">
            <summary>Returns the modified Bessel function of first type and any order of the specified number.</summary>
            <param name="x">the argument</param>
            <param name="n">the order</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Fn.y0(System.Double)">
            <summary>Returns the Bessel function of the second kind, of order 0 of the specified number.</summary>
            <param name="x">the argument</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Fn.y1(System.Double)">
            <summary>Returns the Bessel function of the second kind, of order 1 of the specified number.</summary>
            <param name="x">the argument</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Fn.yn(System.Int32,System.Double)">
            <summary>Returns the Bessel function of the second kind, of order n of the specified number.</summary>
            <param name="n">the order</param>
            <param name="x">the argument</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Fn.Gamma(System.Double)">
            <summary>
            Returns the gamma function of the specified number.
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Euclid.Fn.IncompleteUpperGamma(System.Double,System.Double)">
            <summary>
            Returns the complemented incomplete gamma function.
            </summary>
            <param name="a"></param>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Euclid.Fn.IncompleteLowerGamma(System.Double,System.Double)">
            <summary>Returns the incomplete gamma function.</summary>
            <param name="a"></param>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Euclid.Fn.DiGamma(System.Double)">
            <summary>
            Returns the digamma (psi) function of real values (except at 0, -1, -2, ...).
            Digamma is the logarithmic derivative of the <see cref="M:Euclid.Fn.Gamma(System.Double)"/> function.
            </summary>
        </member>
        <member name="M:Euclid.Fn.Beta(System.Double,System.Double)">
            <summary>
            Returns the beta function
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Euclid.Fn.IncompleteRegularizedBeta(System.Double,System.Double,System.Double)">
            <summary>
            Return the incomplete regularized beta function
            </summary>
            <param name="t">the integral's upper bound</param>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Euclid.Fn.IncompleteBeta(System.Double,System.Double,System.Double)">
            <summary>
            Returns the incomplete beta function evaluated from zero to T.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Euclid.Fn.LogisticFunction(System.Double)">
            <summary>Evaluates the logistic function (sigmoïd) </summary>
            <param name="x">the evaluation point</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Fn.LogisticFunction(Euclid.Vector,Euclid.Vector)">
            <summary>Evaluates the logistic function (sigmoïd)</summary>
            <param name="theta">the scaling vector</param>
            <param name="x">the input vector</param>
            <returns></returns>
        </member>
        <member name="M:Euclid.Fn.Factorial(System.Int32)">
            <summary>Returns the factorial of the specified number</summary>
            <param name="j">the target number</param>
            <returns>the factorial</returns>
        </member>
        <member name="M:Euclid.Fn.Factorial(System.Int64)">
            <summary>Returns the factorial of the specified number</summary>
            <param name="j">the target number</param>
            <returns>the factorial</returns>
        </member>
        <member name="M:Euclid.Fn.stirf(System.Double)">
            <summary> Returns the gamma function computed by Stirling's formula</summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Euclid.Fn.chisq(System.Double,System.Double)">
            <summary> Returns the chi-square function (left hand tail)</summary>
            <param name="df">degrees of freedom</param>
            <param name="x">double value</param>
            <returns></returns>
        </member>
        <member name="M:Euclid.Fn.chisqc(System.Double,System.Double)">
            <summary>Returns the chi-square function (right hand tail)</summary>
            <param name="df">degrees of freedom</param>
            <param name="x">double value</param>
            <returns></returns>
        </member>
        <member name="M:Euclid.Fn.SupBrownianBridgeCDF(System.Double)">
            <summary>Computes the cumulative distribution(CDF) of the sup brownian bridge distribution at x, i.e.P(X ≤ x)</summary>
            <param name="x">the location at which to compute the function</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Fn.poisson(System.Int32,System.Double)">
            <summary>Returns the sum of the first k terms of the Poisson distribution</summary>
            <param name="k">number of terms</param>
            <param name="x">double value</param>
            <returns></returns>
        </member>
        <member name="M:Euclid.Fn.poissonc(System.Int32,System.Double)">
            <summary>Returns the sum of the terms k+1 to infinity of the Poisson distribution</summary>
            <param name="k">start</param>
            <param name="x">double value</param>
            <returns></returns>
        </member>
        <member name="M:Euclid.Fn.Phi(System.Double)">
            <summary>Computes the Phi function which is the cumulative distribution for the standard normal distribution</summary>
            <param name="x">The location at which to compute the Phi</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Fn.InvPhi(System.Double)">
            <summary>Computes the inverse of the Phi function</summary>
            <param name="p">The location at which to compute the inverse Phi function</param>
            <returns> a <c>double</c></returns>
        </member>
        <member name="M:Euclid.Fn.GaussBell(System.Double)">
            <summary>Computes the Gauss-bell function</summary>
            <param name="x">The location at which to compute the function</param>
            <returns>a <c>double</c></returns>
        </member>
        <member name="M:Euclid.Fn.EvaluatePolynomial(System.Double,System.Double[],System.Int32)">
            <summary>Evaluates polynomial of degree N</summary>
            <param name="x"></param>
            <param name="coef"></param>
            <param name="N"></param>
            <returns></returns>
        </member>
        <member name="M:Euclid.Fn.p1evl(System.Double,System.Double[],System.Int32)">
            <summary>Evaluates polynomial of degree N with assumtion that coef[N] = 1.0</summary>
            <param name="x"></param>
            <param name="coef"></param>
            <param name="N"></param>
            <returns></returns>		
        </member>
        <member name="M:Euclid.Fn.lgamma(System.Double)">
            <summary>Returns the natural logarithm of gamma function.</summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Euclid.Fn.incbcf(System.Double,System.Double,System.Double)">
            <summary>Returns the continued fraction expansion #1 for incomplete beta integral</summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Euclid.Fn.incbd(System.Double,System.Double,System.Double)">
            <summary>Returns the continued fraction expansion #2 for incomplete beta integral.</summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Euclid.Fn.PowerSeries(System.Double,System.Double,System.Double)">
            <summary>Returns the power series for incomplete beta integral. Use when b*x is small and x not too close to 1.</summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="T:Euclid.SparseMatrix">
            <summary>
            Matrix of double
            </summary>
        </member>
        <member name="M:Euclid.SparseMatrix.Create(System.Int32,System.Int32)">
            <summary> Builds a  sparse matrix filled with the specified value </summary>
            <param name="rows">the number of rows</param>
            <param name="cols">the number of columns</param>
        </member>
        <member name="P:Euclid.SparseMatrix.Columns">
            <summary>Returns the number of columns of the <c>Matrix</c></summary>
        </member>
        <member name="P:Euclid.SparseMatrix.Rows">
            <summary>Returns the number of rows of the <c>Matrix</c></summary>
        </member>
        <member name="P:Euclid.SparseMatrix.IsSquare">
            <summary>Specifies whether the <c>Matrix</c> is square</summary>
        </member>
        <member name="P:Euclid.SparseMatrix.CountNonZeros">
            <summary>Returns the number of non zero values in the <c>SparseMatrix</c></summary>
        </member>
        <member name="P:Euclid.SparseMatrix.Item(System.Int32,System.Int32)">
            <summary>Allows reading and modifying the coefficients of the <c>Matrix</c></summary>
            <param name="i">the row</param>
            <param name="j">the column</param>
            <returns>a double value</returns>
        </member>
        <member name="P:Euclid.SparseMatrix.Clone">
            <summary>Returns a deep copy of the <c>Matrix</c></summary>
        </member>
        <member name="T:Euclid.Text.Distance">
            <summary>Helps computing string distances</summary>
        </member>
        <member name="M:Euclid.Text.Distance.Levenshtein(System.String,System.String)">
            <summary>Compute the distance between two strings</summary>
        </member>
        <member name="M:Euclid.Text.Distance.Characters(System.String,System.String)">
            <summary>Returns the anagram-distance between two strings</summary>
            <param name="stringA">one string</param>
            <param name="stringB"></param>
            <returns></returns>
        </member>
        <member name="M:Euclid.Text.Distance.JaroWrinklerDistance(System.String,System.String)">
            <summary>
            Returns the Jaro-Winkler distance between the specified  
            strings. The distance is symmetric and will fall in the 
            range 0 (perfect match) to 1 (no match). 
            </summary>
            <param name="aString1">First String</param>
            <param name="aString2">Second String</param>
            <returns></returns>
        </member>
        <member name="M:Euclid.Text.Distance.JaroWrinklerProximity(System.String,System.String)">
            <summary>
            Returns the Jaro-Winkler distance between the specified  
            strings. The distance is symmetric and will fall in the 
            range 0 (no match) to 1 (perfect match). 
            </summary>
            <param name="aString1">First String</param>
            <param name="aString2">Second String</param>
            <returns></returns>
        </member>
        <member name="M:Euclid.Text.Distance.Metaphone(System.String)">
            <summary>Computes the metaphone version of a string</summary>
            <param name="name">the string to convert</param>
            <returns>a <c>String</c></returns>
        </member>
        <member name="T:Euclid.Vector">
            <summary>Vector of double class</summary>
        </member>
        <member name="P:Euclid.Vector.Size">
            <summary>Returns the Vector's size</summary>
        </member>
        <member name="P:Euclid.Vector.Data">
            <summary>Gets the Vector's components</summary>
        </member>
        <member name="P:Euclid.Vector.Item(System.Int32)">
            <summary>Gets a component of the Vector</summary>
            <param name="i">the index</param>
            <returns>a double</returns>
        </member>
        <member name="P:Euclid.Vector.Clone">
            <summary>Returns a deep copy of the Vector</summary>
        </member>
        <member name="P:Euclid.Vector.Norm1">
            <summary>Returns the sum of the absolute values</summary>
        </member>
        <member name="P:Euclid.Vector.Norm2">
            <summary>Returns the square root of the sum of squares</summary>
        </member>
        <member name="P:Euclid.Vector.NormSup">
            <summary>Returns the largest value of the <c>Matrix</c> in absolute value</summary>
        </member>
        <member name="P:Euclid.Vector.SumOfSquares">
            <summary>Returns the sum of the squared values</summary>
        </member>
        <member name="P:Euclid.Vector.Sum">
            <summary>Returns the sum of the values</summary>
        </member>
        <member name="M:Euclid.Vector.op_Multiply(Euclid.Vector,System.Double)">
            <summary>Multiplies a <c>Vector</c> by a scalar</summary>
            <param name="v">the left hand side <c>Vector</c></param>
            <param name="f">the scalar</param>
            <returns>the <c>Vector</c> result of the multiplication</returns>
        </member>
        <member name="M:Euclid.Vector.op_Multiply(System.Double,Euclid.Vector)">
            <summary>Multiplies a <c>Vector</c> by a scalar</summary>
            <param name="f">the scalar</param>
            <param name="v">the right hand side <c>Vector</c></param>
            <returns>the <c>Vector</c> result of the multiplication</returns>
        </member>
        <member name="M:Euclid.Vector.op_Division(Euclid.Vector,System.Double)">
            <summary>Divides all the coefficients of a <c>Vector</c> by a scalar</summary>
            <param name="v">the left hand side <c>Vector</c></param>
            <param name="f">the scalar</param>
            <returns>the <c>Vector</c> result of the division</returns>
        </member>
        <member name="M:Euclid.Vector.op_Multiply(Euclid.Matrix,Euclid.Vector)">
            <summary>Multiplies a Matrix by a Vector</summary>
            <param name="m">the left hand side <c>Matrix</c></param>
            <param name="v">the right hand side <c>Vector</c></param>
            <returns>the <c>Vector</c> result of the multiplication</returns>
        </member>
        <member name="M:Euclid.Vector.op_Multiply(Euclid.Vector,Euclid.Matrix)">
            <summary>Multiplies a Vector by a Matrix</summary>
            <param name="v">the left hand side <c>Vector</c></param>
            <param name="m">the right hand side <c>Matrix</c></param>
            <returns>the <c>Vector</c> result of the multiplication</returns>
        </member>
        <member name="M:Euclid.Vector.op_Multiply(Euclid.Vector,Euclid.Vector)">
            <summary>Multiplies a Vector by a Vector's transpose</summary>
            <param name="v1">the left hand side <c>Vector</c></param>
            <param name="v2">the right hand side <c>Vector</c></param>
            <returns>the <c>Matrix</c> result of the multiplication</returns>
        </member>
        <member name="M:Euclid.Vector.Add(Euclid.Vector,Euclid.Vector)">
            <summary>Performs a Vector addition, after going through dimension compatibility verifications.</summary>
            <param name="v1">First Vector</param>
            <param name="v2">Second Vector</param>
            <returns>The sum of m1 and m2</returns>
        </member>
        <member name="M:Euclid.Vector.Substract(Euclid.Vector,Euclid.Vector)">
            <summary>Performs a Vector substraction, after going through dimension compatibility verifications.</summary>
            <param name="v1">First Vector</param>
            <param name="v2">Second Vector</param>
            <returns>The difference of m1 and m2</returns>
        </member>
        <member name="M:Euclid.Vector.op_Addition(Euclid.Vector,System.Double)">
            <summary>Adds a scalar to all the coefficients of a <c>Vector</c></summary>
            <param name="v">the left hand side <c>Vector</c></param>
            <param name="c">the scalar</param>
            <returns>the <c>Vector</c> result of the addition</returns>
        </member>
        <member name="M:Euclid.Vector.op_Addition(System.Double,Euclid.Vector)">
            <summary>Adds a scalar to all the coefficients of a <c>Vector</c></summary>
            <param name="c">the scalar</param>
            <param name="v">the right hand side <c>Vector</c></param>
            <returns>the <c>Vector</c> result of the addition</returns>
        </member>
        <member name="M:Euclid.Vector.op_Subtraction(Euclid.Vector,System.Double)">
            <summary>Substracts a scalar to all the coefficients of a <c>Vector</c></summary>
            <param name="v">the left hand side <c>Vector</c></param>
            <param name="c">the scalar</param>
            <returns>the <c>Vector</c> result of the substraction</returns>
        </member>
        <member name="M:Euclid.Vector.op_Subtraction(System.Double,Euclid.Vector)">
            <summary>Adds a scalar to the opposite of a <c>Vector</c></summary>
            <param name="c">the scalar</param>
            <param name="v">the right hand side <c>Vector</c></param>
            <returns>the <c>Vector</c> result of the substraction</returns>
        </member>
        <member name="M:Euclid.Vector.op_UnaryNegation(Euclid.Vector)">
            <summary>Returns the opposite of the <c>Vector</c></summary>
            <param name="v">the input Vector</param>
            <returns>the <c>Vector</c> opposite</returns>
        </member>
        <member name="M:Euclid.Vector.op_Addition(Euclid.Vector,Euclid.Vector)">
            <summary>Performs the Vector addition</summary>
            <param name="v1">the left hand side Vector</param>
            <param name="v2">the right hand side Vector</param>
            <returns>a <c>Vector</c></returns>
        </member>
        <member name="M:Euclid.Vector.op_Subtraction(Euclid.Vector,Euclid.Vector)">
            <summary>Performs a Vector substraction</summary>
            <param name="v1">the left hand side</param>
            <param name="v2">the right hand side</param>
            <returns>the <c>Vector</c> result of the substraction</returns>
        </member>
        <member name="M:Euclid.Vector.Scalar(Euclid.Vector,Euclid.Vector)">
            <summary>Returns the scalar product of the Vectors</summary>
            <param name="v1">the left hand side</param>
            <param name="v2">the right hand side</param>
            <returns>a double value</returns>
        </member>
        <member name="M:Euclid.Vector.AggregateSum(System.Collections.Generic.IList{Euclid.Vector})">
            <summary>Aggregates a list of <c>Vector</c></summary>
            <param name="vectors">the vectors to sum</param>
            <returns>a <c>Vector</c></returns>
        </member>
        <member name="M:Euclid.Vector.Apply(System.Func{System.Double,System.Double})">
            <summary>Applies a function on the fields on a Vector</summary>
            <param name="method">the function to apply</param>
            <returns>a Vector</returns>
        </member>
        <member name="M:Euclid.Vector.Quadratic(Euclid.Vector,Euclid.Matrix,Euclid.Vector)">
            <summary>Computes a quadratic form product of two Vectors </summary>
            <param name="x">the left hand side Vector</param>
            <param name="a">the matrix</param>
            <param name="y">the right hand side Vector</param>
            <returns>a double</returns>
        </member>
        <member name="M:Euclid.Vector.Hadamard(Euclid.Vector,Euclid.Vector)">
            <summary>Returns the Hadamard product</summary>
            <param name="v1">the left hand side</param>
            <param name="v2">the right hand side</param>
            <returns>a <c>Vector</c> containing the Hadamard product</returns>
        </member>
        <member name="M:Euclid.Vector.Max(Euclid.Vector,Euclid.Vector)">
            <summary>Builds a Vector made of the highest values </summary>
            <param name="v1">a Vector</param>
            <param name="v2">a Vector</param>
            <returns>a Vector</returns>
        </member>
        <member name="M:Euclid.Vector.Min(Euclid.Vector,Euclid.Vector)">
            <summary>Builds a Vector made of the smallest values </summary>
            <param name="v1">a Vector</param>
            <param name="v2">a Vector</param>
            <returns>a Vector</returns>
        </member>
        <member name="M:Euclid.Vector.Bound(Euclid.Vector,Euclid.Vector,Euclid.Vector)">
            <summary>Builds a Vector made of the values bounded</summary>
            <param name="lowBound">the lower bounds</param>
            <param name="upBound">the upper bounds</param>
            <param name="x">the vector to bound</param>
            <returns>a <c>Vector</c></returns>
        </member>
        <member name="M:Euclid.Vector.ExtractIthDimension(Euclid.Vector,System.Int32)">
            <summary>Builds a vector set at zero, except for the sought dimension</summary>
            <param name="vector">the input vector</param>
            <param name="dimension">the sought dimension</param>
            <returns>a <c>Vector</c></returns>
        </member>
        <member name="M:Euclid.Vector.LinearCombination(System.Double[],Euclid.Vector[])">
            <summary>Builds a Vector as a linear combination of vectors</summary>
            <param name="factors">the factors</param>
            <param name="vectors">the vectors</param>
            <returns>the Vector result of Sum i  fi*mi</returns>
        </member>
        <member name="M:Euclid.Vector.Create(System.Double,Euclid.Vector,System.Double,Euclid.Vector)">
            <summary>Creates a Vector made from the linear combination of two vectors</summary>
            <param name="f1">the left hand side factor</param>
            <param name="v1">the left hand side vector</param>
            <param name="f2">the right hand side factor</param>
            <param name="v2">the right hand side vector</param>
            <returns>a <c>Vector</c> containing the linear combination of the input</returns>
        </member>
        <member name="M:Euclid.Vector.Create(System.Double,Euclid.Vector,System.Double,Euclid.Vector,System.Double,Euclid.Vector)">
            <summary>Creates a Vector made from the linear combination of three vectors</summary>
            <param name="f1">the first factor</param>
            <param name="v1">the first vector</param>
            <param name="f2">the second factor</param>
            <param name="v2">the second vector</param>
            <param name="f3">the third factor</param>
            <param name="v3">the third vector</param>
            <returns>a <c>Vector</c> containing the linear combination of the input</returns>
        </member>
        <member name="M:Euclid.Vector.Create(System.Double[])">
            <summary>Creates a Vector from a set of data</summary>
            <param name="data">the data set</param>
            <returns>a Vector</returns>
        </member>
        <member name="M:Euclid.Vector.Create(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>Creates a Vector from a list of data</summary>
            <param name="data">the data set</param>
            <returns>a Vector</returns>
        </member>
        <member name="M:Euclid.Vector.Create(System.Int32)">
            <summary>Creates an Vector full of zeros </summary>
            <param name="size">the Vector's size</param>
            <returns>a Vector</returns>
        </member>
        <member name="M:Euclid.Vector.Create(System.Int32,System.Double)">
            <summary>Creates a Vector </summary>
            <param name="size">the Vector's size</param>
            <param name="value">the value for all components</param>
            <returns>a Vector</returns>
        </member>
        <member name="M:Euclid.Vector.CreateBaseVector(System.Int32,System.Int32)">
            <summary>Creates a vector that is equal to zero (0.0) everywhere and one (1.0) for the given index</summary>
            <param name="size">the vector's size</param>
            <param name="index">the index of the non zero value</param>
            <returns>a <c>Vector</c></returns>
        </member>
        <member name="M:Euclid.Vector.CreateRandom(System.Int32,Euclid.Distributions.Continuous.ContinuousDistribution)">
            <summary>Creates a Vector full of random variables  </summary>
            <param name="size">the vector's size</param>
            <param name="distribution">the distribution</param>
            <returns></returns>
        </member>
        <member name="M:Euclid.Vector.Equals(Euclid.Vector)">
            <summary>Determines whether the specified object is equal to the current object</summary>
            <param name="other">the object to compare with the current object</param>
            <returns><c>true</c> if the specified object is equal to the current object; otherwise, <c>false</c></returns>
        </member>
        <member name="M:Euclid.Vector.ToString">
            <summary>Returns a string that represents the vector</summary>
            <returns>a string that represents the vector</returns>
        </member>
        <member name="M:Euclid.Vector.ToString(System.String)">
            <summary>Returns a string that represents the vector</summary>
            <returns>a string that represents the vector</returns>
        </member>
    </members>
</doc>
